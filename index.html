<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Canadian Wealth &amp; Income Dashboard</title>
  <!-- Open Graph tags make the site attractive when shared on social media -->
  <meta property="og:title" content="Canadian Wealth &amp; Income Dashboard" />
  <meta property="og:description" content="Explore detailed charts of Canadian median income, net worth by age, wealth distribution and more. Built using multiple data sources for the most comprehensive view available." />
  <meta property="og:image" content="https://example.com/share-image.png" />
  <meta property="og:type" content="website" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    :root{
      /* Core UI (from image) */
      --bg-main:#0F172A;       /* Slate 900 */
      --bg-panel:#111827;      /* Gray 900 */
      --bg-muted:#1F2933;      /* Muted gray */

      --text-primary:#F9FAFB;
      --text-secondary:#CBD5E1;
      --text-muted:#94A3B8;

      --primary:#2563EB;
      --primary-soft:#93C5FD;
      --primary-dark:#1E40AF;

      /* Percentiles (image vibe) */
      --p10:#06B6D4;  /* cyan (new, fits palette) */
      --p25:#3B82F6;  /* blue (new, fits palette) */
      --p50:#22C55E;  /* green (from image) */
      --p75:#EAB308;  /* amber (from image) */
      --p90:#F97316;  /* orange (from image) */

      /* Wealth lines (from image) */
      --wealth-core:#38BDF8;
      --wealth-upper:#818CF8;
      --wealth-elite:#C084FC;

      /* Marker */
      --user-marker:#F43F5E;

      /* Optional chart chrome */
      --chart-grid:rgba(148,163,184,.18);
      --chart-axis:rgba(203,213,225,.65);
      --chart-tooltip-bg:#0B1220;
      --chart-tooltip-border:rgba(148,163,184,.25);

      /* Unified surfaces */
      --bg-base: #0b1a33;
      --bg-surface: rgba(255,255,255,0.06);
      --bg-surface-hover: rgba(255,255,255,0.08);
      --bg-surface-active: rgba(255,255,255,0.10);
      --border-subtle: rgba(255,255,255,0.12);
      --border-focus: rgba(0, 220, 200, 0.55);
      --accent: #00dcc8;
    }
    /* Info icon and tooltip */
    .info-icon { 
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: transparent;
      color: #00bfa5;
      margin-left: 8px;
      cursor: pointer;
      position: relative;
      outline: none;
      vertical-align: middle;
      flex-shrink: 0;
      visibility: visible !important;
      opacity: 1 !important;
    }
    .info-icon svg {
      width: 1rem;
      height: 1rem;
      flex-shrink: 0;
      color: #00bfa5;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    .info-icon .info-tooltip { 
      visibility: hidden;
      opacity: 0;
      transition: opacity .15s ease;
      position: absolute;
      right: 100%;
      left: auto;
      transform: none;
      top: calc(100% + 8px);
      background: rgba(7, 18, 39, 0.98);
      color: #e0e6ed;
      padding: 12px 16px;
      border-radius: 8px;
      max-width: 900px;
      font-size: 0.85rem;
      line-height: 1.6;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
      z-index: 9999;
      text-align: left;
      pointer-events: none;
      white-space: normal;
      word-wrap: break-word;
    }
    /* Special positioning for the View as tooltip: top-left of box to bottom-right of icon */
    #unitInfoIcon .info-tooltip {
      left: 100%;
      right: auto;
      top: 100%;
      transform: translate(6px, 4px);
      max-width: 900px !important;
      width: 700px !important;
    }
    .info-icon:hover .info-tooltip, .info-icon:focus .info-tooltip, .info-icon.focused .info-tooltip { 
      visibility: visible;
      opacity: 1;
      pointer-events: auto;
    }
    .info-tooltip::after { 
      content: '';
      position: absolute;
      top: -6px;
      right: 10px;
      transform: none;
      border-width: 6px;
      border-style: solid;
      border-color: transparent transparent rgba(7, 18, 39, 0.98) transparent;
      left: auto;
    }
    #unitInfoIcon .info-tooltip::after {
      left: 10px;
      right: auto;
      top: -6px;
      border-color: transparent transparent rgba(7, 18, 39, 0.98) transparent;
    }

    /* Custom Chart.js external tooltip styles (tactile, elevated, responsive) */
    .chartjs-tooltip {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, 8px) translateZ(0);
      min-width: 120px;
      max-width: 420px;
      background: linear-gradient(180deg, rgba(7,18,39,0.98), rgba(10,16,28,0.98));
      border: 1px solid rgba(255,255,255,0.04);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      box-shadow: 0 12px 36px rgba(2,6,23,0.7);
      font-size: 0.85rem;
      line-height: 1.3;
      z-index: 2000;
      opacity: 0;
      transition: opacity 140ms ease, transform 140ms ease;
      will-change: transform, opacity;
    }
    .chartjs-tooltip.show {
      opacity: 1;
    }
    .chartjs-tooltip .tt-title { font-weight:700; color: var(--accent); margin-bottom:6px; }
    .chartjs-tooltip .tt-body { display:flex; flex-direction:column; gap:6px; }
    .chartjs-tooltip .tt-row { display:flex; align-items:center; gap:8px; }
    .chartjs-tooltip .tt-swatch { width:10px; height:10px; border-radius:2px; flex:0 0 10px; }
    .chartjs-tooltip .tt-value { color: var(--text); font-weight:600; }
    .chartjs-tooltip .tt-row.highlight { background: linear-gradient(90deg, rgba(41,182,246,0.06), rgba(0,0,0,0)); padding:6px 8px; border-radius:6px; }
    .chartjs-tooltip .tt-row .tt-label { color: var(--muted); font-size:0.85rem; }
    .chartjs-tooltip .tt-row.highlight .tt-label { color: var(--accent); font-weight:700; }

    /* Snapshot button */
    .snapshot-btn { display:inline-block; margin:12px 0 0 0; padding:6px 12px; font-size:0.85rem; border-radius:999px; border:1px solid rgba(255,255,255,0.06); background: rgba(7,18,39,0.6); color:#dbefff; cursor:pointer; }
    .snapshot-btn:hover { box-shadow: 0 6px 18px rgba(0,191,165,0.08); }

    /* Footer */
    footer.site-footer { margin-top:28px; padding:18px 0; text-align:center; color:#9fb6c8; font-size:0.85rem; border-top:1px solid rgba(255,255,255,0.03); }
    footer.site-footer a { color:#9fb6c8; }

    /* Global styles */
    body {
      background: var(--bg-base);
      color: #e0e6ed;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      overflow-x: hidden;
    }
    html { scroll-behavior: smooth; }
    .container {
      max-width: 100%;
      margin: 0 auto;
      padding: 20px 0;
    }
    .content-width {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 16px;
      box-sizing: border-box;
    }
    .hero{
      text-align:center;
      padding: 28px 16px 18px;
      max-width: 980px;
      margin: 0 auto;
    }
    .page-brand{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-size: clamp(32px, 4.5vw, 48px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-secondary);
      margin-bottom: 12px;
      display: inline-block;
    }
    .page-brand .brand-wealth{ font-weight: 800; }
    .page-brand .brand-rest{ font-weight: 400; opacity: 0.95; }

    .page-subtitle{
      max-width: 820px;
      margin: 0 auto 12px;
      font-size: 18px;
      line-height: 1.5;
      color: var(--text-secondary);
    }

    .hero-meta{
      display: inline-flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .meta-pill{
      background: rgba(148,163,184,.10);
      border: 1px solid rgba(148,163,184,.16);
      color: var(--text-secondary);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 13px;
      letter-spacing: 0.02em;
    }

    .meta-dot{
      color: rgba(203,213,225,.55);
      font-size: 14px;
    }
    /* Chart card styling */
    .charts-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 28px;
      justify-content: center;
      box-sizing: border-box;
      width: 100%;
    }
    .references-section { margin-top: 28px; }
    .references-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 16px; }
    .reference-block { background: var(--bg-surface); border: 1px solid var(--border-subtle); border-radius: 12px; padding: 16px 18px; color: var(--text-secondary); }
    .reference-title { font-weight: 700; color: var(--text-primary); margin-bottom: 6px; }
    .reference-links { display: flex; flex-direction: column; gap: 4px; }
    .reference-links a { color: #6aa3f4; }
    .chart-card {
      background: var(--bg-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      padding: 22px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.22);
      min-height: 380px;
      transition: box-shadow 0.25s ease, opacity 0.25s ease, background 0.2s ease;
      will-change: box-shadow, opacity;
      flex: 1 1 calc(50% - 24px);
      max-width: 620px;
      min-width: 360px;
      position: relative;
      overflow: visible;
    }
    .chart-card:hover {
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
      background: var(--bg-surface-hover);
    }
    .chart-card h3 {
      margin: 0 0 10px;
      font-size: clamp(0.9rem, 1.9vw, 1.02rem);
      color: #00bfa5;
      display: flex;
      align-items: center;
      overflow: visible;
      white-space: normal;
      position: relative;
      z-index: 1;
    }
    .chart-container {
      position: relative;
      width: 100%;
      aspect-ratio: 1.618 / 1;
      padding-bottom: 0px; /* minimize reserved space; handled via chart padding */
    }
    .chart-card canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    @media (max-width: 960px) {
      .chart-card { flex: 1 1 100%; max-width: 100%; }
    }
    /* Footnotes */
    .footnotes {
      margin-top: 16px;
      font-size: 0.78rem;
      line-height: 1.36;
      color: var(--text-secondary);
      background: var(--bg-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .footnotes a {
      color: #6aa3f4;
    }
    .source-box {
      margin-top: 12px;
      margin-bottom: 12px;
      background: var(--bg-surface);
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      transition: all 0.25s ease;
      color: var(--text-secondary);
    }
    .source-box summary {
      cursor: pointer;
      font-weight: 600;
      color: #9fb6c8;
      list-style: none;
      font-size: 0.9rem;
    }
    .source-box summary::marker {
      display: none;
    }
    .source-box summary::-webkit-details-marker {
      display: none;
    }
    .source-box summary::after {
      content: '?';
      float: right;
      font-size: 0.9rem;
      /* Fainter arrow colour */
      color: rgba(156,180,204,0.65);
      transition: transform 0.2s ease;
    }
    .source-box[open] summary::after {
      transform: rotate(-180deg);
    }
    .chart-footer-row{
      display:flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      gap:0px;
      margin-top: 8px;
      flex-wrap: nowrap;
      position: relative;
    }
    .chart-footer-sources{ display:block; width:100%; }
    .chart-footer-row .source-box{
      margin: 0;
      padding: 8px 10px;
      border-radius: 12px;
      flex: none;
      min-width: 0;
      position: relative;
    }
    .chart-footer-row .source-box summary{
      font-size: 0.85rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .chart-footer-row .source-box .source-content{
      display: none;
      position: static;
      width: 100%;
      max-height: none;
      overflow: visible;
      margin-top: 10px;
      border-radius: 0;
      padding: 0;
      box-shadow: none;
      z-index: auto;
      background: transparent;
      border: none;
    }
    .chart-footer-row .source-box[open]{
      flex-basis: auto;
    }
    .chart-footer-row .source-box[open] .source-content{
      display: block;
    }
    .source-content {
      margin-top: 12px;
      color: var(--text-secondary);
      font-size: 0.85rem;
      border-top: 1px solid var(--border-subtle);
      padding-top: 12px;
    }
    .source-content ul {
      margin-top: 4px;
      padding-left: 1.2rem;
    }
    /* Top controls: compact, two-row responsive layout */
    .top-controls {
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      margin-bottom: 18px;
    }
    .controls-row, .projection-row {
      display:flex;
      gap:12px;
      width:100%;
      justify-content:center;
      flex-wrap:wrap;
      align-items:center;
    }
    .control-group { display:flex; gap:8px; align-items:center; }
    .control-group label { font-weight:600; color:#d7eaf9; }
    .control-group input[type="number"], .control-group select {
      padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:#071229; color:#e6f4ff;
      box-shadow: none; outline: none; min-width:60px;
    }
    .btn-primary { padding:10px 14px; border-radius:10px; border:none; cursor:pointer; font-weight:600; line-height:1.2; }
    .btn-compare { background:#ef5350; color:#fff; }
    .btn-reset { background:#455a64; color:#fff; }
    .btn-project { background:#ef5350; color:#fff; }
    .insight-panel { width:100%; }
    @media (min-width:880px) {
      .controls-row { justify-content:space-between; }
      .controls-left, .controls-center, .controls-right { flex:1; }
      .controls-center { justify-content:center; display:flex; }
      .controls-right { display:flex; justify-content:flex-end; }
      .projection-row { justify-content:space-between; }
    }
    /* Profile card and result tiles */
    .profile-card {
      width:100%;
      max-width:100%;
      background: var(--bg-surface);
      padding:16px;
      border-radius:16px;
      border:1px solid var(--border-subtle);
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      box-sizing:border-box;
    }
    .controls-grid {
      display: grid;
      grid-template-columns: 1.2fr 1.2fr 0.7fr 1.3fr 1.3fr auto;
      gap: 14px;
      align-items: end;
    }
    .control-group { display:flex; flex-direction:column; gap:8px; min-width:0; }
    .control-label { font-size: 0.95rem; opacity: 0.9; letter-spacing: 0.2px; color:#d7eaf9; }
    .control-label .label-sub { display:block; font-size: 0.82rem; opacity: 0.7; line-height:1.2; }
    .control-input, .control-select {
      height: 44px;
      padding: 0 14px;
      border-radius: 12px;
      background: var(--bg-surface);
      border: 1px solid var(--border-subtle);
      color: #e6f4ff;
      outline: none;
      box-sizing: border-box;
      width: 100%;
    }
    .control-input:focus, .control-select:focus {
      border-color: var(--border-focus);
      box-shadow: 0 0 0 3px rgba(0, 220, 200, 0.12);
    }
    .control-actions { display:flex; gap:12px; align-items:stretch; justify-content:flex-end; align-self:stretch; }
    .control-actions button { height:44px; padding: 0 14px; }
    .input-warning{
      margin-top:8px;
      font-size:12px;
      color:#fca5a5;
      min-height: 16px;
    }
    @media (max-width:1100px) {
      .controls-grid { grid-template-columns: 1fr 1fr 0.7fr 1fr 1fr; }
      .control-actions { grid-column: 1 / -1; justify-content:flex-end; margin-top:6px; }
    }
    @media (max-width: 640px) {
      .controls-grid { grid-template-columns: 1fr; }
      .control-actions { justify-content:stretch; flex-direction:column; }
      .control-actions button { width:100%; }
    }
    /* Result cards (aligned with hero pills but rectangular) */
    .results-grid { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 14px; margin-top: 14px; width:100%; }
    @media (max-width: 980px) { .results-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (max-width: 640px) { .results-grid { grid-template-columns: 1fr; } }
    .metric-card {
      background: var(--bg-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 18px;
      padding: 16px 18px;
      min-height: 112px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 6px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      color: var(--text-secondary);
    }
    .metric-card:hover { box-shadow: 0 10px 28px rgba(0,0,0,0.16); background: var(--bg-surface-hover); }
    .metric-label { font-size: 0.95rem; opacity: 0.9; text-align:center; }
    .metric-value { font-size: 1.9rem; font-weight: 800; line-height: 1.1; color: var(--text-primary); text-align:center; }
    .metric-sub { font-size: 0.9rem; opacity: 0.8; text-align:center; }
    .section-divider { height:1px; background: rgba(255,255,255,0.08); margin: 18px 0 24px; }

    /* Projection section */
    .projection-section { margin-top:12px; width:100%; max-width:100%; background: var(--bg-surface); padding:12px; border-radius:12px; border:1px solid var(--border-subtle); }
    .proj-cards { display:flex; gap:12px; margin-top:12px; }
    .proj-card { flex:1; background: var(--bg-surface); padding:10px; border-radius:10px; border:1px solid var(--border-subtle); text-align:center; }
    .proj-card .label { color:#9fb6c8; font-size:0.85rem; }
    .proj-card .value { color:#e6f4ff; font-weight:700; font-size:1.25rem; margin-top:6px; }
  </style>
  <link rel="stylesheet" href="./styles.css">
</head>
<body>
  <div class="container">
    <section class="hero">
      <div class="page-brand" aria-label="WealthDashboard.ca">
        <span class="brand-wealth">WEALTH</span><span class="brand-rest">DASHBOARD.CA</span>
      </div>

      <p class="page-subtitle">
        Compare your income and net worth to Canadians by age, province, and percentile using public datasets and transparent assumptions.
      </p>

      <div class="hero-meta">
        <span class="meta-pill">All values in CAD</span>
        <span class="meta-dot">•</span>
        <span class="meta-pill">Updated to 2026</span>
      </div>
    </section>

    <!-- Profile card: region, unit, age, income, net worth -->
    <div class="content-width">
    <section id="section-inputs">
    <div class="profile-card">
      <div class="controls-grid">
        <div class="control-group">
          <label class="control-label" for="provinceSelect">Region</label>
          <select id="provinceSelect" class="control-select">
            <option value="Canada">Canada</option>
            <option value="Newfoundland & Labrador">Newfoundland & Labrador</option>
            <option value="Prince Edward Island">Prince Edward Island</option>
            <option value="Nova Scotia">Nova Scotia</option>
            <option value="New Brunswick">New Brunswick</option>
            <option value="Quebec">Quebec</option>
            <option value="Ontario">Ontario</option>
            <option value="Manitoba">Manitoba</option>
            <option value="Saskatchewan">Saskatchewan</option>
            <option value="Alberta">Alberta</option>
            <option value="British Columbia">British Columbia</option>
          </select>
        </div>
        <div class="control-group">
          <label class="control-label" for="unitSelect">View as</label>
          <div style="display:flex; align-items:center; gap:8px;">
            <select id="unitSelect" class="control-select">
              <option value="households" selected>Households</option>
              <option value="individuals">Individuals</option>
            </select>
            <span class="info-icon" tabindex="0" role="button" aria-label="Info: Household vs Individual scaling" id="unitInfoIcon">
              <svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg>
              <span class="info-tooltip" style="max-width:280px; width:auto;">
                Household income shows the combined income of everyone living together.

                Individual income adjusts this to reflect what a typical person in that household would have. The dashboard uses the square-root equivalence scale: income / sqrt(household size).

                Canada's average household has about 2.4 people, so individual income = household income / sqrt(2.4). This method is standard in Statistics Canada and OECD income comparisons.
              </span>
            </span>
          </div>
        </div>
        <div class="control-group">
          <label class="control-label" for="userAge">Age</label>
          <input id="userAge" type="number" min="18" max="100" class="control-input" />
        </div>
        <div class="control-group">
          <label class="control-label" for="userIncome"><span class="label-main">Annual Income</span> <span class="label-sub">(before tax)</span></label>
          <input id="userIncome" type="number" step="1000" max="1000000" class="control-input" />
        </div>
        <div class="control-group">
          <label class="control-label" for="userNetWorth">Net worth</label>
          <input id="userNetWorth" type="number" step="1000" max="100000000" class="control-input" />
        </div>
        <div class="control-actions">
          <button id="compareBtn" class="btn-primary btn-compare">Compare</button>
          <button id="resetBtn" class="btn-primary btn-reset">Reset</button>
        </div>
      </div>
      <div id="inputWarning" class="input-warning" aria-live="polite"></div>
    </div>
    </section>
    </div>

    <!-- Percentile tiles - separate section placed under inputs -->
    <section id="section-percentiles" aria-live="polite">
      <div class="results-grid" id="resultTiles" style="display:none;">
        <div class="metric-card" id="incomePctTile">
          <div class="metric-label">Income percentile</div>
          <div id="incomePercentileValue" class="metric-value tile-value">—</div>
          <div id="incomePercentileSubtext" class="metric-sub tile-sub">of peers</div>
        </div>
        <div class="metric-card" id="netPctTile">
          <div class="metric-label">Net worth percentile</div>
          <div id="netWorthPercentileValue" class="metric-value tile-value">—</div>
          <div id="netWorthPercentileSubtext" class="metric-sub tile-sub">of peers</div>
        </div>
        <div class="metric-card" id="avgIncomeTile">
          <div class="metric-label">Average income at selected age</div>
          <div id="avgIncomeValue" class="metric-value tile-value">—</div>
          <div id="avgIncomeSubtext" class="metric-sub tile-sub">for - ? age -</div>
        </div>
        <div class="metric-card" id="medianIncomeTile">
          <div class="metric-label">Median income at selected age</div>
          <div id="medianIncomeValue" class="metric-value tile-value">—</div>
          <div id="medianIncomeSubtext" class="metric-sub tile-sub">for - ? age -</div>
        </div>
        <div class="metric-card" id="avgNetWorthTile">
          <div class="metric-label">Average net worth at selected age</div>
          <div id="avgNetWorthValue" class="metric-value tile-value">—</div>
          <div id="avgNetWorthSubtext" class="metric-sub tile-sub">for - ? age -</div>
        </div>
        <div class="metric-card" id="medianNetWorthTile">
          <div class="metric-label">Median net worth at selected age</div>
          <div id="medianNetWorthValue" class="metric-value tile-value">—</div>
          <div id="medianNetWorthSubtext" class="metric-sub tile-sub">for - ? age -</div>
        </div>
      </div>
    </section>

    <div class="section-divider"></div>

    <!-- Future Net Worth Projection section -->
    <section id="section-projections">
    <div class="projection-section" id="projectionSection" style="display:none;">
      <div style="display:flex; align-items:center; gap:12px; justify-content:space-between;">
        <div style="font-weight:700; color:#bfe0ff;">Future Net Worth Projection</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <label for="savingsRate" style="color:#9fb6c8;">Savings rate (% of gross income)</label>
          <input id="savingsRate" type="number" min="0" max="100" step="0.1" style="width:90px;" />
          <label for="targetAge" style="color:#9fb6c8; margin-left:6px;">Target age</label>
          <input id="targetAge" type="number" min="18" max="100" value="65" style="width:60px;" />
          <button id="projectBtn" class="btn-primary btn-project" style="margin-left:8px;">Project</button>
        </div>
      </div>
      <div class="proj-cards">
        <div class="proj-card" id="projCard"><div class="label">Projected net worth</div><div class="value">-</div></div>
        <div class="proj-card" id="median65Card"><div class="label">Projected median at target</div><div class="value">-</div></div>
        <div class="proj-card" id="requiredRateCard"><div class="label">Required savings rate</div><div class="value">-</div></div>
      </div>
      <details id="projectionAssumptions" class="source-box" style="width:100%; margin-top:12px;">
        <summary>Projection Assumptions & Formula</summary>
        <div class="source-content">
          <p>Percentile baselines (median, 75th, 90th) are 2026 values and are projected forward to the year you reach the target age using a constant nominal growth rate of <strong>5.0% per year</strong>:</p>
          <p style="font-family:monospace;">futurePercentile = currentPercentile * (1 + 0.05)^(yearsToTarget)</p>
          <p><em>yearsToTarget</em> = target age - your current age. These projections assume steady real growth and do not model shocks, taxes, or behavioural changes; the savings projection uses its own return assumption.</p>
        </div>
      </details>
    </div>
    </section>
    <div class="content-width">
    <section id="section-income-charts">
    <div class="charts-grid">
      <!-- Median Income Chart (2026 estimate) -->
      <div class="chart-card">
        <h3 id="incomeTitle">Estimated Median Employment Income by Age (Individuals, 2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Estimated 2026 employment income by age with percentile ranges."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows estimated 2026 employment income by age, including median and percentile ranges, adjusted for your selected province and household/individual view.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="incomeChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Canadian Income Survey (employment income by age)</li>
              <li>Canada Revenue Agency - wage growth trends</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>2022 income levels are adjusted to 2026 based on recent wage growth and inflation guidance.</li>
              <li>Statistics Canada publishes income by 5-year age brackets; values for individual ages are smoothed between these brackets.</li>
              <li>Percentiles (10th, 25th, median, 75th, 90th) are calculated by scaling the median pattern.</li>
              <li>Results update automatically when the user selects a different province or household/individual view.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Income composition breakdown chart (2026) -->
      <div class="chart-card">
        <h3 id="compositionTitle">Median Income Composition by Age (Households, 2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Income composition by age."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows how employment income, investment income, pensions, and transfers contribute to total income at each age.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="compositionChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Canadian Income Survey</li>
              <li>Survey of Household Spending</li>
              <li>CRA pension and benefit statistics</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Income sources (employment, investment income, pensions, transfers) follow age patterns published by Statistics Canada.</li>
              <li>Total income adjusts for the selected province and household/individual view.</li>
              <li>Values between anchor ages are smoothed to form a continuous curve.</li>
            </ul>
          </div>
        </details>
      </div>

      </div>
    </section>

    <section id="section-networth-charts">
      <div class="charts-grid">
      <!-- Median Net Worth Chart (2026 estimate) -->
      <div class="chart-card">
        <h3 id="netWorthTitle">Estimated Median Net Worth by Age (Households, 2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Estimated 2026 net worth by age with percentile ranges."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows estimated 2026 median net worth by age, including typical accumulation during working years and gradual drawdown in retirement, adjusted for your selected province and household/individual view.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="netWorthChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Survey of Financial Security</li>
              <li>Bank of Canada - inflation outlook</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Statistics Canada publishes net worth by broad age groups; a smooth curve is created for single ages by estimating the change between these groups.</li>
              <li>The curve is projected to 2026 using inflation expectations.</li>
              <li>After around age 65, values gradually decrease to reflect typical retirement drawdown.</li>
              <li>Percentiles (10th, 25th, median, 75th, 90th) are created by scaling the median pattern.</li>
              <li>Results update automatically based on the selected province and household/individual view.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Income vs Net Worth Scatter Plot (2026) -->
      <div class="chart-card">
        <h3 id="scatterTitle">Median Income vs Net Worth by Age (Households, 2026) - Canada
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Income and net worth relationship by age."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows how median income at each age relates to median net worth, using consistent smoothing and inflation adjustments.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="scatterChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Canadian Income Survey</li>
              <li>Survey of Financial Security</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Each point combines the median income and median net worth for the same age.</li>
              <li>Values follow the same smoothing and inflation-adjustment approach used in the income and wealth charts.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Net Worth Distribution (Histogram) -->
      <div class="chart-card">
        <h3 id="percentileNetWorthTitle">Net Worth Distribution (Histogram, 2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Net worth distribution histogram."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows the estimated distribution of household net worth in 2026 for your selected province and household/individual view.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="percentileNetWorthChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Survey of Financial Security</li>
              <li>Bank of Canada - inflation adjustments</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Percentile points across the wealth distribution are used to build a smooth distribution curve.</li>
              <li>This curve is divided into evenly sized bins to show the estimated distribution of net worth in 2026.</li>
              <li>Values update when selecting a different province or household/individual view.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Income Distribution (Histogram) -->
      <div class="chart-card">
        <h3 id="percentileIncomeTitle">Income Distribution (Histogram, 2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Income distribution histogram."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows the estimated distribution of employment income in 2026 for your selected province and household/individual view.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="percentileIncomeChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Canadian Income Survey</li>
              <li>CRA tax-filer percentile tables</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Published income percentiles are used to build a smooth distribution curve.</li>
              <li>The curve is divided into income ranges (bins) to show how earnings are distributed across the population.</li>
              <li>Results adjust based on the selected province and household/individual view.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Wealth Composition by Age (stacked area) -->
      <div class="chart-card">
        <h3 id="wealthCompositionTitle">Median Wealth Composition by Age (Households, 2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Wealth composition by age."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows how real estate, financial assets, pensions, and debt typically change with age, along with resulting net worth.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="wealthCompositionChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Survey of Financial Security</li>
              <li>CMHC and Bank of Canada - household credit statistics</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Real estate, financial assets, pensions, and debt follow age patterns in the Survey of Financial Security.</li>
              <li>Values are smoothed across ages and updated for the selected province and household/individual view.</li>
              <li>Net worth is displayed as a line across the stacked asset and debt areas.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Income Percentile by Gender -->
      <div class="chart-card">
        <h3 id="genderIncomeTitle">Income Percentile by Gender (2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Median income by gender and age."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Compares women's and men's median employment income by age, adjusted for province and household/individual view.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="genderIncomeChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Canadian Income Survey (by sex)</li>
              <li>CRA tax-filer benchmarks</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Women-s median income is shown relative to men using the most recent national ratio.</li>
              <li>The same smoothing, provincial adjustments, and household/individual view options apply as in the main income chart.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Projected Median Net Worth by Province (2026) -->
      <div class="chart-card">
        <h3 id="provinceTitle">Projected Median Net Worth by Province (2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Projected 2026 median net worth by province with percentile whiskers."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows projected 2026 median net worth by province, with whiskers marking the 10th and 90th percentile ranges.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="provinceChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Survey of Financial Security (provincial detail)</li>
              <li>Bank of Canada - inflation guidance</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Provincial net worth medians are projected to 2026 in constant dollars.</li>
              <li>Percentile ranges are shown as whiskers for the 10th and 90th percentiles.</li>
              <li>Values adjust for household/individual view selection.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Median Income by Province (2026) -->
      <div class="chart-card">
        <h3 id="provinceIncomeTitle">Median Income by Province (2026)
          <span class="info-icon" tabindex="0" role="button" aria-label="Chart info: Median income by province with percentile whiskers."><svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="12" cy="12" r="9" stroke="#00bfa5" stroke-width="1.4" fill="none"></circle><text x="12" y="15" text-anchor="middle" fill="#00bfa5" font-size="10" font-weight="bold">i</text></svg><span class="info-tooltip">Shows median employment income across provinces in 2026, with whiskers marking the 10th and 90th percentile ranges.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="provinceIncomeChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Sources &amp; Methods</summary>
          <div class="source-content">
            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada - Canadian Income Survey (provincial medians)</li>
              <li>CRA tax-filer percentile ratios</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Provincial income differences are based on Statistics Canada medians.</li>
              <li>Percentile ranges use CRA ratios and are shown as whiskers for the 10th and 90th percentiles.</li>
              <li>Values adjust for household/individual view.</li>
            </ul>
          </div>
        </details>
      </div>

      </div>
    </section>
    </div>
    <section id="sources-links" class="references-section">
      <div class="content-width">
      <h2 style="margin:0 0 12px; color:#bfe0ff;">References</h2>
      <div class="references-grid">
        <div class="reference-block">
          <div class="reference-title">Statistics Canada - Income Data</div>
          <div class="reference-links">
            <a href="https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=1110019001" target="_blank">Canadian Income Survey - Employment Income (Table 11-10-0190-01)</a>
            <a href="https://www150.statcan.gc.ca/t1/tbl1/en/cv.action?pid=1110019001" target="_blank">Income by Age, Sex, Province (CIS)</a>
          </div>
        </div>
        <div class="reference-block">
          <div class="reference-title">Statistics Canada - Wealth & Net Worth</div>
          <div class="reference-links">
            <a href="https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=1110001601" target="_blank">Survey of Financial Security - Net Worth by Asset Category (Table 11-10-0016-01)</a>
            <a href="https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=1110006501" target="_blank">Survey of Financial Security - Net Worth by Age Group (Table 11-10-0065-01)</a>
          </div>
        </div>
        <div class="reference-block">
          <div class="reference-title">Statistics Canada - Spending & Transfers</div>
          <div class="reference-links">
            <a href="https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=1110022301" target="_blank">Survey of Household Spending (Table 11-10-0223-01)</a>
          </div>
        </div>
        <div class="reference-block">
          <div class="reference-title">Canada Revenue Agency (CRA)</div>
          <div class="reference-links">
            <a href="https://www.canada.ca/en/revenue-agency/services/tax/statistics/income-statistics-gst-hst-statistics/t1-final-statistics.html" target="_blank">T1 Final Statistics - Income Percentiles</a>
            <a href="https://www.canada.ca/en/revenue-agency/services/forms-publications/publications/t4130.html" target="_blank">CRA Pension & Benefit Amounts</a>
          </div>
        </div>
        <div class="reference-block">
          <div class="reference-title">Bank of Canada</div>
          <div class="reference-links">
            <a href="https://www.bankofcanada.ca/monetary-policy-report/" target="_blank">Inflation Outlook & Monetary Policy Report</a>
          </div>
        </div>
        <div class="reference-block">
          <div class="reference-title">CMHC - Housing & Debt Statistics</div>
          <div class="reference-links">
            <a href="https://www.cmhc-schl.gc.ca/en/professionals/housing-markets-data-and-research/data-tables" target="_blank">Mortgage Debt & Household Credit Indicators</a>
          </div>
        </div>
      </div>
      </div>
    </section>
  <script src="scripts/vibe-utils.js"></script>
  <script src="scripts/chart-strategies.js"></script>
  <script>
    // Plugin to draw box-and-whisker style whiskers for the province chart.
    const provinceWhiskersPlugin = {
      id: 'provinceWhiskers',
      afterDatasetsDraw: function(chart, args, options) {
        if (['provinceChart','provinceIncomeChart'].indexOf(chart.canvas.id) === -1) return;
        const whiskers = chart._whiskers;
        if (!whiskers) return;
        const ctx = chart.ctx;
        const yScale = chart.scales.y;
        const meta = chart.getDatasetMeta(0);
        if (!meta || !meta.data) return;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        for (let i = 0; i < meta.data.length; i++) {
          const el = meta.data[i];
          const x = el.x;
          const p10 = whiskers.p10 && whiskers.p10[i] !== undefined ? whiskers.p10[i] : null;
          const p90 = whiskers.p90 && whiskers.p90[i] !== undefined ? whiskers.p90[i] : null;
          if (p10 === null || p90 === null) continue;
          const yTop = yScale.getPixelForValue(p90);
          const yBottom = yScale.getPixelForValue(p10);
          // Vertical whisker line
          ctx.beginPath();
          ctx.moveTo(x, yTop);
          ctx.lineTo(x, yBottom);
          ctx.stroke();
          // Caps
          ctx.beginPath(); ctx.moveTo(x - 8, yTop); ctx.lineTo(x + 8, yTop); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(x - 8, yBottom); ctx.lineTo(x + 8, yBottom); ctx.stroke();
        }
        ctx.restore();
      }
    };
    Chart.register(provinceWhiskersPlugin);

    // Format currency helper (required by tooltip handler)
    function fmtDollar(v) {
      if (v === null || v === undefined) return '$0';
      const num = Number(v);
      if (isNaN(num)) return '$0';
      return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(num);
    }

    // External HTML tooltip handler for Chart.js - tactile, responsive and reusable.
    function externalTooltipHandler(context) {
      try {
        const { chart, tooltip } = context;
        // Attach tooltip to document.body to avoid clipping inside canvas containers
        const root = document.body;
        let tooltipEl = root.querySelector('.chartjs-tooltip');
        if (!tooltipEl) {
          tooltipEl = document.createElement('div');
          tooltipEl.className = 'chartjs-tooltip';
          tooltipEl.style.position = 'absolute';
          tooltipEl.style.pointerEvents = 'none';
          root.appendChild(tooltipEl);
        }

        // Hide if no tooltip
        if (!tooltip || tooltip.opacity === 0) {
          tooltipEl.classList.remove('show');
          return;
        }

        const isHistogram = chart?.canvas?.id === 'percentileNetWorthChart' || chart?.canvas?.id === 'percentileIncomeChart';

        // Special-case histogram charts: show value + percentile, suppress y-value
        if (isHistogram && tooltip.dataPoints && tooltip.dataPoints.length) {
          const dp = tooltip.dataPoints[0];
          const valX = dp.parsed?.x ?? 0;
        const distCurve = chart.options?.plugins?.distCurve;
        const pctIdx = (distCurve && distCurve.length) ? findPercentileIndex(valX, distCurve) : 0;
        const pct = Math.min(99, Math.max(1, pctIdx + 1));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        const valueLabel = `${fmtDollar(valX)} - ${toOrdinal(pct)} percentile`;
          let html = '<div class="tt-body">';
          const color = dp.element?.options?.borderColor || dp.dataset?.borderColor || dp.dataset?.backgroundColor || '#29b6f6';
          html += `<div class="tt-row highlight"><div class="tt-swatch" style="background:${color};"></div><div><div class="tt-label">${dp.dataset?.label || ''}</div><div class="tt-value">${valueLabel}</div></div></div>`;
          html += '</div>';
          tooltipEl.innerHTML = html;
          const canvasRect = chart.canvas.getBoundingClientRect();
          const left = canvasRect.left + window.scrollX + (tooltip.caretX ?? (canvasRect.width / 2));
          const top = canvasRect.top + window.scrollY + (tooltip.caretY ?? 0);
          tooltipEl.style.left = left + 'px';
          tooltipEl.style.top = (top + 12) + 'px';
          tooltipEl.classList.add('show');
          return;
        }

          // Build tooltip content (defensive access)
          const titleLines = Array.isArray(tooltip.title) ? tooltip.title : (tooltip.title ? [tooltip.title] : []);
          const bodyItems = (tooltip.dataPoints && tooltip.dataPoints.length) ? Array.from(tooltip.dataPoints) : [];
          // Fallback: if Chart.js didn't provide dataPoints (some versions/configs),
          // reconstruct rows from the active x-label using chart datasets.
          if (!bodyItems.length && titleLines.length && chart && chart.data && Array.isArray(chart.data.labels)) {
            const xLabel = titleLines[0];
            const idx = chart.data.labels.indexOf(String(xLabel));
            if (idx >= 0) {
              chart.data.datasets.forEach((ds, dsi) => {
                try {
                  const meta = chart.getDatasetMeta ? chart.getDatasetMeta(dsi) : null;
                  if (meta && meta.hidden) return; // skip hidden datasets
                  const rawVal = Array.isArray(ds.data) ? ds.data[idx] : (ds.data && ds.data[idx]);
                  const element = (meta && meta.data && meta.data[idx]) ? meta.data[idx] : null;
                  bodyItems.push({ dataset: ds, parsed: { y: rawVal }, element });
                } catch (reconErr) {
                  // ignore per-dataset reconstruction errors
                }
              });
            }
          }
          // If still no body items, try locating closest x-index using caretX and
          // dataset point pixel positions (works when tooltip title doesn't match labels).
          if (!bodyItems.length && chart && typeof tooltip.caretX === 'number' && chart.data && Array.isArray(chart.data.labels)) {
            try {
              const labelsLen = chart.data.labels.length;
              let nearestIdx = -1;
              let bestScore = Infinity;
              for (let i = 0; i < labelsLen; i++) {
                let sumDist = 0;
                let count = 0;
                for (let d = 0; d < chart.data.datasets.length; d++) {
                  try {
                    const meta = chart.getDatasetMeta ? chart.getDatasetMeta(d) : null;
                    const el = meta && meta.data && meta.data[i] ? meta.data[i] : null;
                    if (!el) continue;
                    const ex = el.x;
                    if (typeof ex === 'number') { sumDist += Math.abs(ex - tooltip.caretX); count++; }
                  } catch (inner) { /* ignore per-dataset element errors */ }
                }
                if (count > 0) {
                  const avg = sumDist / count;
                  if (avg < bestScore) { bestScore = avg; nearestIdx = i; }
                }
              }
              if (nearestIdx >= 0) {
                chart.data.datasets.forEach((ds, dsi) => {
                  try {
                    const meta = chart.getDatasetMeta ? chart.getDatasetMeta(dsi) : null;
                    if (meta && meta.hidden) return; // skip hidden
                    const rawVal = Array.isArray(ds.data) ? ds.data[nearestIdx] : (ds.data && ds.data[nearestIdx]);
                    const element = (meta && meta.data && meta.data[nearestIdx]) ? meta.data[nearestIdx] : null;
                    bodyItems.push({ dataset: ds, parsed: { y: rawVal }, element });
                  } catch (reconErr) { /* ignore */ }
                });
              }
            } catch (e) {
              // defensive - don't break tooltip
            }
          }
          let html = '';
          if (titleLines.length) {
            html += `<div class="tt-title">${titleLines.map(t => String(t)).join(' - ')}</div>`;
          }

          // Determine the closest dataset item to the caret (so we can highlight it)
          let closestIndex = -1;
          try {
            if (bodyItems.length && typeof tooltip.caretX === 'number' && typeof tooltip.caretY === 'number') {
              let minDist = Infinity;
              bodyItems.forEach((it, i) => {
                const ex = it.element?.x ?? it.x ?? it.caretX ?? null;
                const ey = it.element?.y ?? it.y ?? it.caretY ?? null;
                if (ex === null || ey === null) return;
                const dx = (ex - tooltip.caretX);
                const dy = (ey - tooltip.caretY);
                const d = Math.hypot(dx, dy);
                if (d < minDist) { minDist = d; closestIndex = i; }
              });
            }
          } catch (pickErr) {
            closestIndex = -1;
          }

          if (bodyItems.length) {
            // Sort tooltip rows so Median sits between 25th and 75th percentiles
            const percentileOrder = (label='', datasetIndex=999) => {
              const lbl = String(label).toLowerCase();
              if (lbl.includes('you')) return 1000;
              if (lbl.includes('90th')) return 0;
              if (lbl.includes('75th')) return 1;
              if (lbl.includes('median')) return 2; // keep median centered
              if (lbl.includes('50th')) return 2;
              if (lbl.includes('25th')) return 3;
              if (lbl.includes('10th')) return 4;
              const m = lbl.match(/(\\d+)(st|nd|rd|th)?\\s*percentile/);
              if (m) return Math.max(0, 100 - parseInt(m[1], 10)); // higher percentile first
              return 500 + datasetIndex; // default stable order after percentiles
            };
            const isGenderChart = chart?.canvas?.id === 'genderIncomeChart';
            const sortedItems = bodyItems.slice().sort((a, b) => {
              if (isGenderChart) {
                const key = (it) => String(it?.dataset?.label || it?.label || '').toLowerCase().trim();
                const rankMap = new Map([
                  ['men p90', 0],
                  ['women p90', 1],
                  ['men (median)', 2],
                  ['women (median)', 3],
                  ['men p10', 4],
                  ['women p10', 5],
                ]);
                const ra = rankMap.has(key(a)) ? rankMap.get(key(a)) : 999;
                const rb = rankMap.has(key(b)) ? rankMap.get(key(b)) : 999;
                if (ra !== rb) return ra - rb;
                return String(a?.dataset?.label || a?.label || '').localeCompare(String(b?.dataset?.label || b?.label || ''));
              }
              return (
                percentileOrder(a.dataset?.label || a.label, a.datasetIndex ?? 999) -
                percentileOrder(b.dataset?.label || b.label, b.datasetIndex ?? 999)
              );
            });
            const highlightItem = (closestIndex >=0) ? bodyItems[closestIndex] : null;
            const highlightIndex = highlightItem ? sortedItems.indexOf(highlightItem) : -1;
            html += '<div class="tt-body">';
            sortedItems.forEach((item, idx) => {
              try {
                const label = (item.dataset && item.dataset.label) ? item.dataset.label : (item.label || '');
                const parsed = item.parsed;
                const value = (parsed && (parsed.y !== undefined)) ? parsed.y : (parsed ?? item.raw ?? '');
                const color = (item.element && item.element.options && (item.element.options.borderColor || item.element.options.backgroundColor)) || item.dataset?.borderColor || item.dataset?.backgroundColor || '#29b6f6';
                const isHighlight = idx === highlightIndex;
                html += `<div class="tt-row${isHighlight ? ' highlight' : ''}"><div class="tt-swatch" style="background:${color};"></div><div><div class="tt-label">${label}</div><div class="tt-value">${fmtDollar(Number(value))}</div></div></div>`;
              } catch (innerE) {
                // ignore row build errors and continue
              }
            });
            html += '</div>';
          } else if (Array.isArray(tooltip.body) && tooltip.body.length) {
            // Fallback: parse tooltip.body lines (string) to display something useful
            html += '<div class="tt-body">';
            tooltip.body.forEach((bline, idx) => {
              const txt = (bline.lines && bline.lines.join(' ')) || String(bline);
              html += `<div class="tt-row"><div class="tt-label">${txt}</div></div>`;
            });
            html += '</div>';
          }

          tooltipEl.innerHTML = html;

          // Positioning: caretX/caretY are relative to the canvas. Use page coordinates.
          const canvasRect = chart.canvas.getBoundingClientRect();
          const left = canvasRect.left + window.scrollX + (tooltip.caretX ?? (canvasRect.width / 2));
          const top = canvasRect.top + window.scrollY + (tooltip.caretY ?? 0);
          // Keep tooltip within viewport horizontally
          tooltipEl.style.left = left + 'px';
          tooltipEl.style.top = (top + 12) + 'px';
          tooltipEl.classList.add('show');
      } catch (err) {
        // Defensive: do not allow tooltip errors to break chart rendering
        console.warn('Tooltip handler error', err);
      }
    }

    // Install as default tooltip handler so all charts use the same tactile tooltip.
    if (Chart && Chart.defaults && Chart.defaults.plugins && Chart.defaults.plugins.tooltip) {
      // Disable the built-in canvas tooltip drawing - we'll render with the DOM external handler.
      Chart.defaults.plugins.tooltip.enabled = false;
      Chart.defaults.plugins.tooltip.external = externalTooltipHandler;
      Chart.defaults.plugins.tooltip.position = 'nearest';
      Chart.defaults.plugins.tooltip.mode = 'index';
      Chart.defaults.plugins.tooltip.intersect = false;
    }

    // ============================== Data Metric Abstraction ================================
    // A DataMetric encapsulates a base time series (median) and associated percentile
    // arrays for a given metric (e.g., employment income, net worth).  It exposes
    // methods to scale the values by a region ratio and optionally apply a unit
    // multiplier (e.g., converting individuals to households).  Encapsulating
    // percentile data in one object dramatically reduces the number of global
    // arrays and makes it trivial to add new metrics without duplicating
    // hundreds of lines of code.
    class DataMetric {
      constructor(name, baseValues, percentiles = {}, unit = 'individuals') {
        this.name = name;
        this.baseValues = baseValues;
        this.percentiles = percentiles;
        this.unit = unit;
      }
      // Scale the median series by a region-specific ratio.  Returns a new
      // array of rounded values.
      getScaledMedian(ratio) {
        return this.baseValues.map(v => Math.round(v * ratio));
      }
      // Scale a single percentile array by the ratio.  If the percentile
      // isn't defined for this metric, null is returned.
      getScaledPercentile(p, ratio) {
        const arr = this.percentiles[p];
        if (!arr) return null;
        return arr.map(v => Math.round(v * ratio));
      }
      // Return an object containing the scaled median and a subset of
      // percentile arrays.  selectedPercentiles defines which percentile
      // keys (e.g., 'p10','p25','p75','p90') to include.  Missing
      // percentiles are simply omitted.
      getAllScaledData(ratio, selectedPercentiles = ['p10','p25','p75','p90']) {
        const median = this.getScaledMedian(ratio);
        const pcts = {};
        selectedPercentiles.forEach(p => {
          const scaled = this.getScaledPercentile(p, ratio);
          if (scaled) pcts[p] = scaled;
        });
        return { median, percentiles: pcts };
      }
      // Apply a unit multiplier (e.g., households vs individuals) to an
      // already scaled data object.  Returns a new object so that
      // DataMetric instances remain immutable.  If multiplier is 1, the
      // original data object is returned.
      applyUnitScaling(data, multiplier = 1) {
        if (multiplier === 1) return data;
        const median = data.median.map(v => Math.round(v * multiplier));
        const pcts = {};
        Object.keys(data.percentiles).forEach(k => {
          pcts[k] = data.percentiles[k].map(v => Math.round(v * multiplier));
        });
        return { median, percentiles: pcts };
      }
    }

    // Registry to keep track of all DataMetric instances.  This simplifies
    // metric discovery and ensures there is exactly one source of truth for
    // each metric.  Adding a metric requires registering a new DataMetric
    // instance with a key.
    class MetricRegistry {
      constructor() {
        this.metrics = new Map();
      }
      register(key, metric) {
        this.metrics.set(key, metric);
        return this;
      }
      get(key) {
        const m = this.metrics.get(key);
        if (!m) throw new Error('Metric not found: ' + key);
        return m;
      }
      all() {
        return Array.from(this.metrics.values());
      }
    }

    /* ============================================================================
     * CHANGE LOG:
     * 
     * 2025-12-06: Implemented DataMetric/MetricRegistry for scalability
     *   - Reduced data array complexity from 70+ to encapsulated classes
     *   - Maintained 100% backward compatibility
     *   - ChartUpdater class added with updateIncomeChart/updateNetWorthChart methods
     * 
     * In Progress:
     *   [ ] Extract remaining chart update logic to ChartUpdater methods
     *   [ ] Implement strategy pattern for all 8 charts
     *   [ ] Add performance caching layer
     *   [ ] Complete DataMetric migration from all charts
     * ============================================================================ */

    // ChartUpdater encapsulates the logic to update individual charts.  Each
    // chart type gets its own method so that updateCharts() no longer
    // contains hundreds of lines of repetitive scaling and dataset creation.
    class ChartUpdater {
      constructor(metrics, ratios) {
        this.metrics = metrics;
        this.incomeRatios = ratios.income || {};
        this.netWorthRatios = ratios.netWorth || {};
      }
      // Build datasets for the median and selected percentiles.  The
      // colorMap parameter maps percentile keys to colours (see
      // percentileColors) and selectedPcts specifies which percentile
      // series to include.  Median is always added first.
      buildPercentileDatasets(data, colorMap, selectedPcts) {
        const datasets = [];
        datasets.push({
          label: 'Median',
          data: data.median,
          borderColor: colorMap.p50 || '#29b6f6',
          backgroundColor: 'transparent',
          pointRadius: 0,
          pointHoverRadius: 4,
          tension: 0.35
        });
        selectedPcts.forEach(p => {
          if (p === 'p50') return;
          const arr = data.percentiles[p];
          if (!arr) return;
          let label;
          switch (p) {
            case 'p10': label = '10th Percentile'; break;
            case 'p25': label = '25th Percentile'; break;
            case 'p75': label = '75th Percentile'; break;
            case 'p90': label = '90th Percentile'; break;
            case 'p99': label = '99th Percentile'; break;
            default: label = p;
          }
          datasets.push({
            label: label,
            data: arr,
            borderColor: colorMap[p],
            backgroundColor: 'transparent',
            pointRadius: 0,
            pointHoverRadius: 4,
            tension: 0.35
          });
        });
        return datasets;
      }
      // Update the employment income chart using DataMetric scaling and
      // percentile logic.  Handles unit conversion, user overlay and
      // automatic axis computation.  selectedPcts should exclude 'p50'.
      updateIncomeChart(region, unit, selectedPcts, userActive, userIncome) {
        const ratio = this.incomeRatios[region] || 1;
        const metric = this.metrics.get('employmentIncome');
        let scaledData = metric.getAllScaledData(ratio, selectedPcts);
        if (unit === 'households') {
          scaledData = metric.applyUnitScaling(scaledData, EQUIVALENCE_SCALE);
        }
        const datasets = this.buildPercentileDatasets(scaledData, percentileColors.income, selectedPcts);
        // Only add the 'You' marker after the user submits a comparison.
        if (userActive && userIncome) {
          const youData = new Array(ageLabels.length).fill(null);
          const ua = (typeof userAgeVal === 'number' ? userAgeVal : parseInt(document.getElementById('userAge')?.value,10) || 18);
          const idx = Math.max(0, Math.min(ageLabels.length - 1, ua - 18));
          youData[idx] = userIncome;
          datasets.push({
            label: 'You',
            data: youData,
            borderColor: '#ff6b6b',
            backgroundColor: '#ff6b6b',
            pointRadius: 6,
            pointHoverRadius: 8,
            showLine: false,
            order: 9999
          });
        }
        if (incomeChartInstance) {
          incomeChartInstance.data.labels = ageLabels;
          incomeChartInstance.data.datasets = datasets;
          // Determine axis bounds from median and selected percentiles.  Zero
          // should remain the lower bound for incomes.
          let vals = scaledData.median.slice();
          selectedPcts.forEach(p => {
            if (p !== 'p50' && scaledData.percentiles[p]) {
              vals = vals.concat(scaledData.percentiles[p]);
            }
          });
          if (userActive && userIncome) vals.push(userIncome);
          const axis = computeAxis(vals, 5000);
          incomeChartInstance.options.scales.y.min = Math.min(0, axis.min);
          incomeChartInstance.options.scales.y.max = axis.max;
          incomeChartInstance.options.scales.y.title.text = unit === 'households'
            ? 'Median Employment Income ($ - Households)'
            : 'Median Employment Income ($ - Individuals)';
          incomeChartInstance.update();
        }
      }
      // Update the net worth chart.  Determines the correct metric (households vs
      // individuals), preserves the user overlay, and computes axis bounds that include zero to
      // ensure negative values are visible.
      updateNetWorthChart(region, unit, selectedPcts, userActive, userNetWorth) {
        const ratio = this.netWorthRatios[region] || 1;
        const metricKey = (unit === 'households') ? 'netWorth' : 'indNetWorth';
        const metric = this.metrics.get(metricKey);
        const scaledData = metric.getAllScaledData(ratio, selectedPcts);
        const colorMap = (unit === 'households') ? percentileColors.netWorth : percentileColors.indNetWorth;
        const datasets = this.buildPercentileDatasets(scaledData, colorMap, selectedPcts);
        if (userActive && userNetWorth) {
          // Show a single red dot at the user's age rather than a full horizontal line.
          const youData = new Array(ageLabels.length).fill(null);
          const ua = (typeof userAgeVal === 'number' ? userAgeVal : parseInt(document.getElementById('userAge')?.value,10) || 18);
          const idx = Math.max(0, Math.min(ageLabels.length - 1, ua - 18));
          youData[idx] = userNetWorth;
          datasets.push({
            label: 'You',
            data: youData,
            borderColor: '#ff6b6b',
            backgroundColor: '#ff6b6b',
            pointRadius: 6,
            pointHoverRadius: 8,
            showLine: false,
            order: 9999
          });
        }
        if (netWorthChartInstance) {
          netWorthChartInstance.data.labels = ageLabels;
          netWorthChartInstance.data.datasets = datasets;
          let vals = scaledData.median.slice();
          selectedPcts.forEach(p => {
            if (p !== 'p50' && scaledData.percentiles[p]) {
              vals = vals.concat(scaledData.percentiles[p]);
            }
          });
          // Include zero line to ensure axis includes zero
          if (userActive && userNetWorth) vals.push(userNetWorth);
          const axis = computeAxis(vals, 200000);
          netWorthChartInstance.options.scales.y.min = axis.min;
          netWorthChartInstance.options.scales.y.max = axis.max;
          netWorthChartInstance.options.scales.y.title.text = unit === 'households'
            ? 'Median Net Worth ($ - Households)'
            : 'Median Net Worth ($ - Individuals)';
          netWorthChartInstance.update();
        }
      }
    }
    
    /* ============================================================================
     * VIBE PROMPT TEMPLATE (copy & modify for requests):
     * 
     * I want to [ACTION: add/change/remove/optimize] [COMPONENT: chart/data/styling]
     * Context: [WHY: describe the change]
     * Affected areas: [WHERE: lines or functions]
     * Test validation: [HOW TO VERIFY: what should work after change]
     * Constraints: [ANY LIMITS: performance, compatibility, etc]
     * 
     * Example:
     * I want to CHANGE the income percentile colors
     * Context: Make the 75th/90th percentiles more distinct
     * Affected: percentileColors.income (line ~870)
     * Test: Line colors should update on region dropdown change
     * Constraints: Must remain accessible/readable on dark background
     * ============================================================================ */

    // Data definitions for 2026 smoothed estimates
    // Age labels for 18-80 inclusive
    const ageLabels = [
      '18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50','51','52','53','54','55','56','57','58','59','60','61','62','63','64','65','66','67','68','69','70','71','72','73','74','75','76','77','78','79','80'
    ];
    const BASE_YEAR = 2026;
    const PRIOR_BASE_YEAR = 2025;
    const INCOME_GROWTH_NOMINAL = 0.03;    // 1-year forward projection for 2026
    const NET_WORTH_GROWTH_NOMINAL = 0.05; // 1-year forward projection for 2026
    const SPENDING_GROWTH_NOMINAL = 0.025; // 1-year forward projection for 2026
    const DEFAULT_HOUSEHOLD_SIZE = 2.4; // Canada average persons per household
    const EQUIVALENCE_SCALE = Math.sqrt(DEFAULT_HOUSEHOLD_SIZE); // square-root equivalence
    const USD_TO_CAD_2024 = 1.34; // 2024 average USD/CAD reference from Bank of Canada
    
    // ? QUICK SWAP: Chart colors (percentileColors object, line ~1320)
    // ? QUICK SWAP: Provincial labels (baseProvinceLabels, line ~1050)
    // ? QUICK SWAP: Spending estimates (provinceSpendingEstimates, line ~1160)
    // ? QUICK SWAP: Percentile ratios (provincePctRatios, line ~1850)
    // ? QUICK SWAP: Equivalence scale (EQUIVALENCE_SCALE, line above)
    // ? QUICK SWAP: USD/CAD rate (USD_TO_CAD_2024, line above)
    /*
     * Base datasets for Canada. These arrays serve as the foundation for all
     * regions; when a province is selected, values are scaled by the appropriate
     * income or net worth ratio. The earliest ages are adjusted to reflect
     * typical negative or low net worth in early adulthood.
     */
    let baseIncome = [
      25000,27500,30000,32500,35000,37188,39375,41562,43750,45938,48125,50312,52500,53450,54400,55350,56300,57250,58200,59150,60100,61050,62000,62200,62400,62600,62800,63000,62800,62600,62400,62200,62000,61100,60200,59300,58400,57500,56600,55700,54800,53900,53000,51700,50400,49100,47800,46500,45200,43900,42600,41300,40000,38500,37000,35500,34000,32500,31000,29500,28000,26500,25000
    ];

    // Base total income values (all sources) for 2026 (2025 values projected forward 1 year @ 3% nominal).
    // Reflects estimated median total income by age, including wages, investment returns, pensions and government
    // transfers. Anchor points were chosen at ages 18, 22, 30, 40, 45, 50, 60, 65, 70, 75 and 80 based on typical
    // earnings patterns and average retirement incomes reported by senior households. Linear interpolation was used
    // between anchors to create a smooth curve across ages. See Methods for a full explanation.
    let baseTotalIncome = [
      26000,28250,30500,32750,35000,37500,40000,42500,45000,47500,50000,52500,55000,56500,58000,59500,61000,62500,64000,65500,67000,68500,70000,70400,70800,71200,71600,72000,71600,71200,70800,70400,70000,69000,68000,67000,66000,65000,64000,63000,62000,61000,60000,59000,58000,57000,56000,55000,54000,53000,52000,51000,50000,49000,48000,47000,46000,45000,44000,43000,42000,41000,40000
    ];

    const incomeGrowthFactor = 1 + INCOME_GROWTH_NOMINAL;
    baseIncome = baseIncome.map(v => Math.round(v * incomeGrowthFactor));
    baseTotalIncome = baseTotalIncome.map(v => Math.round(v * incomeGrowthFactor));
    // Compute median net worth by age using compound interpolation between
    // SFS anchor medians. This replaces the prior static array and preserves
    // exact values at the anchor ages. The estimator uses the formula:
    //   value(age) = A_value * (B_value / A_value)^((age - A_age)/(B_age - A_age))
    // which is the compound interpolation (equivalent to constant CAGR
    // between anchors). Anchors below/above the provided range are
    // extrapolated using the nearest interval's CAGR.
    //
    // Anchors supplied (SFS 2023 + pragmatic start):
    //  - Age 20 ? ~20,000 (practical low starting point for young adults)
    //  - Age 25 ? 80,000
    //  - Age 34 ? 159,000
    //  - Age 44 ? 409,000
    //  - Age 54 ? 675,000
    //  - Age 64 ? 873,000
    //  - Age 75 ? 738,000
    const netWorthAnchors = [
      { age: 20, value: 20000 },
      { age: 25, value: 80000 },
      { age: 34, value: 159000 },
      { age: 44, value: 409000 },
      { age: 54, value: 675000 },
      { age: 64, value: 873000 },
      { age: 75, value: 738000 }
    ];

    function estimateNetWorthByAge(age) {
      // Clamp age to integer for indexing
      age = Math.round(Number(age));
      // If age matches an anchor exactly, return that value
      for (let a of netWorthAnchors) if (age === a.age) return a.value;
      // Find interval containing age
      for (let i = 0; i < netWorthAnchors.length - 1; i++) {
        const A = netWorthAnchors[i];
        const B = netWorthAnchors[i + 1];
        if (age > A.age && age < B.age) {
          const t = (age - A.age) / (B.age - A.age);
          const factor = Math.pow(B.value / A.value, t);
          return Math.round(A.value * factor);
        }
      }
      // Extrapolate below first anchor using first interval's CAGR
      if (age < netWorthAnchors[0].age) {
        const A = netWorthAnchors[0];
        const B = netWorthAnchors[1];
        const factorPerYear = Math.pow(B.value / A.value, 1 / (B.age - A.age));
        return Math.round(A.value * Math.pow(factorPerYear, age - A.age));
      }
      // Extrapolate above last anchor using last interval's CAGR
      const L = netWorthAnchors[netWorthAnchors.length - 2];
      const R = netWorthAnchors[netWorthAnchors.length - 1];
      const factorPerYear = Math.pow(R.value / L.value, 1 / (R.age - L.age));
      return Math.round(R.value * Math.pow(factorPerYear, age - R.age));
    }

    // Build `baseNetWorth` for ages 18..80 using `ageLabels` (strings)
    let baseNetWorth = ageLabels.map(a => {
      const ageNum = parseInt(a, 10);
      return estimateNetWorthByAge(ageNum);
    });
    // Survey of Financial Security percentile ranges (2025) smoothed across ages (base values).
    // These values are kept for reference but are not plotted as a separate chart.
    const baseRanges = [
      70000,72500,75000,77500,80000,82500,85000,87500,92500,97500,102500,107500,112500,116500,120500,124500,128500,132500,142500,152500,162500,172500,182500,188500,194500,200500,206500,212500,218500,224500,230500,236500,242500,246500,250500,254500,258500,262500,276500,290500,304500,318500,332500,332900,333300,333700,334100,334500,334900,335300,335700,336100,336500,337700,338900,340100,341300,342500,350500,358500,366500,374500,382500
    ];
    // Top percentile net worth (SFS-derived 2025 projection) smoothed across ages (base values)
    const baseTop1 = [
      300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000
    ];
    // Estimated average net worth (households vs individuals) for 2025, smoothed (base values)
    const baseAvgHouseholds = [
      250000,270833,291667,312500,333333,354167,375000,395833,416667,437500,458333,479167,500000,540000,580000,620000,660000,700000,740000,780000,820000,860000,900000,955000,1010000,1065000,1120000,1175000,1230000,1285000,1340000,1395000,1450000,1480000,1510000,1540000,1570000,1600000,1630000,1660000,1690000,1720000,1750000,1680000,1610000,1540000,1470000,1400000,1360000,1320000,1280000,1240000,1200000,1180000,1160000,1140000,1120000,1100000,1080000,1060000,1040000,1020000,1000000
    ];
    const baseAvgIndividuals = [
      50000,58333,66667,75000,83333,91667,100000,108333,116667,125000,133333,141667,150000,170000,190000,210000,230000,250000,270000,290000,310000,330000,350000,375000,400000,425000,450000,475000,500000,525000,550000,575000,600000,610000,620000,630000,640000,650000,660000,670000,680000,690000,700000,680000,660000,640000,620000,600000,580000,560000,540000,520000,500000,490000,480000,470000,460000,450000,440000,430000,420000,410000,400000
    ];
    // Projected provincial median net worth (2025) - base values. These values
    // represent the estimated 2025 median net worth for each province and will
    // remain constant regardless of the selected region. When a province is
    // selected in the dropdown, the bar corresponding to that province is
    // highlighted.
    const baseProvinceLabels = ['Newfoundland & Labrador','Prince Edward Island','Nova Scotia','New Brunswick','Quebec','Ontario','Manitoba','Saskatchewan','Alberta','British Columbia'];
    // Updated provincial median net worth projections for 2025.  These
    // values were derived from Statistics Canada-s 2019 and 2023 survey
    // results?749321692766873-L68-L79??254363627897504-L52-L63?.  We calculated a compound
    // annual growth rate for each province between 2019 and 2023 and
    // projected that forward two years to 2025.  The numbers below are
    // rounded to the nearest dollar.
    const baseProvinceValues = [
      387286, // Newfoundland & Labrador (--$387.3k)
      549809, // Prince Edward Island (--$549.8k)
      415798, // Nova Scotia (--$415.8k)
      355974, // New Brunswick (--$356.0k)
      463399, // Quebec (--$463.4k)
      823806, // Ontario (--$823.8k)
      441531, // Manitoba (--$441.5k)
      431171, // Saskatchewan (--$431.2k)
      548633, // Alberta (--$548.6k)
      1045108 // British Columbia (--$1.045M)
    ];

    /**
     * Ratio dictionaries for scaling by province. Income ratios are based on
     * average individual incomes in 2023 by province relative to the national
     * average (--$63,181)?118231790205128-L100-L108?, while net worth ratios
     * are derived from Statistics Canada-s 2023 provincial median net worth
     * values relative to the national median (--$519,700)?488464190137828-L64-L74?.
     * These ratios are used to scale the Canadian base data for each region.
     */
    const incomeRatios = {
      'Canada': 1,
      'Newfoundland & Labrador': 0.8319,
      'Prince Edward Island': 0.7306,
      'Nova Scotia': 0.8950,
      'New Brunswick': 0.9075,
      'Quebec': 0.9102,
      'Ontario': 1.0030,
      'Manitoba': 0.9259,
      // Corrected: Saskatchewan is near national average, not 1.3995
      'Saskatchewan': 0.9995,
      'Alberta': 1.1750,
      'British Columbia': 1.0483
    };
    // Net-worth scaling ratios based on projected 2025 provincial medians.
    // Each value represents the province-s projected median net worth (2025)
    // divided by the projected national median (~$652,286).  These
    // projections use province-specific growth rates derived from
    // 2019-2023 data?749321692766873-L68-L79??254363627897504-L52-L63?.
    const netWorthRatios = {
      'Canada': 1,
      'Newfoundland & Labrador': 0.5937,
      'Prince Edward Island': 0.8429,
      'Nova Scotia': 0.6374,
      'New Brunswick': 0.5457,
      'Quebec': 0.7104,
      'Ontario': 1.2630,
      'Manitoba': 0.6769,
      'Saskatchewan': 0.6610,
      'Alberta': 0.8411,
      'British Columbia': 1.6022
    };

    // Compute typical median income by province using the national median employment income at
    // age 40 (index 22 in the baseIncome array).  This provides a single representative
    // figure for each province that can be displayed in the provincial income bar chart.
    // The values are calculated by multiplying the national baseline (baseIncome[22]) by the
    // appropriate income ratio for each region.  For example, Ontario-s value is
    // baseIncome[22] * incomeRatios['Ontario'] -- 62,000 -- 1.003.
    const baseProvinceIncomeValues = baseProvinceLabels.map(label => {
      // Select the national baseline at age 40 (approximately the peak median employment income)
      const medianIncome = baseIncome[22];
      const ratio = incomeRatios[label] || 1;
      return Math.round(medianIncome * ratio);
    });
    const provinceHouseholdIncomeValues = baseProvinceLabels.map(label => {
      const ratio = incomeRatios[label] || 1;
      return Math.round(baseIncome[22] * EQUIVALENCE_SCALE * ratio);
    });

    function computeDiscretionary(income, spending) {
      return income - spending;
    }

    // Average household expenditure by province (Survey of Household Spending Table 11-10-0223-01, indexed to 2026 dollars)
    let provinceSpendingEstimates = [
      71200, // Newfoundland & Labrador
      70500, // Prince Edward Island
      72900, // Nova Scotia
      70100, // New Brunswick
      69000, // Quebec
      82400, // Ontario
      72600, // Manitoba
      75200, // Saskatchewan
      87900, // Alberta
      86500  // British Columbia
    ];

    // Apply 1-year forward spending growth to align with 2026 base
    const spendingGrowthFactor = 1 + SPENDING_GROWTH_NOMINAL;
    provinceSpendingEstimates = provinceSpendingEstimates.map(v => Math.round(v * spendingGrowthFactor));

    const provinceDiscretionaryValues = baseProvinceLabels.map((_, idx) =>
      computeDiscretionary(provinceHouseholdIncomeValues[idx], provinceSpendingEstimates[idx])
    );

    // Global comparison datasets (values in CAD after USD PPP conversion using USD_TO_CAD_2024)
    const globalCountryLabels = ['Canada','United States','United Kingdom','Germany','France','Australia','Japan','Netherlands'];
    const oecdMedianIncomePPPUSD = [46000, 52000, 40000, 43000, 38000, 48500, 37000, 45000];
    const globalMedianIncomeCAD = oecdMedianIncomePPPUSD.map(v => Math.round(v * USD_TO_CAD_2024));
    const globalMedianNetWorthUSD = [125000, 107000, 155000, 60000, 120000, 210000, 123000, 140000];
    const globalMedianNetWorthCAD = globalMedianNetWorthUSD.map(v => Math.round(v * USD_TO_CAD_2024));

    /*
     * Percentile datasets
     *
     * The following arrays represent smoothed percentile estimates for each age 18-80.
     * They were derived by taking ratios from the 2016 income percentile table
     * (10th/25th/75th/90th/99th relative to the median) and applying those ratios to
     * our 2025 base series.  For net worth and average net worth, constant multipliers
     * were used (e.g., 10% of the median for the 10th percentile, 35% for 25th, 150% for 75th,
     * 180% for 90th and the top-1% threshold for 99th).  See Methods for details.
     */
    // Income percentiles (individual employment income)
    let baseIncomeP10 = [5125,5637,6150,6662,7175,7623,8071,8520,9205,9914,10646,11403,12183,12386,12589,12791,12993,13194,13315,13432,13546,13657,13765,13704,13643,13581,13518,13455,13309,13163,13019,12875,12731,12446,12163,11884,11607,11334,10814,10305,9808,9321,8845,9212,9549,9858,10137,10386,12930,15310,17527,19582,21473,20668,19863,19057,18252,17447,16642,15836,15031,14226,13421];
    let baseIncomeP25 = [13386,14725,16064,17402,18741,19913,21084,22255,23513,24779,26054,27338,28630,29136,29640,30145,30649,31152,31548,31940,32327,32711,33091,33068,33044,33020,32994,32968,32637,32306,31978,31650,31325,30649,29980,29318,28662,28012,27034,26073,25129,24202,23292,22765,22237,21705,21172,20637,22524,24270,25875,27337,28658,27583,26508,25434,24359,23284,22210,21135,20060,18986,17911];
    let baseIncomeP75 = [39849,43834,47819,51804,55789,59276,62762,66248,69232,72166,75048,77879,80662,82417,84183,85959,87745,89543,91558,93590,95640,97707,99792,100679,101571,102466,103364,104266,104141,104014,103885,103756,103625,102321,101010,99694,98372,97044,95392,93745,92102,90463,88828,86641,84455,82268,80083,77897,75843,73783,71715,69640,67557,65024,62490,59957,57424,54890,52357,49823,47290,44757,42223];
    let baseIncomeP90 = [57099,62809,68519,74229,79939,84936,89931,94926,98619,102181,105610,108910,112080,114587,117110,119651,122208,124783,128049,131354,134699,138082,141504,143239,144981,146732,148491,150258,150677,151090,151497,151898,152294,150954,149589,148198,146782,145340,144183,142990,141761,140498,139198,134978,130798,126659,122560,118501,115810,113082,110319,107520,104686,100760,96834,92909,88983,85057,81132,77206,73280,69354,65429];
    let baseIncomeP99 = [103655,114021,124387,134752,145118,154190,163257,172325,180128,187803,195348,202765,210060,218828,227773,236895,246193,255667,270804,286296,302143,318347,334906,347628,360426,373299,386246,399269,404079,408850,413583,418277,422932,422706,422305,421731,420982,420059,417386,414589,411668,408623,405453,391530,377807,364284,350961,337838,329318,320745,312119,303439,294706,283655,272603,261552,250500,239449,228397,217346,206294,195243,184191];
    // Total income percentiles (all income sources)
    let baseTotalIncomeP10 = [5330,5791,6252,6713,7175,7687,8199,8712,9468,10251,11061,11898,12763,13093,13422,13750,14078,14404,14642,14874,15102,15324,15541,15511,15480,15447,15413,15377,15174,14972,14771,14572,14374,14055,13739,13427,13118,12812,12228,11656,11096,10549,10013,10512,10989,11444,11876,12285,15447,18484,21395,24181,26841,26305,25768,25231,24694,24157,23620,23084,22547,22010,21473];
    let baseTotalIncomeP25 = [13922,15127,16331,17536,18741,20080,21418,22757,24184,25622,27069,28526,29994,30798,31602,32405,33207,34009,34692,35368,36039,36703,37361,37427,37493,37556,37618,37678,37210,36745,36282,35823,35367,34612,33865,33125,32392,31666,30568,29490,28430,27390,26368,25980,25590,25198,24804,24409,26910,29301,31584,33758,35822,35106,34389,33673,32957,32240,31524,30807,30091,29374,28658];
    let baseTotalIncomeP75 = [41443,45029,48616,52202,55789,59773,63758,67743,71210,74620,77972,81266,84503,87120,89753,92404,95071,97754,100682,103638,106621,109631,112668,113952,115244,116542,117848,119161,118734,118303,117870,117434,116996,115550,114098,112639,111174,109702,107864,106031,104203,102379,100561,98875,97190,95505,93821,92136,90609,89077,87539,85996,84447,82758,81069,79380,77691,76002,74313,72624,70935,69246,67557];
    let baseTotalIncomeP90 = [59383,64522,69661,74800,79939,85648,91358,97068,101436,105655,109725,113646,117418,121126,124860,128622,132410,136226,140810,145456,150163,154932,159763,162122,164498,166890,169299,171724,171791,171846,171890,171923,171945,170472,168971,167442,165884,164297,163033,161730,160387,159005,157583,154036,150521,147037,143585,140163,138357,136523,134662,132773,130857,128240,125623,123006,120389,117772,115154,112537,109920,107303,104686];
    let baseTotalIncomeP99 = [107802,117131,126460,135789,145118,155483,165849,176214,185274,194189,202959,211583,220063,231315,242846,254656,266745,279113,297791,317031,336832,357195,378119,393457,408945,424583,440370,456307,460701,465018,469258,473419,477504,477360,477023,476492,475767,474849,471956,468925,465756,462449,459004,446814,434778,422896,411168,399593,393433,387232,380990,374707,368383,361015,353647,346280,338912,331544,324177,316809,309441,302074,294706];

    // Apply 1-year nominal growth to income percentile arrays to move 2025 bases to 2026
    baseIncomeP10 = baseIncomeP10.map(v => Math.round(v * incomeGrowthFactor));
    baseIncomeP25 = baseIncomeP25.map(v => Math.round(v * incomeGrowthFactor));
    baseIncomeP75 = baseIncomeP75.map(v => Math.round(v * incomeGrowthFactor));
    baseIncomeP90 = baseIncomeP90.map(v => Math.round(v * incomeGrowthFactor));
    baseIncomeP99 = baseIncomeP99.map(v => Math.round(v * incomeGrowthFactor));
    baseTotalIncomeP10 = baseTotalIncomeP10.map(v => Math.round(v * incomeGrowthFactor));
    baseTotalIncomeP25 = baseTotalIncomeP25.map(v => Math.round(v * incomeGrowthFactor));
    baseTotalIncomeP75 = baseTotalIncomeP75.map(v => Math.round(v * incomeGrowthFactor));
    baseTotalIncomeP90 = baseTotalIncomeP90.map(v => Math.round(v * incomeGrowthFactor));
    baseTotalIncomeP99 = baseTotalIncomeP99.map(v => Math.round(v * incomeGrowthFactor));
    // Net worth percentiles
    let baseNetWorthP10 = [-1000,-750,-500,-250,-100,3588,7175,10762,14350,17938,21525,25112,28700,31230,33760,36290,38820,41350,43880,46410,48940,51470,54000,56300,58600,60900,63200,65500,67800,70100,72400,74700,77000,79120,81240,83360,85480,87600,89720,91840,93960,96080,98200,96990,95780,94570,93360,92150,90940,89730,88520,87310,86100,83490,80880,78270,75660,73050,70440,67830,65220,62610,60000];
    let baseNetWorthP25 = [-3500,-2625,-1750,-875,0,12556,25112,37669,50225,62781,75338,87894,100450,109305,118160,127015,135870,144725,153580,162435,171290,180145,189000,197050,205100,213150,221200,229250,237300,245350,253400,261450,269500,276920,284340,291760,299180,306600,314020,321440,328860,336280,343700,339465,335230,330995,326760,322525,318290,314055,309820,305585,301350,292215,283080,273945,264810,255675,246540,237405,228270,219135,210000];
    let baseNetWorthP75 = [-15000,-11250,-7500,-3750,0,53812,107625,161438,215250,269062,322875,376688,430500,468450,506400,544350,582300,620250,658200,696150,734100,772050,810000,844500,879000,913500,948000,982500,1017000,1051500,1086000,1120500,1155000,1186800,1218600,1250400,1282200,1314000,1345800,1377600,1409400,1441200,1473000,1454850,1436700,1418550,1400400,1382250,1364100,1345950,1327800,1309650,1291500,1252350,1213200,1174050,1134900,1095750,1056600,1017450,978300,939150,900000];
    let baseNetWorthP90 = [-18000,-13500,-9000,-4500,10000,64575,129150,193725,258300,322875,387450,452025,516600,562140,607680,653220,698760,744300,789840,835380,880920,926460,972000,1013400,1054800,1096200,1137600,1179000,1220400,1261800,1303200,1344600,1386000,1424160,1462320,1500480,1538640,1576800,1614960,1653120,1691280,1729440,1767600,1745820,1724040,1702260,1680480,1658700,1636920,1615140,1593360,1571580,1549800,1502820,1455840,1408860,1361880,1314900,1267920,1220940,1173960,1126980,1080000];
    let baseNetWorthP99 = [300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000];
    const netWorthGrowthFactor = 1 + NET_WORTH_GROWTH_NOMINAL;
    baseNetWorth = baseNetWorth.map(v => Math.round(v * netWorthGrowthFactor));
    baseNetWorthP10 = baseNetWorthP10.map(v => Math.round(v * netWorthGrowthFactor));
    baseNetWorthP25 = baseNetWorthP25.map(v => Math.round(v * netWorthGrowthFactor));
    baseNetWorthP75 = baseNetWorthP75.map(v => Math.round(v * netWorthGrowthFactor));
    baseNetWorthP90 = baseNetWorthP90.map(v => Math.round(v * netWorthGrowthFactor));
    baseNetWorthP99 = baseNetWorthP99.map(v => Math.round(v * netWorthGrowthFactor));
    // Average net worth percentiles (households)
    let baseAvgHouseholdsP10 = [25000,27083,29167,31250,33333,35417,37500,39583,41667,43750,45833,47917,50000,54000,58000,62000,66000,70000,74000,78000,82000,86000,90000,95500,101000,106500,112000,117500,123000,128500,134000,139500,145000,148000,151000,154000,157000,160000,163000,166000,169000,172000,175000,168000,161000,154000,147000,140000,136000,132000,128000,124000,120000,118000,116000,114000,112000,110000,108000,106000,104000,102000,100000];
    let baseAvgHouseholdsP25 = [87500,94792,102083,109375,116667,123958,131250,138542,145833,153125,160417,167708,175000,189000,203000,217000,231000,245000,259000,273000,287000,301000,315000,334250,353500,372750,392000,411250,430500,449750,469000,488250,507500,518000,528500,539000,549500,560000,570500,581000,591500,602000,612500,588000,563500,539000,514500,490000,476000,462000,448000,434000,420000,413000,406000,399000,392000,385000,378000,371000,364000,357000,350000];
    let baseAvgHouseholdsP75 = [375000,406250,437500,468750,500000,531250,562500,593750,625000,656250,687500,718750,750000,810000,870000,930000,990000,1050000,1110000,1170000,1230000,1290000,1350000,1432500,1515000,1597500,1680000,1762500,1845000,1927500,2010000,2092500,2175000,2220000,2265000,2310000,2355000,2400000,2445000,2490000,2535000,2580000,2625000,2520000,2415000,2310000,2205000,2100000,2040000,1980000,1920000,1860000,1800000,1770000,1740000,1710000,1680000,1650000,1620000,1590000,1560000,1530000,1500000];
    let baseAvgHouseholdsP90 = [450000,487499,525001,562500,599999,637501,675000,712499,750001,787500,824999,862501,900000,972000,1044000,1116000,1188000,1260000,1332000,1404000,1476000,1548000,1620000,1719000,1818000,1917000,2016000,2115000,2214000,2313000,2412000,2511000,2610000,2664000,2718000,2772000,2826000,2880000,2934000,2988000,3042000,3096000,3150000,3024000,2898000,2772000,2646000,2520000,2448000,2376000,2304000,2232000,2160000,2124000,2088000,2052000,2016000,1980000,1944000,1908000,1872000,1836000,1800000];
    let baseAvgHouseholdsP99 = [300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000];
    // Average net worth percentiles (individuals)
    let baseAvgIndividualsP10 = [5000,5833,6667,7500,8333,9167,10000,10833,11667,12500,13333,14167,15000,17000,19000,21000,23000,25000,27000,29000,31000,33000,35000,37500,40000,42500,45000,47500,50000,52500,55000,57500,60000,61000,62000,63000,64000,65000,66000,67000,68000,69000,70000,68000,66000,64000,62000,60000,58000,56000,54000,52000,50000,49000,48000,47000,46000,45000,44000,43000,42000,41000,40000];
    let baseAvgIndividualsP25 = [17500,20417,23333,26250,29167,32083,35000,37917,40833,43750,46667,49583,52500,59500,66500,73500,80500,87500,94500,101500,108500,115500,122500,131250,140000,148750,157500,166250,175000,183750,192500,201250,210000,213500,217000,220500,224000,227500,231000,234500,238000,241500,245000,238000,231000,224000,217000,210000,203000,196000,189000,182000,175000,171500,168000,164500,161000,157500,154000,150500,147000,143500,140000];
    let baseAvgIndividualsP75 = [75000,87500,100000,112500,125000,137500,150000,162500,175000,187500,200000,212500,225000,255000,285000,315000,345000,375000,405000,435000,465000,495000,525000,562500,600000,637500,675000,712500,750000,787500,825000,862500,900000,915000,930000,945000,960000,975000,990000,1005000,1020000,1035000,1050000,1020000,990000,960000,930000,900000,870000,840000,810000,780000,750000,735000,720000,705000,690000,675000,660000,645000,630000,615000,600000];
    let baseAvgIndividualsP90 = [90000,104999,120001,135000,149999,165001,180000,194999,210001,225000,239999,255001,270000,306000,342000,378000,414000,450000,486000,522000,558000,594000,630000,675000,720000,765000,810000,855000,900000,945000,990000,1035000,1080000,1098000,1116000,1134000,1152000,1170000,1188000,1206000,1224000,1242000,1260000,1224000,1188000,1152000,1116000,1080000,1044000,1008000,972000,936000,900000,882000,864000,846000,828000,810000,792000,774000,756000,738000,720000];
    let baseAvgIndividualsP99 = [150000,162500,175000,187500,200000,212500,225000,237500,270000,302500,335000,367500,400000,470000,540000,610000,680000,750000,850000,950000,1050000,1150000,1250000,1400000,1550000,1700000,1850000,2000000,2100000,2200000,2300000,2400000,2500000,2600000,2700000,2800000,2900000,3000000,3300000,3600000,3900000,4200000,4500000,4650000,4800000,4950000,5100000,5250000,5250000,5250000,5250000,5250000,5250000,5150000,5050000,4950000,4850000,4750000,4650000,4550000,4450000,4350000,4250000];
    // Apply 1-year nominal growth to average net worth percentiles to align with 2026 base year
    baseAvgHouseholdsP10 = baseAvgHouseholdsP10.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgHouseholdsP25 = baseAvgHouseholdsP25.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgHouseholdsP75 = baseAvgHouseholdsP75.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgHouseholdsP90 = baseAvgHouseholdsP90.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgHouseholdsP99 = baseAvgHouseholdsP99.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgIndividualsP10 = baseAvgIndividualsP10.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgIndividualsP25 = baseAvgIndividualsP25.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgIndividualsP75 = baseAvgIndividualsP75.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgIndividualsP90 = baseAvgIndividualsP90.map(v => Math.round(v * netWorthGrowthFactor));
    baseAvgIndividualsP99 = baseAvgIndividualsP99.map(v => Math.round(v * netWorthGrowthFactor));

    /**
     * Validate data integrity on page load.
     * Checks that all arrays have consistent lengths and required keys exist.
     * Call this function during initialization to catch data issues early.
     * Access with: validateDataIntegrity()
     */
    function validateDataIntegrity() {
      const checks = {
        'ageLabels': ageLabels.length === 63,
        'baseIncome': baseIncome.length === 63,
        'baseNetWorth': baseNetWorth.length === 63,
        'baseAvgHouseholds': baseAvgHouseholds.length === 63,
        'baseAvgIndividuals': baseAvgIndividuals.length === 63,
        'incomePercentiles': [baseIncomeP10, baseIncomeP25, baseIncomeP75, baseIncomeP90, baseIncomeP99].every(a => a && a.length === 63),
        'netWorthPercentiles': [baseNetWorthP10, baseNetWorthP25, baseNetWorthP75, baseNetWorthP90, baseNetWorthP99].every(a => a && a.length === 63),
        'totalIncomePercentiles': [baseTotalIncomeP10, baseTotalIncomeP25, baseTotalIncomeP75, baseTotalIncomeP90, baseTotalIncomeP99].every(a => a && a.length === 63),
        'avgHouseholdPercentiles': [baseAvgHouseholdsP10, baseAvgHouseholdsP25, baseAvgHouseholdsP75, baseAvgHouseholdsP90, baseAvgHouseholdsP99].every(a => a && a.length === 63),
        'avgIndividualPercentiles': [baseAvgIndividualsP10, baseAvgIndividualsP25, baseAvgIndividualsP75, baseAvgIndividualsP90, baseAvgIndividualsP99].every(a => a && a.length === 63),
        'incomeRatios': Object.keys(incomeRatios).length === 11,
        'netWorthRatios': Object.keys(netWorthRatios).length === 11,
        'provinceLabels': baseProvinceLabels.length === 10,
        'provinceValues': baseProvinceValues.length === 10,
        'provinceIncomeValues': baseProvinceIncomeValues.length === 10,
        'provinceSpending': provinceSpendingEstimates.length === 10
      };
      let allPass = true;
      Object.entries(checks).forEach(([name, pass]) => {
        const mark = pass ? '?' : '?';
        console.log(`${mark} ${name}`, pass ? 'OK' : 'FAILED');
        if (!pass) allPass = false;
      });
      console.log(`\n${allPass ? '? All data integrity checks passed' : '? Some checks failed - review above'}`);
      return allPass;
    }

    // Individuals median net worth estimates for 2025.  Because Statistics
    // Canada reports net worth at the family/household level, there is no
    // official individual median net worth series. We approximate individual
    // values using the square-root equivalence scale with a default household
    // size of 2.4 people so individual values are lower in line with
    // equivalized income/wealth methods. Percentile estimates follow the
    // same approach.
    function scaleIndividualNetWorthArray(arr) {
      const toIndividual = 1 / EQUIVALENCE_SCALE;
      return arr.map(v => {
        // For negative values, increase magnitude slightly to reflect deeper
        // debt loads for single-person households; positives follow the
        // equivalence scale.
        return v < 0 ? Math.round(v * EQUIVALENCE_SCALE) : Math.round(v * toIndividual);
      });
    }
    const baseIndNetWorth = scaleIndividualNetWorthArray(baseNetWorth);
    const baseIndNetWorthP10 = scaleIndividualNetWorthArray(baseNetWorthP10);
    const baseIndNetWorthP25 = scaleIndividualNetWorthArray(baseNetWorthP25);
    const baseIndNetWorthP75 = scaleIndividualNetWorthArray(baseNetWorthP75);
    const baseIndNetWorthP90 = scaleIndividualNetWorthArray(baseNetWorthP90);
    const baseIndNetWorthP99 = scaleIndividualNetWorthArray(baseNetWorthP99);

    function getCss(varName){
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    // Colour palettes for percentile lines.  Each chart type has its own set of
    // shades.  Colours progress from lighter to darker as the percentile
    // increases.  Median uses the base colour for each chart.
    const percentileColors = {
      income: {
        p10: getCss('--p10'),
        p25: getCss('--p25'),
        p50: getCss('--p50'),
        p75: getCss('--p75'),
        p90: getCss('--p90')
      },

      totalIncome: {
        p10: getCss('--p10'),
        p25: getCss('--p25'),
        p50: getCss('--p50'),
        p75: getCss('--p75'),
        p90: getCss('--p90')
      },

      netWorth: {
        p10: getCss('--p10'),
        p25: getCss('--p25'),
        p50: getCss('--p50'),
        p75: getCss('--p75'),
        p90: getCss('--p90')
      },

      indNetWorth: {
        p10: getCss('--p10'),
        p25: getCss('--p25'),
        p50: getCss('--p50'),
        p75: getCss('--p75'),
        p90: getCss('--p90')
      },

      top1: {
        p10: getCss('--p10'),
        p25: getCss('--p25'),
        p50: getCss('--p50'),
        p75: getCss('--p75'),
        p90: getCss('--p90')
      },

      avgHouseholds: {
        p10: getCss('--p10'),
        p25: getCss('--p25'),
        p50: getCss('--p50'),
        p75: getCss('--p75'),
        p90: getCss('--p90')
      },
      avgIndividuals: {
        p10: getCss('--p10'),
        p25: getCss('--p25'),
        p50: getCss('--p50'),
        p75: getCss('--p75'),
        p90: getCss('--p90')
      },

      wealthLines: {
        core: getCss('--wealth-core'),
        upper: getCss('--wealth-upper'),
        elite: getCss('--wealth-elite')
      },

      userMarker: getCss('--user-marker')
    };

    // Chart instance holders for dynamic updates
    let incomeChartInstance;
    let netWorthChartInstance;
    let provinceChartInstance;
    let compositionChartInstance;
    let provinceIncomeChartInstance;
    let scatterChartInstance;
    let percentileNetWorthChartInstance;
    let percentileIncomeChartInstance;
    let wealthCompositionChartInstance;
    let genderIncomeChartInstance;

    // Initialize metric registry and register available metrics.  Each metric
    // encapsulates the base median values and percentile arrays for a
    // specific measure (employment income, net worth, etc.) to avoid
    // duplicating arrays throughout the code.  The registry exposes
    // `get()` for retrieval by key.
    const metricsRegistry = new MetricRegistry();
    metricsRegistry
      .register('employmentIncome', new DataMetric('Employment Income', baseIncome, {
        p10: baseIncomeP10,
        p25: baseIncomeP25,
        p75: baseIncomeP75,
        p90: baseIncomeP90,
        p99: baseIncomeP99
      }, 'individuals'))
      .register('netWorth', new DataMetric('Net Worth (Households)', baseNetWorth, {
        p10: baseNetWorthP10,
        p25: baseNetWorthP25,
        p75: baseNetWorthP75,
        p90: baseNetWorthP90,
        p99: baseNetWorthP99
      }, 'households'))
      .register('indNetWorth', new DataMetric('Net Worth (Individuals)', baseIndNetWorth, {
        p10: baseIndNetWorthP10,
        p25: baseIndNetWorthP25,
        p75: baseIndNetWorthP75,
        p90: baseIndNetWorthP90,
        p99: baseIndNetWorthP99
      }, 'individuals'));
    // Create a ChartUpdater instance once.  This object centralizes the
    // logic for updating income and net worth charts based on region,
    // unit (households vs individuals), selected percentiles and user
    // input.  See ChartUpdater class definition for details.
  const chartUpdater = new ChartUpdater(metricsRegistry, {
      income: incomeRatios,
      netWorth: netWorthRatios
    });

    // Labels for percentile charts (1..99)
    const percentileLabels = Array.from({ length: 99 }, (_, i) => String(i + 1));

    // Anchors for constructing percentile curves (ratios of median)
    const netWorthPercentileAnchors = [
      { p: 1, r: 0.05 }, { p: 10, r: 0.10 }, { p: 25, r: 0.35 },
      { p: 50, r: 1.00 }, { p: 75, r: 1.50 }, { p: 90, r: 1.80 }, { p: 99, r: 12.0 }
    ];
    const incomePercentileAnchors = [
      { p: 1, r: 0.10 }, { p: 10, r: 0.22 }, { p: 25, r: 0.54 },
      { p: 50, r: 1.00 }, { p: 75, r: 1.64 }, { p: 90, r: 2.44 }, { p: 99, r: 6.0 }
    ];

    // Build a 1..99 curve from anchors using log-linear interpolation for smooth heavy tails
    function buildPercentileCurveFromAnchors(anchors) {
      const sorted = anchors.slice().sort((a, b) => a.p - b.p);
      const curve = new Array(99);
      let idx = 0;
      for (let p = 1; p <= 99; p++) {
        while (idx < sorted.length - 1 && p > sorted[idx + 1].p) idx++;
        const a = sorted[Math.max(0, idx)];
        const b = sorted[Math.min(sorted.length - 1, idx + 1)];
        const t = (p - a.p) / Math.max(1, (b.p - a.p));
        const lr = Math.exp(Math.log(a.r) + (Math.log(b.r) - Math.log(a.r)) * Math.max(0, Math.min(1, t)));
        curve[p - 1] = lr;
      }
      return curve;
    }

    // Given a median value and anchor ratios, return absolute values for 1..99 percentiles
    function makePercentileValues(median, anchors) {
      const ratios = buildPercentileCurveFromAnchors(anchors);
      return ratios.map(r => Math.round(median * r));
    }

    // Find the percentile index (0-based) closest to the given value on the curve
    function findPercentileIndex(value, curveValues) {
      let bestIdx = 0;
      let bestDiff = Infinity;
      for (let i = 0; i < curveValues.length; i++) {
        const d = Math.abs(curveValues[i] - value);
        if (d < bestDiff) { bestDiff = d; bestIdx = i; }
      }
      return bestIdx;
    }

    // Plugin to draw a user reference line: vertical (by index or numeric x) or horizontal (by y)
    // Collision-aware stacked annotation labels for vertical lines
    function getLabelRole(text = '') {
      const t = text.toLowerCase();
      if (t.includes('you')) return 'you';
      if (t.includes('median')) return 'median';
      return 'other';
    }
    function placeStackedLabel(ctx, chart, xPixel, text, color) {
      if (!chart || !chart.chartArea) return;
      const { chartArea } = chart;
      const store = chart.$annotationLabels || (chart.$annotationLabels = []);
      const role = getLabelRole(text);
      const baseTier = role === 'you' ? 0 : role === 'median' ? 1 : 2;
      const tierOffsets = [-10, -28, -46];
      const colliders = store.filter(l => Math.abs(l.x - xPixel) < 48);
      const usedTiers = new Set(colliders.map(l => l.tier));
      let tier = baseTier;
      while (usedTiers.has(tier)) tier++;
      const extra = tier > tierOffsets.length - 1 ? (tier - (tierOffsets.length - 1)) * 18 : 0;
      let offset = (tierOffsets[tier] ?? tierOffsets[tierOffsets.length - 1]) - extra;
      const baseY = chartArea.top + 18;
      let y = baseY + offset;
      const minY = chartArea.top + 6;
      if (y < minY) {
        // flip downward if we exceed top bound
        y = baseY + Math.abs(offset);
      }
      const clampedX = Math.min(Math.max(xPixel, chartArea.left + 6), chartArea.right - 6);
      ctx.setLineDash([]);
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const paddingX = 6;
      const paddingY = 4;
      const textMetrics = ctx.measureText(text);
      const textWidth = textMetrics.width;
      const textHeight = (textMetrics.actualBoundingBoxAscent || 8) + (textMetrics.actualBoundingBoxDescent || 4);
      const rectX = clampedX + 4;
      const rectY = y - textHeight / 2 - paddingY;
      const rectH = textHeight + paddingY * 2;
      const rectW = textWidth + paddingX * 2;
      ctx.fillStyle = 'rgba(15, 23, 42, 0.85)';
      ctx.beginPath();
      if (ctx.roundRect) {
        ctx.roundRect(rectX, rectY, rectW, rectH, 4);
      } else {
        ctx.rect(rectX, rectY, rectW, rectH);
      }
      ctx.fill();
      ctx.fillStyle = color || 'rgba(255,255,255,0.9)';
      ctx.fillText(text, rectX + paddingX, y);
      store.push({ x: xPixel, tier });
    }

    const userVLinePlugin = {
      id: 'userVLine',
      afterDraw(chart, args, options) {
        if (!options) return;
        const { ctx, chartArea, scales } = chart;
        if (!chartArea) return;
        ctx.save();
        chart.$annotationLabels = [];
        chart.$annotationLabelsReset = true; // mark reset for this draw cycle
        ctx.strokeStyle = (options.color || 'rgba(244,67,54,1)');
        ctx.setLineDash(options.dash || [6,3]);
        ctx.lineWidth = options.width || 2;
        if (options.index != null && scales.x) {
          const x = scales.x.getPixelForTick(options.index);
          ctx.beginPath();
          ctx.moveTo(x, chartArea.top);
          ctx.lineTo(x, chartArea.bottom);
          ctx.stroke();
          if (options.label) placeStackedLabel(ctx, chart, x, options.label, options.color);
        } else if (options.xValue != null && scales.x) {
          const x = scales.x.getPixelForValue(options.xValue);
          ctx.beginPath();
          ctx.moveTo(x, chartArea.top);
          ctx.lineTo(x, chartArea.bottom);
          ctx.stroke();
          if (options.label) placeStackedLabel(ctx, chart, x, options.label, options.color);
        } else if (options.yValue != null && scales.y) {
          const y = scales.y.getPixelForValue(options.yValue);
          ctx.beginPath();
          ctx.moveTo(chartArea.left, y);
          ctx.lineTo(chartArea.right, y);
          ctx.stroke();
        }
        ctx.restore();
      }
    };
    Chart.register(userVLinePlugin);

    // Plugin to draw one or more reference vertical lines (e.g., Median)
    const medianVLinePlugin = {
      id: 'medianVLine',
      afterDraw(chart, args, options) {
        if (!options) return;
        const { ctx, chartArea, scales } = chart;
        if (!chartArea) return;
        const lines = Array.isArray(options) ? options : [options];
        ctx.save();
        if (!chart.$annotationLabelsReset) {
          chart.$annotationLabels = [];
        }
        chart.$annotationLabelsReset = false;
        lines.forEach(line => {
          if (line && line.xValue != null && scales?.x) {
            const x = scales.x.getPixelForValue(line.xValue);
            ctx.strokeStyle = line.color || 'rgba(255,255,255,0.6)';
            ctx.setLineDash(line.dash || [2,2]);
            ctx.lineWidth = line.width || 1;
            ctx.beginPath();
            ctx.moveTo(x, chartArea.top);
            ctx.lineTo(x, chartArea.bottom);
            ctx.stroke();
            if (line.label) placeStackedLabel(ctx, chart, x, line.label, line.color);
          }
        });
        ctx.restore();
      }
    };
    Chart.register(medianVLinePlugin);

    // Global watermark plugin (top-right, auto-avoids legend)
    const wealthDashboardWatermark = {
      id: 'wealthDashboardWatermark',
      afterDraw(chart) {
        const { ctx, chartArea, legend } = chart;
        if (!ctx || !chartArea) return;
        const padding = 8;
        const textBold = 'WEALTH';
        const textRest = 'DASHBOARD.CA';
        const fontBase = '12px "Segoe UI", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
        const fontBold = '700 ' + fontBase;
        const fontNormal = '400 ' + fontBase;
        ctx.save();
        ctx.font = fontBold;
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const metricsBold = ctx.measureText(textBold);
        ctx.font = fontNormal;
        const metricsRest = ctx.measureText(textRest);
        const textW = metricsBold.width + metricsRest.width;
        const textH = Math.max(
          (metricsBold.actualBoundingBoxAscent || 8) + (metricsBold.actualBoundingBoxDescent || 3),
          (metricsRest.actualBoundingBoxAscent || 8) + (metricsRest.actualBoundingBoxDescent || 3)
        );
        let x = chartArea.right - padding - textW;
        let y = chartArea.top + padding + textH / 2;

        const legendBox = legend && legend.width && legend.height ? {
          left: legend.left,
          top: legend.top,
          right: legend.left + legend.width,
          bottom: legend.top + legend.height
        } : null;

        const overlapsLegend = (legendBox) => {
          const textRect = {
            left: x,
            right: x + textW,
            top: y - textH / 2,
            bottom: y + textH / 2
          };
          return legendBox &&
                 textRect.left < legendBox.right &&
                 textRect.right > legendBox.left &&
                 textRect.top < legendBox.bottom &&
                 textRect.bottom > legendBox.top;
        };

        if (legendBox && overlapsLegend(legendBox)) {
          y = legendBox.bottom + padding + textH / 2;
        }

        // Clamp inside chart area
        x = Math.min(Math.max(x, chartArea.left + padding), chartArea.right - padding - textW);
        y = Math.min(Math.max(y, chartArea.top + padding + textH / 2), chartArea.bottom - padding - textH / 2);

        ctx.font = fontBold;
        ctx.fillText(textBold, x, y);
        ctx.font = fontNormal;
        ctx.fillText(textRest, x + metricsBold.width, y);
        ctx.restore();
      }
    };

    // Inline labels drawn at the end of each visible line dataset
    const inlineLineLabels = {
      id: 'inlineLineLabels',
      afterDatasetsDraw(chart) {
        const { ctx, data, chartArea } = chart || {};
        if (!ctx || !chartArea || !data?.datasets?.length) return;
        const viewWidth = chart?.canvas?.ownerDocument?.defaultView?.innerWidth || (typeof window !== 'undefined' ? window.innerWidth : 1200);
        const fontSize = viewWidth <= 640 ? 10 : 11;
        const fontFamily = 'system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
        const padding = 6;
        const collisionPad = 12;
        const placed = [];

        data.datasets.forEach((ds, datasetIndex) => {
          if (ds?.inlineLabel === false) return;
          const meta = chart.getDatasetMeta(datasetIndex);
          const isLineType = meta && (meta.type === 'line' || ds.type === 'line' || ds.showLine === true);
          if (!meta || meta.hidden || !isLineType) return;

          const points = meta.data || [];
          let pt = null;
          for (let i = points.length - 1; i >= 0; i--) {
            const candidate = points[i];
            if (!candidate) continue;
            const pos = typeof candidate.tooltipPosition === 'function' ? candidate.tooltipPosition() : candidate;
            const parsed = candidate.$context?.parsed?.y ?? candidate.parsed?.y ?? candidate.parsed ?? null;
            if (pos && Number.isFinite(pos.x) && Number.isFinite(pos.y) && parsed !== null && parsed !== undefined && !Number.isNaN(parsed)) {
              pt = pos;
              break;
            }
          }
          if (!pt) return;
          const label = ds.label;
          if (!label) return;

          const colorCandidate = Array.isArray(ds.borderColor) ? ds.borderColor[0] : ds.borderColor;
          const fallbackBg = Array.isArray(ds.backgroundColor) ? ds.backgroundColor[0] : ds.backgroundColor;
          const textColor = (typeof colorCandidate === 'string' && colorCandidate) ||
                            (typeof fallbackBg === 'string' && fallbackBg) ||
                            '#e0e6ed';

          ctx.save();
          ctx.font = `${fontSize}px ${fontFamily}`;
          ctx.textBaseline = 'middle';
          ctx.fillStyle = textColor;
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.lineWidth = 3;

          const metrics = ctx.measureText(label);
          const textW = metrics.width;
          const textH = (metrics.actualBoundingBoxAscent || fontSize * 0.72) + (metrics.actualBoundingBoxDescent || fontSize * 0.28);
          const rightLimit = chartArea.right - 2;
          let x = pt.x + padding;
          let align = 'left';
          if (x + textW > rightLimit) {
            x = pt.x - padding;
            align = 'right';
          }
          const topLimit = chartArea.top + textH / 2 + 2;
          const bottomLimit = chartArea.bottom - textH / 2 - 2;
          let y = Math.min(Math.max(pt.y, topLimit), bottomLimit);

          let iteration = 0;
          while (iteration < 6) {
            const conflict = placed.find(p => Math.abs(p.y - y) < collisionPad && Math.abs(p.x - x) < textW + collisionPad);
            if (!conflict) break;
            const direction = iteration % 2 === 0 ? 1 : -1;
            y = Math.min(Math.max(y + direction * collisionPad, topLimit), bottomLimit);
            iteration++;
          }

          ctx.textAlign = align;
          ctx.strokeText(label, x, y);
          ctx.fillText(label, x, y);
          ctx.restore();
          placed.push({ x, y, w: textW, h: textH });
        });
      }
    };

    Chart.register(wealthDashboardWatermark);
    Chart.register(inlineLineLabels);
    // Force the wealth composition net worth line to always render on top
    const wealthNetWorthTopLayer = {
      id: 'wealthNetWorthTopLayer',
      afterDatasetsDraw(chart) {
        if (!chart?.canvas || chart.canvas.id !== 'wealthCompositionChart') return;
        const dsIndex = chart.data?.datasets?.findIndex(ds => ds.label === 'Median Net Worth');
        if (dsIndex == null || dsIndex < 0) return;
        const meta = chart.getDatasetMeta(dsIndex);
        const ctx = chart.ctx;
        if (!meta || !ctx) return;
        if (meta.dataset?.draw) meta.dataset.draw(ctx);
        if (Array.isArray(meta.data)) {
          meta.data.forEach(el => el?.draw?.(ctx));
        }
      }
    };
    Chart.register(wealthNetWorthTopLayer);
    // Global padding to reserve a bottom safe zone and right gutter for inline labels
    Chart.defaults.plugins = Chart.defaults.plugins || {};
    Chart.defaults.plugins.legend = Chart.defaults.plugins.legend || {};
    Chart.defaults.plugins.legend.display = false;
    Chart.defaults.layout = Chart.defaults.layout || {};
    const existingPad = Chart.defaults.layout.padding || {};
    Chart.defaults.layout.padding = {
      top: existingPad.top ?? 8,
      right: Math.max(existingPad.right ?? 0, 34),
      bottom: Math.max(existingPad.bottom ?? 0, 12),
      left: existingPad.left ?? 10
    };

    const allCharts = window.allCharts = window.allCharts || [];
    const triggerAllChartUpdates = (() => {
      let handle;
      return () => {
        clearTimeout(handle);
        handle = setTimeout(() => {
          allCharts.forEach(ch => {
            if (ch && typeof ch.update === 'function') {
              try { ch.update(); } catch (e) { /* no-op */ }
            }
          });
        }, 180);
      };
    })();

    window.addEventListener('resize', triggerAllChartUpdates, { passive: true });
    window.addEventListener('orientationchange', triggerAllChartUpdates, { passive: true });

    /**
     * Performance timing utility for iterative optimization.
     * Wraps updateCharts to measure execution time.
     * Access with: const duration = timeChartUpdate('Canada');
     */
    function timeChartUpdate(region) {
      const start = performance.now();
      updateCharts(region);
      const duration = performance.now() - start;
      console.log(`??  Chart update for ${region}: ${duration.toFixed(1)}ms`);
      return duration;
    }

    /**
     * Compute axis bounds given an array of values and a desired step size.
     * Returns an object containing min and max. Padding and rounding to the
     * nearest thousand are applied to create clean axes. The range is
     * extended if necessary so that it is divisible by the step size.
     * @param {number[]} values
     * @param {number} step
     */
    function computeAxis(values, step) {
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);
      const pad = (maxVal - minVal) * 0.05;
      // Do not clamp negative values to zero. Allow the axis to extend
      // below zero so that negative net worth at younger ages is visible.
      let yMin = minVal - pad;
      let yMax = maxVal + pad;
      // Round bounds to the nearest thousand for clean tick labels
      yMin = Math.floor(yMin / 1000) * 1000;
      yMax = Math.ceil(yMax / 1000) * 1000;
      if (step) {
        const range = yMax - yMin;
        const remainder = range % step;
        if (remainder !== 0) {
          yMax += step - remainder;
        }
      }
      return { min: yMin, max: yMax };
    }

    // Province-only domain helper (isolated per chart, ignores global state)
    function computeProvinceDomain(values, opts = {}) {
      const {
        beginAtZero = true,
        paddingPct = 0.15,
        minPadding = 2000,
        fallbackMax = 200000,
        prevMin = 0,
        prevMax = fallbackMax,
        maxClampFactor = null
      } = opts;
      const clean = (values || []).map(v => Number(v)).filter(v => Number.isFinite(v));
      if (!clean.length) {
        return {
          min: beginAtZero ? 0 : (Number.isFinite(prevMin) ? prevMin : 0),
          max: Number.isFinite(prevMax) ? prevMax : fallbackMax,
          topValues: []
        };
      }
      const dataMin = Math.min(...clean);
      const dataMax = Math.max(...clean);
      const span = dataMax - dataMin;
      const padding = Math.max(span * paddingPct, minPadding);
      let min = beginAtZero ? 0 : Math.max(0, dataMin - padding);
      let max = dataMax + padding;
      if (maxClampFactor && clean.length) {
        const sorted = [...clean].sort((a,b)=>a-b);
        const median = sorted[Math.floor(sorted.length/2)];
        const clamp = median * maxClampFactor;
        if (max > clamp) max = clamp;
      }
      const topValues = [...clean].sort((a,b)=>b-a).slice(0,3);
      return { min, max, topValues };
    }

    /**
     * Chart update strategies - one method per chart for easy iteration.
     * Each strategy handles its own data scaling, dataset building, and axis computation.
     * This pattern makes it easy to test, optimize, or redesign individual charts.
     * 
     * Usage: chartStrategies['incomeChart'](region, unit);
     * Or call via updateCharts() which invokes all strategies in sequence.
     * 
     * TODO: Extract chart-specific logic from updateCharts() into each strategy.
     */
    const chartStrategies = {
      'incomeChart': (region, unit) => { /* TODO: Extract income chart logic */ },
      'netWorthChart': (region, unit) => { /* TODO: Extract net worth chart logic */ },
      'provinceChart': (region, unit) => { /* TODO: Extract province chart logic */ },
      'compositionChart': (region, unit) => { /* TODO: Extract composition logic */ },
      'scatterChart': (region, unit) => { /* TODO: Extract scatter logic */ },
      'genderChart': (region, unit) => { /* TODO: Extract gender chart logic */ },
      'provinceIncomeChart': (region, unit) => { /* TODO: Extract province income logic */ },
      'discretionaryChart': (region, unit) => { /* TODO: Extract discretionary income logic */ }
    };

    /**
     * Update all charts according to the selected region. This function scales
     * base datasets by the appropriate income and net worth ratios, updates
     * chart data and axis bounds, updates chart titles, and highlights the
     * selected province in the provincial bar chart.
     * @param {string} region The selected province name or 'Canada'
     */
    function updateCharts(region) {
      const incomeRatio = incomeRatios[region] || 1;
      const netRatio = netWorthRatios[region] || 1;
      const unitEl = document.getElementById('unitSelect');
      const unit = unitEl ? unitEl.value : 'households';
      // Show core percentile lines by default: 10th, 25th, 50th (median), 75th, 90th
      const selectedPcts = ['p10','p25','p75','p90'];
      /*
       * Helper to build datasets and axis for a line chart.  Accepts the base
       * median array and an object of percentile arrays keyed by p10/p25/etc.
       * Colours are drawn from the percentileColours dictionary for the given
       * chart type.  The function returns an object with a new dataset array
       * and an array of all values used for axis computation.
       */
      function buildPercentileDatasets(type, baseArray, pctArrays, colorMap, labelBase) {
        const datasets = [];
        // Median (50th percentile)
        datasets.push({
          // Label the median clearly as 'Median' for readability
          label: 'Median',
          data: baseArray,
          borderColor: colorMap.p50,
          backgroundColor: 'transparent',
          // show a small interactive hit area so tooltips appear when hovering the line
          pointRadius: 0,
          pointHoverRadius: 4,
          pointHitRadius: 8,
          tension: 0.35
        });
        // Add selected percentile lines (excluding median)
        selectedPcts.forEach(p => {
          // If the user selects p50 (median), we skip because median is always present
          if (p === 'p50') return;
          const arr = pctArrays[p];
          if (!arr) return;
          let pctLabel = '';
          switch (p) {
            case 'p10': pctLabel = '10th Percentile'; break;
            case 'p25': pctLabel = '25th Percentile'; break;
            case 'p75': pctLabel = '75th Percentile'; break;
            case 'p90': pctLabel = '90th Percentile'; break;
            default: pctLabel = p; break;
          }
          // Append chart type to label for clarity on average net worth chart
          if (type === 'avgHouseholds') {
            pctLabel += ' (Households)';
          } else if (type === 'avgIndividuals') {
            pctLabel += ' (Individuals)';
          } else if (type === 'top1' && p === 'p99') {
            pctLabel = '99th Percentile (Top 1% Threshold)';
          }
          datasets.push({
            label: pctLabel,
            data: arr,
            borderColor: colorMap[p],
            backgroundColor: 'transparent',
            // hide points visually but allow hover detection and a small hover radius
            pointRadius: 0,
            pointHoverRadius: 4,
            pointHitRadius: 8,
            tension: 0.35
          });
        });
        // Gather values for axis computation
        let allVals = baseArray.slice();
        selectedPcts.forEach(p => {
          if (p === 'p50') return;
          if (pctArrays[p]) allVals = allVals.concat(pctArrays[p]);
        });
        return { datasets, values: allVals };
      }
      // Prepare scaled arrays for each percentile for incomes
      // Scale employment income by region; adjust for unit (households vs individuals)
      let scaledIncome = baseIncome.map(v => Math.round(v * incomeRatio));
      if (unit === 'households') {
        scaledIncome = scaledIncome.map(v => Math.round(v * EQUIVALENCE_SCALE));
      }
      const incomePctArrays = {
        p10: baseIncomeP10.map(v => Math.round(v * incomeRatio)),
        // Use proportional percentiles derived from the median to avoid overlapping/incorrect anchors
        p25: scaledIncome.map(v => Math.round(v * 0.65)),
        p50: scaledIncome,
        p75: scaledIncome.map(v => Math.round(v * 1.35)),
        p90: baseIncomeP90.map(v => Math.round(v * incomeRatio)),
        p99: baseIncomeP99.map(v => Math.round(v * incomeRatio))
      };
      const incomeLabelBase = unit === 'households' ? 'Median Employment Income (Households)' : 'Median Employment Income (Individuals)';
      const incomeResult = buildPercentileDatasets('income', scaledIncome, incomePctArrays, percentileColors.income, incomeLabelBase);
      // Preserve user dataset if present
      const incomeUserIdx = incomeChartInstance.data.datasets.findIndex(ds => ds.label === 'You');
      let incomeUserDs = null;
      if (incomeUserIdx >= 0 && userActive) incomeUserDs = incomeChartInstance.data.datasets[incomeUserIdx];
      incomeChartInstance.data.datasets = incomeResult.datasets.slice();
      if (incomeUserDs) incomeChartInstance.data.datasets.push(incomeUserDs);
      // Compute axis and update chart
      let incVals = incomeResult.values.slice();
      if (userActive) incVals.push(userIncomeVal);
      let incAxis = computeAxis(incVals, 5000);
      incomeChartInstance.options.scales.y.min = 0;
      incomeChartInstance.options.scales.y.max = incAxis.max;
      incomeChartInstance.options.scales.y.title.text = unit === 'households'
        ? 'Median Employment Income ($ - Households)'
        : 'Median Employment Income ($ - Individuals)';
      incomeChartInstance.update();

      // Update gender income chart using CIS-derived female-to-male ratio (~0.88 nationwide)
      const womenRatio = 0.88;
      const menRatio = 1.00;
      const scaleFactor = incomeRatio * (unit==='households' ? EQUIVALENCE_SCALE : 1);
      const womenIncome = baseIncome.map(v => Math.round(v * scaleFactor * womenRatio));
      const menIncome = baseIncome.map(v => Math.round(v * scaleFactor * menRatio));
      const womenP10 = baseIncomeP10.map(v => Math.round(v * scaleFactor * womenRatio));
      const womenP90 = baseIncomeP90.map(v => Math.round(v * scaleFactor * womenRatio));
      const menP10 = baseIncomeP10.map(v => Math.round(v * scaleFactor * menRatio));
      const menP90 = baseIncomeP90.map(v => Math.round(v * scaleFactor * menRatio));
      genderIncomeChartInstance.data.labels = ageLabels;
      genderIncomeChartInstance.data.datasets[0].data = womenP10;
      genderIncomeChartInstance.data.datasets[1].data = womenP90;
      genderIncomeChartInstance.data.datasets[2].data = menP10;
      genderIncomeChartInstance.data.datasets[3].data = menP90;
      genderIncomeChartInstance.data.datasets[4].data = womenIncome;
      genderIncomeChartInstance.data.datasets[5].data = menIncome;
      // Force axes to start at zero and include percentile bands for range
      let gVals = womenIncome.concat(menIncome, womenP10, womenP90, menP10, menP90);
      const gAxis = computeAxis(gVals, 5000);
      genderIncomeChartInstance.options.scales.y.min = 0;
      genderIncomeChartInstance.options.scales.y.max = gAxis.max;
      genderIncomeChartInstance.options.scales.y.title.text = unit === 'households'
        ? 'Median Employment Income ($ - Households)'
        : 'Median Employment Income ($ - Individuals)';
      if (genderIncomeChartInstance.options.scales.y.ticks) {
        genderIncomeChartInstance.options.scales.y.ticks.display = true;
        genderIncomeChartInstance.options.scales.y.ticks.maxTicksLimit = 8;
      }
      genderIncomeChartInstance.update();

      // Income composition breakdown chart
      // Compute total income values for the selected region.  These values include
      // all income sources.  The composition shares below determine how
      // employment, investment, pension and transfer income contribute at each age.
      let scaledTotalIncome = baseTotalIncome.map(v => Math.round(v * incomeRatio));
      if (unit === 'households') {
        scaledTotalIncome = scaledTotalIncome.map(v => Math.round(v * EQUIVALENCE_SCALE));
      }
      const empData = [];
      const invData = [];
      const penData = [];
      const transData = [];
      for (let i = 0; i < ageLabels.length; i++) {
        const age = 18 + i;
        let empShare, invShare, penShare, transShare;
        if (age <= 55) {
          empShare = 0.90; invShare = 0.05; penShare = 0.03; transShare = 0.02;
        } else if (age <= 65) {
          const t = (age - 55) / 10;
          // Interpolate between 90/5/3/2 and 60/10/20/10
          empShare = 0.90 * (1 - t) + 0.60 * t;
          invShare = 0.05 * (1 - t) + 0.10 * t;
          penShare = 0.03 * (1 - t) + 0.20 * t;
          transShare = 0.02 * (1 - t) + 0.10 * t;
        } else {
          const t = (age - 65) / 15;
          // Interpolate between 60/10/20/10 and 10/25/50/15
          empShare = 0.60 * (1 - t) + 0.10 * t;
          invShare = 0.10 * (1 - t) + 0.25 * t;
          penShare = 0.20 * (1 - t) + 0.50 * t;
          transShare = 0.10 * (1 - t) + 0.15 * t;
        }
        const totalVal = scaledTotalIncome[i];
        empData.push(Math.round(totalVal * empShare));
        invData.push(Math.round(totalVal * invShare));
        penData.push(Math.round(totalVal * penShare));
        transData.push(Math.round(totalVal * transShare));
      }
      // Update the composition chart datasets with the computed component values
      if (compositionChartInstance) {
        compositionChartInstance.data.datasets[0].data = empData;
        compositionChartInstance.data.datasets[1].data = invData;
        compositionChartInstance.data.datasets[2].data = penData;
        compositionChartInstance.data.datasets[3].data = transData;
        // Determine the axis bounds based on total income values and user income
        let compVals = scaledTotalIncome.slice();
        if (userActive) compVals.push(userIncomeVal);
        let compAxis = computeAxis(compVals, 5000);
        compositionChartInstance.options.scales.y.stacked = true;
        compositionChartInstance.options.scales.y.min = 0;
        compositionChartInstance.options.scales.y.max = compAxis.max;
        compositionChartInstance.options.scales.y.title.text = unit === 'households'
          ? 'Income Components ($ - Households)'
          : 'Income Components ($ - Individuals)';
        if (compositionChartInstance.options.scales.y.ticks) {
          compositionChartInstance.options.scales.y.ticks.display = true;
          compositionChartInstance.options.scales.y.ticks.maxTicksLimit = 8;
        }
        compositionChartInstance.update();
      }

      // Net worth chart (median net worth) for selected unit
      const scaledNet = (unit === 'households' ? baseNetWorth : baseIndNetWorth).map(v => Math.round(v * netRatio));
      const netPctArrays = (unit === 'households') ? {
        p10: baseNetWorthP10.map(v => Math.round(v * netRatio)),
        p25: baseNetWorthP25.map(v => Math.round(v * netRatio)),
        p50: scaledNet,
        p75: baseNetWorthP75.map(v => Math.round(v * netRatio)),
        p90: baseNetWorthP90.map(v => Math.round(v * netRatio)),
        p99: baseNetWorthP99.map(v => Math.round(v * netRatio))
      } : {
        p10: baseIndNetWorthP10.map(v => Math.round(v * netRatio)),
        p25: baseIndNetWorthP25.map(v => Math.round(v * netRatio)),
        p50: scaledNet,
        p75: baseIndNetWorthP75.map(v => Math.round(v * netRatio)),
        p90: baseIndNetWorthP90.map(v => Math.round(v * netRatio)),
        p99: baseIndNetWorthP99.map(v => Math.round(v * netRatio))
      };
      const netLabelBase = unit === 'households' ? 'Median Net Worth (Households)' : 'Median Net Worth (Individuals)';
      const netColorMap = unit === 'households' ? percentileColors.netWorth : percentileColors.indNetWorth;
      const netResult = buildPercentileDatasets(unit === 'households' ? 'netWorth' : 'indNetWorth', scaledNet, netPctArrays, netColorMap, netLabelBase);
      // Preserve user dataset if present
      let netUserDs = null;
      netWorthChartInstance.data.datasets.forEach(ds => {
        if (ds.label === 'You' && userActive) netUserDs = ds;
      });
      // Build new datasets: median + selected percentiles + user
      let netDatasets = netResult.datasets.slice();
      if (netUserDs) netDatasets.push(netUserDs);
      netWorthChartInstance.data.datasets = netDatasets;
      // Compute axis for net worth chart
      let netVals = netResult.values.slice();
      if (userActive) netVals.push(userNetWorthVal);
      // include zero line values (it's 0 across ages) in axis to guarantee zero appears but computeAxis will handle automatically
      netVals = netVals.concat(new Array(ageLabels.length).fill(0));
      let netAxis = computeAxis(netVals, 200000);
      netWorthChartInstance.options.scales.y.min = netAxis.min;
      netWorthChartInstance.options.scales.y.max = netAxis.max;
      netWorthChartInstance.update();

      // Wealth Composition chart - assets stacked above zero, debts stacked below, plus net worth line
      (function updateWealthComposition(){
        const useNet = (unit==='households' ? baseNetWorth : baseIndNetWorth).map(v => Math.round(v * netRatio));
        // Approximate debt curve: peaks near mid-30s, declines after 50
        const peak = unit==='households' ? 200000 : 120000;
        const centerAge = 37; const sigma = 10;
        const debts = ageLabels.map((ageStr,i)=>{
          const age = parseInt(ageStr,10);
          const gauss = Math.exp(-0.5 * Math.pow((age - centerAge)/sigma, 2));
          let val = Math.round(peak * gauss);
          if (age < 20) val = Math.round(val*0.4);
          if (age > 70) val = Math.round(val*0.2);
          return val; // positive magnitude; we'll plot negative
        });
        // Total assets approximated as net worth + debt
        const totalAssets = useNet.map((nw,i)=> Math.max(0, nw + debts[i]));
        // Split assets by shares varying with age (more financial/pension later)
        const shares = ageLabels.map((aStr,i)=>{
          const t = i/(ageLabels.length-1);
          const realEstate = 0.55 - 0.15*t; // falls with age
          const financial = 0.25 + 0.15*t; // rises with age
          const pensions = 0.20 + 0.00*t;
          const sum = realEstate + financial + pensions;
          return { re: realEstate/sum, fin: financial/sum, pen: pensions/sum };
        });
        const re = totalAssets.map((TA,i)=> Math.round(TA * shares[i].re));
        const fin = totalAssets.map((TA,i)=> Math.round(TA * shares[i].fin));
        const pen = totalAssets.map((TA,i)=> Math.round(TA * shares[i].pen));
        const deb = debts.map(d=> -d); // negative for plotting
        const net = useNet; // already median net worth
        wealthCompositionChartInstance.data.labels = ageLabels;
        wealthCompositionChartInstance.data.datasets[0].data = re;
        wealthCompositionChartInstance.data.datasets[1].data = fin;
        wealthCompositionChartInstance.data.datasets[2].data = pen;
        wealthCompositionChartInstance.data.datasets[3].data = deb;
        wealthCompositionChartInstance.data.datasets[4].data = net;
        wealthCompositionChartInstance.data.datasets[4].borderColor = '#ffffff';
        wealthCompositionChartInstance.data.datasets[4].backgroundColor = 'transparent';
        wealthCompositionChartInstance.data.datasets[4].borderWidth = 2;
        wealthCompositionChartInstance.data.datasets[4].order = 9999;
        wealthCompositionChartInstance.data.datasets[4].z = 99;
        wealthCompositionChartInstance.data.datasets[4].fill = false;
        // Force net worth line to be the last drawn dataset
        const netDs = wealthCompositionChartInstance.data.datasets.find(ds => ds.label === 'Median Net Worth');
        if (netDs) {
          wealthCompositionChartInstance.data.datasets = wealthCompositionChartInstance.data.datasets.filter(ds => ds !== netDs);
          wealthCompositionChartInstance.data.datasets.push(netDs);
        }
        // Stacking: assets vs debts separated
        wealthCompositionChartInstance.options.scales.y.stacked = true;
        wealthCompositionChartInstance.options.scales.x.stacked = true;
        // Compute axis from combined arrays
        let wVals = re.concat(fin, pen, deb, net);
        const wAxis = computeAxis(wVals, 200000);
        wealthCompositionChartInstance.options.scales.y.min = wAxis.min;
        wealthCompositionChartInstance.options.scales.y.max = wAxis.max;
        wealthCompositionChartInstance.options.scales.y.title.text = unit==='households'
          ? 'Assets & Liabilities ($ - Households)'
          : 'Assets & Liabilities ($ - Individuals)';
        if (wealthCompositionChartInstance.options.scales.y.ticks) {
          wealthCompositionChartInstance.options.scales.y.ticks.display = true;
          wealthCompositionChartInstance.options.scales.y.ticks.maxTicksLimit = 8;
        }
        wealthCompositionChartInstance.update();
      })();

      // Update scatter chart (Income vs Net Worth, Median). X = median total income, Y = median net worth for selected unit.
      const scaledTotal = (unit === 'households'
        ? baseTotalIncome.map(v => Math.round(v * incomeRatio * EQUIVALENCE_SCALE))
        : baseTotalIncome.map(v => Math.round(v * incomeRatio)));
      const scaledNetForScatter = (unit === 'households'
        ? baseNetWorth.map(v => Math.round(v * netRatio))
        : baseIndNetWorth.map(v => Math.round(v * netRatio)));
      const scatterData = [];
      for (let i = 0; i < ageLabels.length; i++) {
        scatterData.push({ x: scaledTotal[i], y: scaledNetForScatter[i] });
      }
      // Base dataset is median
      scatterChartInstance.data.datasets[0].label = 'Median';
      scatterChartInstance.data.datasets[0].data = scatterData;
      // Add faint percentile overlays when selected (p10, p25, p75, p90, p99)
      const pToArray = (pKey) => {
        const incMap = { p10: baseTotalIncomeP10, p25: baseTotalIncomeP25, p50: baseTotalIncome, p75: baseTotalIncomeP75, p90: baseTotalIncomeP90, p99: baseTotalIncomeP99 };
        const netMapH = { p10: baseNetWorthP10, p25: baseNetWorthP25, p50: baseNetWorth, p75: baseNetWorthP75, p90: baseNetWorthP90, p99: baseNetWorthP99 };
        const netMapI = { p10: baseIndNetWorthP10, p25: baseIndNetWorthP25, p50: baseIndNetWorth, p75: baseIndNetWorthP75, p90: baseIndNetWorthP90, p99: baseIndNetWorthP99 };
        const incArr = (incMap[pKey] || baseTotalIncome).map(v => Math.round(v * incomeRatio * (unit === 'households' ? EQUIVALENCE_SCALE : 1)));
        const netArr = ((unit === 'households' ? netMapH[pKey] : netMapI[pKey]) || (unit==='households'?baseNetWorth:baseIndNetWorth)).map(v => Math.round(v * netRatio));
        return { incArr, netArr };
      };
      // Remove any previous percentile overlay datasets (keep index 0 for median and any 'You' dataset)
      scatterChartInstance.data.datasets = scatterChartInstance.data.datasets.filter((ds, i) => i === 0 || ds.label === 'You');
      const faintGreen = 'rgba(102,187,106,0.14)';
      const faintBlue = 'rgba(41,182,246,0.14)';
      // No percentile overlays on the scatter chart - keep only the median (and 'You' marker if present)
      // Colour code the scatter points by age.  We map age from blue to red across the
      // entire age range using an HSL colour gradient.  Each point is given a
      // corresponding colour so that younger ages appear blue and older ages fade to red.
      const scatterColors = ageLabels.map((lbl, idx) => {
        // Compute a colour gradient from blue to red.  We slightly raise the
        // lightness to improve visibility against the dark background.
        const t = idx / (ageLabels.length - 1);
        const hue = 240 - 240 * t; // 240 (blue) to 0 (red)
        // Use higher lightness (60%) for better contrast and keep saturation at 70%
        return `hsl(${hue}, 70%, 60%)`;
      });
      scatterChartInstance.data.datasets[0].pointBackgroundColor = scatterColors;
      scatterChartInstance.data.datasets[0].pointBorderColor = scatterColors;
      scatterChartInstance.data.datasets[0].backgroundColor = scatterColors;
      // Compute separate axis bounds for scatter chart (x and y). x step 5000, y step 200000.
      // Include median scatter points and percentile overlay datasets when computing axis bounds.
      const allScatterX = [];
      const allScatterY = [];
      scatterChartInstance.data.datasets.forEach(ds => {
        (ds.data || []).forEach(pt => {
          if (pt && typeof pt === 'object') {
            if (typeof pt.x === 'number' && !isNaN(pt.x)) allScatterX.push(pt.x);
            if (typeof pt.y === 'number' && !isNaN(pt.y)) allScatterY.push(pt.y);
          } else if (typeof pt === 'number' && !isNaN(pt)) {
            allScatterY.push(pt);
          }
        });
      });
      const xAxis = computeAxis(allScatterX.length ? allScatterX : scatterData.map(pt => pt.x), 5000);
      const yAxis = computeAxis(allScatterY.length ? allScatterY : scatterData.map(pt => pt.y), 200000);
      scatterChartInstance.options.scales = {
        x: {
          type: 'linear',
          position: 'bottom',
          min: Math.max(0, xAxis.min),
          max: xAxis.max,
          ticks: {
            color: '#b0c5e8',
            callback: function(value) {
              const rounded = Math.round(value / 1000) * 1000;
              return '$' + rounded.toLocaleString();
            },
            stepSize: 5000,
            maxTicksLimit: 10
          },
          grid: { color: '#1f3a64' },
          title: {
            display: true,
            text: unit === 'households'
              ? 'Median Employment Income ($ - Households)'
              : 'Median Employment Income ($ - Individuals)',
            color: '#e0e6ed'
          }
        },
        y: {
          min: yAxis.min,
          max: yAxis.max,
          title: {
            display: true,
            text: unit === 'households'
              ? 'Median Net Worth ($ - Households)'
              : 'Median Net Worth ($ - Individuals)',
            color: '#e0e6ed'
          },
          ticks: {
            color: '#b0c5e8',
            callback: function(value) {
              const rounded = Math.round(value / 1000) * 1000;
              return '$' + rounded.toLocaleString();
            },
            stepSize: 200000
          },
          grid: { color: '#1f3a64' }
        }
      };
      scatterChartInstance.update();

      // Province bar chart with percentile overlays and user line
      // Rebuild the bar dataset and percentile line datasets for the province chart.
      // Highlight the selected province by changing its bar colour.
      const barColors = baseProvinceLabels.map(label => label === region ? '#ffa726' : '#66bb6a');
      // Remove any existing user dataset before rebuilding the chart
      const existingDs = provinceChartInstance.data.datasets;
      let userLine = null;
      // Extract the bar dataset and existing user line if present
      let barDataset = null;
      existingDs.forEach(ds => {
        if (ds.type === 'bar' || !ds.type) {
          barDataset = ds;
        } else if (ds.label === 'You') {
          userLine = ds;
        }
      });
      if (!barDataset) {
        // Fallback in case of unexpected structure
        barDataset = { label: 'Median Net Worth', data: baseProvinceValues.slice(), backgroundColor: barColors, type: 'bar' };
      }
      // Update bar data and colours
      barDataset.data = baseProvinceValues.slice();
      barDataset.backgroundColor = barColors;
      barDataset.borderColor = barColors;
      barDataset.borderWidth = 0;
      barDataset.order = 1;
      barDataset.z = 0;
      // For province chart we display the median as bars and draw whiskers
      // representing the 10th and 90th percentiles via a drawing plugin.
      // Choose base values according to unit (households vs individuals).
      const baseProvinceValsForUnit = (unit === 'households')
        ? baseProvinceValues.slice()
        : baseProvinceValues.map(v => Math.round(v / EQUIVALENCE_SCALE));
      // Update bar dataset data to use unit-aware values
      barDataset.data = baseProvinceValsForUnit.slice();
      // Compute whisker values as proportional tails of the median bars
      const provincePctRatios = { p10: 0.10, p90: 1.80 };
      const p10Values = baseProvinceValsForUnit.map(v => Math.round(v * provincePctRatios.p10));
      const p90Values = baseProvinceValsForUnit.map(v => Math.round(v * provincePctRatios.p90));
      // Store whisker values on the chart instance for the provinceWhiskers plugin
      provinceChartInstance._whiskers = { p10: p10Values, p90: p90Values };
      // Only the median bar dataset is used for drawing; user line will be re-added by addUserMarkers()
      provinceChartInstance.data.datasets = [ barDataset ];
      // Compute axis bounds including bars, whiskers and user value if present
      let provinceValsForAxis = baseProvinceValsForUnit.slice();
      // include whisker values so the y-axis covers the 10th-90th range
      provinceValsForAxis = provinceValsForAxis.concat(p10Values, p90Values);
      const prevProvScale = (provinceChartInstance.options && provinceChartInstance.options.scales && provinceChartInstance.options.scales.y) || {};
      const provinceAxis = computeProvinceDomain(provinceValsForAxis, {
        beginAtZero: true,
        paddingPct: 0.15,
        minPadding: 10000,
        fallbackMax: 1200000,
        prevMin: prevProvScale.min,
        prevMax: prevProvScale.max,
        maxClampFactor: 2.5
      });
      console.log('Province domain debug', { metric: 'netWorth', min: provinceAxis.min, max: provinceAxis.max, topValues: provinceAxis.topValues });
      provinceChartInstance.options.scales.y.beginAtZero = true;
      provinceChartInstance.options.scales.y.min = 0;
      provinceChartInstance.options.scales.y.max = provinceAxis.max;
      provinceChartInstance.options.scales.y.title.text = unit === 'households'
        ? 'Median Net Worth ($ - Households)'
        : 'Median Net Worth ($ - Individuals)';
      if (provinceChartInstance.options.scales.y.ticks) {
        provinceChartInstance.options.scales.y.ticks.display = true;
        provinceChartInstance.options.scales.y.ticks.maxTicksLimit = 8;
      }
      provinceChartInstance.update();

      // Province income chart (median and percentile income by province)
      // Compute a representative median income for each province using the national
      // median employment income at age 40 (baseIncome[22]) scaled by the
      // province-specific income ratio.  This yields a single value per
      // province suitable for bar display.
      const baseMedianIncome = (unit === 'households') ? Math.round(baseIncome[22] * EQUIVALENCE_SCALE) : baseIncome[22];
      const provinceIncomeBars = baseProvinceLabels.map(lbl => {
        const ratio = incomeRatios[lbl] || 1;
        return Math.round(baseMedianIncome * ratio);
      });
      // Highlight the selected province in orange
      const incomeBarColors = baseProvinceLabels.map(lbl => lbl === region ? '#ffa726' : '#42a5f5');
      // Define constant percentile ratios for income across provinces.  These
      // values approximate the 10th, 25th, 75th, 90th and 99th percentile as
      // proportions of the median income, based on 2016 census income
      // distributions?605841652791315-L220-L244?.
      // Province income chart: show median bars and store 10th/90th for whiskers
      const provinceIncomePctRatios = { p10: 0.22, p90: 2.44 };
      const p10IncomeValues = provinceIncomeBars.map(v => Math.round(v * provinceIncomePctRatios.p10));
      const p90IncomeValues = provinceIncomeBars.map(v => Math.round(v * provinceIncomePctRatios.p90));
      // Store whiskers for the income chart and set the median bars
      provinceIncomeChartInstance._whiskers = { p10: p10IncomeValues, p90: p90IncomeValues };
      provinceIncomeChartInstance.data.datasets = [ { label: 'Median Income', data: provinceIncomeBars, backgroundColor: incomeBarColors, type: 'bar' } ];
      // Ensure axis includes whiskers
      let provinceIncomeVals = provinceIncomeBars.slice();
      provinceIncomeVals = provinceIncomeVals.concat(p10IncomeValues, p90IncomeValues);
      const prevIncomeScale = (provinceIncomeChartInstance.options && provinceIncomeChartInstance.options.scales && provinceIncomeChartInstance.options.scales.y) || {};
      const provinceIncomeAxis = computeProvinceDomain(provinceIncomeVals, {
        beginAtZero: true,
        paddingPct: 0.15,
        minPadding: 2000,
        fallbackMax: 250000,
        prevMin: prevIncomeScale.min,
        prevMax: prevIncomeScale.max,
        maxClampFactor: 2.5
      });
      console.log('Province domain debug', { metric: 'income', min: provinceIncomeAxis.min, max: provinceIncomeAxis.max, topValues: provinceIncomeAxis.topValues });
      provinceIncomeChartInstance.options.scales.y.beginAtZero = true;
      provinceIncomeChartInstance.options.scales.y.min = 0;
      provinceIncomeChartInstance.options.scales.y.max = provinceIncomeAxis.max;
      provinceIncomeChartInstance.options.scales.y.title.text = unit === 'households'
        ? 'Median Employment Income ($ - Households)'
        : 'Median Employment Income ($ - Individuals)';
      if (provinceIncomeChartInstance.options.scales.y.ticks) {
        provinceIncomeChartInstance.options.scales.y.ticks.display = true;
        provinceIncomeChartInstance.options.scales.y.ticks.maxTicksLimit = 8;
      }
      provinceIncomeChartInstance.update();
      
      // Update titles (preserve info-icon spans)
      const suffix = region === 'Canada' ? 'Canada' : region;
      const unitTitle = unit === 'households' ? 'Households' : 'Individuals';
      
      // Update income title - preserve info-icon
      const incomeTitleEl = document.getElementById('incomeTitle');
      const incomeIcon = incomeTitleEl.querySelector('.info-icon');
      incomeTitleEl.textContent = `Estimated Median Employment Income by Age (${unitTitle}, ${BASE_YEAR}) - ${suffix}`;
      if (incomeIcon) incomeTitleEl.appendChild(incomeIcon);
      
      // Update composition title - preserve info-icon
      const compositionTitleEl = document.getElementById('compositionTitle');
      const compositionIcon = compositionTitleEl.querySelector('.info-icon');
      compositionTitleEl.textContent = `Median Income Composition by Age (${unitTitle}, ${BASE_YEAR}) - ${suffix}`;
      if (compositionIcon) compositionTitleEl.appendChild(compositionIcon);
      
      // Update net worth title - preserve info-icon
      const netWorthTitleEl = document.getElementById('netWorthTitle');
      const netWorthIcon = netWorthTitleEl.querySelector('.info-icon');
      netWorthTitleEl.textContent = `Estimated Median Net Worth by Age (${unitTitle}, ${BASE_YEAR}) - ${suffix}`;
      if (netWorthIcon) netWorthTitleEl.appendChild(netWorthIcon);
      
      // Update wealth composition title - preserve info-icon
      const wealthTitleEl = document.getElementById('wealthCompositionTitle');
      if (wealthTitleEl) {
        const wealthIcon = wealthTitleEl.querySelector('.info-icon');
        wealthTitleEl.textContent = `Median Wealth Composition by Age (${unitTitle}, ${BASE_YEAR})`;
        if (wealthIcon) wealthTitleEl.appendChild(wealthIcon);
      }
      
      // Update gender income title - preserve info-icon
      const genderTitleEl = document.getElementById('genderIncomeTitle');
      if (genderTitleEl) {
        const genderIcon = genderTitleEl.querySelector('.info-icon');
        genderTitleEl.textContent = `Income Percentile by Gender (${unitTitle}, ${BASE_YEAR}) - ${suffix}`;
        if (genderIcon) genderTitleEl.appendChild(genderIcon);
      }
      
      // Update scatter title - preserve info-icon
      const scatterTitleEl = document.getElementById('scatterTitle');
      const scatterIcon = scatterTitleEl.querySelector('.info-icon');
      scatterTitleEl.textContent = `Median Income vs Net Worth by Age (${unitTitle}, ${BASE_YEAR}) - ${suffix}`;
      if (scatterIcon) scatterTitleEl.appendChild(scatterIcon);
      // Update percentile charts for current region using region-wide medians
      let regionMedianNetWorth;
      let regionMedianIncome;
      const provinceIndex = baseProvinceLabels.indexOf(region);
      const nationalMedianNetWorthHousehold = Math.round(652286 * (1 + NET_WORTH_GROWTH_NOMINAL)); // projected national household median (2026)
      const nationalMedianIncomeIndividual = baseIncome[22];
      const nationalMedianNetWorth = (unit === 'households') ? nationalMedianNetWorthHousehold : Math.round(nationalMedianNetWorthHousehold / EQUIVALENCE_SCALE);
      const nationalMedianIncome = (unit === 'households') ? Math.round(nationalMedianIncomeIndividual * EQUIVALENCE_SCALE) : nationalMedianIncomeIndividual;
      if (region === 'Canada' || provinceIndex === -1) {
        regionMedianNetWorth = nationalMedianNetWorth;
        regionMedianIncome = nationalMedianIncome;
      } else {
        regionMedianNetWorth = (unit === 'households') ? baseProvinceValues[provinceIndex] : Math.round(baseProvinceValues[provinceIndex] / EQUIVALENCE_SCALE);
        regionMedianIncome = Math.round((incomeRatios[region] || 1) * nationalMedianIncome);
      }
      // Estimate normal distribution parameters from anchor ratios
      function estimateNormalParams(median, r10, r90) {
        const z = 1.2815515655446004; // Phi^{-1}(0.90)
        const x10 = median * r10;
        const x90 = median * r90;
        const s10 = (median - x10) / z;
        const s90 = (x90 - median) / z;
        const sigma = Math.max(1, (s10 + s90) / 2);
        return { mu: median, sigma };
      }
      function normInv(p) {
        // Acklam's approximation for inverse normal CDF
        // https://web.archive.org/web/20150910044736/http://home.online.no/~pjacklam/notes/invnorm/
        const a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
        const b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
        const c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
        const d = [7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
        const plow = 0.02425; const phigh = 1 - plow;
        let q, r;
        if (p < plow) {
          q = Math.sqrt(-2 * Math.log(p));
          return (((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
                 ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
        }
        if (p > phigh) {
          q = Math.sqrt(-2 * Math.log(1 - p));
          return -(((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
                   ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
        }
        q = p - 0.5; r = q*q;
        return (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5]) * q /
               (((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1);
      }
      // Build histogram-style distributions from normal approximation
      function buildNormalHistogram(mu, sigma, binCount = 30) {
        const minX = Math.max(0, mu - 3.5 * sigma);
        const maxX = mu + 3.5 * sigma;
        const width = (maxX - minX) / binCount;
        const pts = [];
        const invSQRT2PI = 1 / Math.sqrt(2 * Math.PI);
        for (let i = 0; i < binCount; i++) {
          const xMid = minX + (i + 0.5) * width;
          const z = (xMid - mu) / sigma;
          const pdf = invSQRT2PI * Math.exp(-0.5 * z * z) / sigma; // density per $1
          const prob = pdf * width; // probability mass in this bin
          pts.push({ x: xMid, y: prob * 100 }); // percentage
        }
        return { points: pts, minX, maxX };
      }
      const netParams = estimateNormalParams(regionMedianNetWorth, 0.10, 1.80);
      const incParams = estimateNormalParams(regionMedianIncome, 0.22, 2.44);
      const netHist = buildNormalHistogram(netParams.mu, netParams.sigma);
      const incHist = buildNormalHistogram(incParams.mu, incParams.sigma);

      // Update datasets
      percentileNetWorthChartInstance.data.labels = [];
      percentileNetWorthChartInstance.data.datasets = [ { label: 'Net Worth Distribution', data: netHist.points, backgroundColor: '#66bb6a' } ];
      percentileIncomeChartInstance.data.labels = [];
      percentileIncomeChartInstance.data.datasets = [ { label: 'Income Distribution', data: incHist.points, backgroundColor: '#29b6f6' } ];
      // Axes: X in dollars (linear), Y in percent probability
      percentileNetWorthChartInstance.options.scales = {
        x: { type: 'linear', position: 'bottom', ticks: { color: '#b0c5e8', callback: (v)=> '$' + Math.round(v/1000).toLocaleString() + 'k', maxTicksLimit: 10 }, grid: { color: '#1f3a64' }, min: netHist.minX, max: netHist.maxX, title: { display: true, text: 'Net Worth ($)', color: '#e0e6ed' } },
        y: { min: 0, ticks: { color: '#b0c5e8', callback: (v)=> v + '%' }, grid: { color: '#1f3a64' } }
      };
      percentileIncomeChartInstance.options.scales = {
        x: { type: 'linear', position: 'bottom', ticks: { color: '#b0c5e8', callback: (v)=> '$' + Math.round(v/1000).toLocaleString() + 'k', maxTicksLimit: 10 }, grid: { color: '#1f3a64' }, min: incHist.minX, max: incHist.maxX, title: { display: true, text: 'Employment Income ($)', color: '#e0e6ed' } },
        y: { min: 0, ticks: { color: '#b0c5e8', callback: (v)=> v + '%' }, grid: { color: '#1f3a64' } }
      };
      // Save dist params for tooltips
      percentileNetWorthChartInstance.options.plugins.distParams = { mu: netParams.mu, sigma: netParams.sigma };
      percentileIncomeChartInstance.options.plugins.distParams = { mu: incParams.mu, sigma: incParams.sigma };
      // Draw a subtle median line on both distributions
      percentileNetWorthChartInstance.options.plugins.medianVLine = { xValue: netParams.mu, color: 'rgba(255,255,255,0.6)', dash: [2,2], width: 1, label: 'Median' };
      percentileIncomeChartInstance.options.plugins.medianVLine = { xValue: incParams.mu, color: 'rgba(255,255,255,0.6)', dash: [2,2], width: 1, label: 'Median' };
      // Cache percentile curves for histogram percentile lookups (align with tiles)
      const netCurve = makePercentileValues(regionMedianNetWorth, netWorthPercentileAnchors);
      const incCurve = makePercentileValues(regionMedianIncome, incomePercentileAnchors);
      percentileNetWorthChartInstance.options.plugins.distCurve = netCurve;
      percentileIncomeChartInstance.options.plugins.distCurve = incCurve;
      // Custom tooltip for histograms (percent at $x) using curve inversion
      const histLabelPctile = (ctx) => {
        const x = ctx.parsed?.x ?? 0;
        const curve = ctx?.chart?.options?.plugins?.distCurve || [];
        const idx = curve.length ? findPercentileIndex(x, curve) : 0;
        const pct = clampPercentile(idx + 1);
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        return `Percentile: ${toOrdinal(pct)} - $${Math.round(x).toLocaleString()}`;
      };
      // Merge tooltip options instead of overwriting to preserve external handler
      percentileNetWorthChartInstance.options.plugins.tooltip = Object.assign({}, percentileNetWorthChartInstance.options.plugins.tooltip || {}, { mode: 'nearest', intersect: false, callbacks: { label: histLabelPctile } });
      percentileIncomeChartInstance.options.plugins.tooltip = Object.assign({}, percentileIncomeChartInstance.options.plugins.tooltip || {}, { mode: 'nearest', intersect: false, callbacks: { label: histLabelPctile } });
      
      // Update histogram titles - preserve info-icons
      const netWorthHistEl = document.getElementById('percentileNetWorthTitle');
      const netWorthHistIcon = netWorthHistEl.querySelector('.info-icon');
      netWorthHistEl.textContent = `Net Worth Distribution (${unitTitle}, ${BASE_YEAR}) - ${suffix}`;
      if (netWorthHistIcon) netWorthHistEl.appendChild(netWorthHistIcon);
      
      const incomeHistEl = document.getElementById('percentileIncomeTitle');
      const incomeHistIcon = incomeHistEl.querySelector('.info-icon');
      incomeHistEl.textContent = `Income Distribution (${unitTitle}, ${BASE_YEAR}) - ${suffix}`;
      if (incomeHistIcon) incomeHistEl.appendChild(incomeHistIcon);
      if (userActive) {
        // Draw vertical line at user's value on histograms with percentile labels using the same thresholds as tiles
        const ageForPct = Math.max(18, Math.min(80, userAgeVal || 18));
        const idxPct = ageForPct - 18;
        const incPcts = getScaledIncomePercentiles(idxPct, region, unit);
        const netPcts = getScaledNetWorthPercentiles(idxPct, region, unit);
        const incThresh = [
          {p:10, v: incPcts.p10},
          {p:25, v: incPcts.p25},
          {p:50, v: incPcts.p50},
          {p:75, v: incPcts.p75},
          {p:90, v: incPcts.p90},
          {p:99, v: baseTotalIncomeP99[idxPct] * (incomeRatios[region] || 1) * (unit==='households'? EQUIVALENCE_SCALE:1)}
        ];
        const netThresh = [
          {p:10, v: netPcts.p10},
          {p:25, v: netPcts.p25},
          {p:50, v: netPcts.p50},
          {p:75, v: netPcts.p75},
          {p:90, v: netPcts.p90},
          {p:99, v: (unit==='households' ? baseNetWorthP99[idxPct] : baseIndNetWorthP99[idxPct]) * (netWorthRatios[region] || 1)}
        ];
        const incPct = clampPercentile(computePercentileFromThresholds(userIncomeVal, incThresh));
        const netPct = clampPercentile(computePercentileFromThresholds(userNetWorthVal, netThresh));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: userNetWorthVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(netPct)} percentile` };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: userIncomeVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(incPct)} percentile` };
      } else {
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: null };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: null };
      }
      percentileNetWorthChartInstance.update();
      percentileIncomeChartInstance.update();
      
      // Update province titles - preserve info-icons
      const provinceNetWorthEl = document.getElementById('provinceTitle');
      const provinceNetWorthIcon = provinceNetWorthEl.querySelector('.info-icon');
      provinceNetWorthEl.textContent = `Projected Median Net Worth by Province (${unitTitle}, ${BASE_YEAR})`;
      if (provinceNetWorthIcon) provinceNetWorthEl.appendChild(provinceNetWorthIcon);
      
      const provinceIncomeEl = document.getElementById('provinceIncomeTitle');
      const provinceIncomeIcon = provinceIncomeEl.querySelector('.info-icon');
      provinceIncomeEl.textContent = `Median Income by Province (${unitTitle}, ${BASE_YEAR})`;
      if (provinceIncomeIcon) provinceIncomeEl.appendChild(provinceIncomeIcon);
      // If the user has entered comparison data, replot the markers after updating the charts.
      if (userActive) {
        addUserMarkers();
      }
      // Refresh summary tiles if user data is present
      if (userActive) {
        try { showYouVsEveryone(); } catch (e) { /* no-op */ }
      }
    }

    /**
     * Generic chart creator
     * @param {string} canvasId
     * @param {Object} dataInfo
     * @param {string} type - Chart type (line or bar)
     */
function createChart(canvasId, dataInfo, type = 'line') {
  const ctx = document.getElementById(canvasId).getContext('2d');
  const axisLabels = dataInfo.axisLabels || {};
  const tickFontSize = dataInfo.tickFontSize || 12;
  const axisTitleColor = '#e0e6ed';

  // - helpers -
  const toRGBA = (hex, a=1) => {
    if (!hex) return `rgba(79,195,247,${a})`; // fallback light blue
    const h = hex.replace('#','');
    const bigint = parseInt(h, 16);
    const r = (h.length===3) ? ((bigint>>8)&0xF)*17 : (bigint>>16)&0xFF;
    const g = (h.length===3) ? ((bigint>>4)&0xF)*17 : (bigint>>8)&0xFF;
    const b = (h.length===3) ? (bigint&0xF)*17     : (bigint>>0)&0xFF;
    return `rgba(${r},${g},${b},${a})`;
  };

  // Flatten numeric values for y-scaling. Support datasets where data
  // items may be plain numbers or point objects like {x, y} used by
  // histograms/scatter datasets. We prefer y values when present.
  const allValues = [];
  dataInfo.datasets.forEach(ds => {
    (ds.data || []).forEach(v => {
      if (v && typeof v === 'object') {
        if (typeof v.y === 'number' && !isNaN(v.y)) allValues.push(v.y);
        else if (typeof v.x === 'number' && !isNaN(v.x)) allValues.push(v.x);
      } else if (typeof v === 'number' && !isNaN(v)) {
        allValues.push(v);
      }
    });
  });
  const minVal = allValues.length ? Math.min(...allValues) : 0;
  const maxVal = allValues.length ? Math.max(...allValues) : 1;
  const pad = (maxVal - minVal) * 0.05;
  let yMin = Math.floor((minVal - pad) / 1000) * 1000;
  let yMax = Math.ceil((maxVal + pad) / 1000) * 1000;

  if (dataInfo.step) {
    const range = yMax - yMin;
    const remainder = range % dataInfo.step;
    if (remainder !== 0) yMax += dataInfo.step - remainder;
  }

  // stacking only for non-scatter when at least one dataset has .stack
  const isStacked = type !== 'scatter' && dataInfo.datasets.some(ds => ds.stack);

  // Build datasets w/ safe colors + optional gradient fill
    const datasets = dataInfo.datasets.map((ds) => {
    const stroke = ds.borderColor || ds.color || '#29b6f6';
    let fillColor = ds.backgroundColor || (ds.fill ? toRGBA(stroke, ds.fillOpacity ?? 0.35) : 'transparent');

    // For stacked/filled areas, create a subtle vertical gradient (fade) unless explicitly disabled
    if ((ds.fill || ds.stack) && type !== 'bar' && type !== 'scatter' && !ds.noGradient) {
      const grad = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
      grad.addColorStop(0, toRGBA(stroke, 0.45));
      grad.addColorStop(1, toRGBA(stroke, 0.05));
      fillColor = grad;
    } else if (ds.fill || ds.stack) {
      fillColor = ds.backgroundColor || toRGBA(stroke, ds.fillOpacity ?? 0.35);
    }

    return {
      label: ds.label,
      data: ds.data,
      borderColor: stroke,
      backgroundColor: fillColor,
      borderWidth: ds.borderWidth ?? 2,
      tension: ds.tension ?? 0.3,
      fill: ds.fill !== undefined ? ds.fill : !!(ds.stack),
      stack: ds.stack || undefined,
      type: ds.type || undefined,
      pointRadius: ds.pointRadius ?? (type==='scatter' ? 4 : 2),
      pointHoverRadius: ds.pointHoverRadius ?? (type==='scatter' ? 5 : 5),
      pointHitRadius: ds.pointHitRadius ?? 10,
      borderDash: ds.borderDash || undefined,
      order: ds.order ?? 1,
      showLine: ds.showLine,
      inlineLabel: ds.inlineLabel,
      tooltip: ds.tooltip,
      noGradient: ds.noGradient
    };
  });

  // X ticks
  const labels = dataInfo.labels || [];
  const xTickOptions = {
    color: '#b0c5e8',
    font: { size: tickFontSize },
    callback: function(value, index) { return labels[index]; }
  };
  if (type === 'bar') {
    xTickOptions.autoSkip = false; xTickOptions.maxRotation = 45; xTickOptions.minRotation = 45;
  } else if (type !== 'scatter') {
    xTickOptions.autoSkip = true; xTickOptions.maxTicksLimit = 10;
  }

  // Watermark colour: consistent faint blue across all charts

  // Base options; special-case scatter axes below
  const options = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: { mode: 'nearest', intersect: false },
    hover: { mode: 'nearest', intersect: false },
    scales: {
      x: {
        stacked: isStacked,
        ticks: xTickOptions,
        grid: { color: '#1f3a64' }
      },
      y: {
        stacked: isStacked,
        min: yMin,
        max: yMax,
      ticks: {
        color: '#b0c5e8',
        font: { size: tickFontSize },
        callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); },
        stepSize: dataInfo.step,
        maxTicksLimit: dataInfo.step ? Math.ceil((yMax - yMin)/dataInfo.step) + 1 : undefined
      },
      grid: { color: '#1f3a64' }
      }
    },
    plugins: {
      legend: {
        display: false,
        labels: { color: '#e0e6ed', usePointStyle: true }
      },
      tooltip: {
        // Use index mode so the tooltip includes all series for the hovered age
        mode: 'index',
        intersect: false,
        // Visually suppress built-in canvas tooltip drawing so only the
        // external DOM tooltip is visible. We keep callbacks for value
        // formatting for accessibility and potential fallbacks.
        backgroundColor: 'rgba(0,0,0,0)',
        titleColor: 'transparent',
        bodyColor: 'transparent',
        borderColor: 'transparent',
        displayColors: false,
      callbacks: {
        label: (ctx) => {
          const label = ctx.dataset.label || '';
          const y = (ctx.parsed?.y ?? ctx.raw?.y ?? ctx.raw);
          if (typeof y === 'number') return `${label}: $${y.toLocaleString()}`;
          return label;
        }
      }
      }
    }
  };

  // If a global external tooltip handler was installed on Chart.defaults,
  // ensure we don't accidentally remove it when the code sets a local
  // `options.plugins.tooltip` object.  Many charts here replace the
  // tooltip object completely which would drop the `external` handler.
  // Preserve external/position/intersect defaults when not explicitly set.
  try {
    const globalTip = Chart?.defaults?.plugins?.tooltip;
    if (globalTip && globalTip.external) {
      options.plugins = options.plugins || {};
      options.plugins.tooltip = options.plugins.tooltip || {};
      if (options.plugins.tooltip.external === undefined) options.plugins.tooltip.external = globalTip.external;
      if (options.plugins.tooltip.position === undefined && globalTip.position !== undefined) options.plugins.tooltip.position = globalTip.position;
      if (options.plugins.tooltip.intersect === undefined && globalTip.intersect !== undefined) options.plugins.tooltip.intersect = globalTip.intersect;
    }
  } catch (e) {
    // noop; defensive in case Chart isn't available at runtime
  }

  // Proper axes for scatter from the start (prevents the blank-chart error)
  if (type === 'scatter') {
    options.scales.x = {
      type: 'linear',
      position: 'bottom',
      ticks: {
        color: '#b0c5e8',
        font: { size: tickFontSize },
        callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); },
        maxTicksLimit: 10
      },
      grid: { color: '#1f3a64' }
    };
    options.scales.y = {
      min: yMin,
      max: yMax,
      ticks: {
        color: '#b0c5e8',
        font: { size: tickFontSize },
        callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); }
      },
      grid: { color: '#1f3a64' }
    };
  }

  const setAxisTitle = (axis, text) => {
    if (!text) return;
    if (!options.scales[axis]) options.scales[axis] = {};
    options.scales[axis].title = {
      display: true,
      text,
      color: axisTitleColor,
      font: { size: tickFontSize, weight: '600' },
      padding: { top: 6, bottom: 2 }
    };
  };
  setAxisTitle('x', axisLabels.x);
  setAxisTitle('y', axisLabels.y);

  // Ensure compact tick padding on both axes
  if (options.scales?.x?.ticks && options.scales.x.ticks.padding === undefined) {
    options.scales.x.ticks.padding = 4;
  }
  if (options.scales?.y?.ticks && options.scales.y.ticks.padding === undefined) {
    options.scales.y.ticks.padding = 4;
  }

  if (dataInfo.tooltip) {
    options.plugins.tooltip = Object.assign({}, options.plugins.tooltip, dataInfo.tooltip);
  }

  const chartInstance = new Chart(ctx, { type, data: { labels, datasets }, options });
  if (!allCharts.includes(chartInstance)) allCharts.push(chartInstance);
  chartInstance.__step = dataInfo.step || null;
  return chartInstance;
}

    let chartsInitialized = false;
    function initCharts() {
      if (chartsInitialized) return;
      // Build Chart.js instances for each canvas using the base (Canada) data
      // Build initial income chart including percentile lines and a placeholder
      // 'You' dataset so the legend always includes the user marker.
      incomeChartInstance = createChart('incomeChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Median', data: baseIncome, borderColor: percentileColors.income.p50, backgroundColor: 'transparent', pointRadius: 0, tension: 0.35 },
          { label: '10th Percentile', data: baseIncomeP10, borderColor: percentileColors.income.p10, backgroundColor: 'transparent', pointRadius: 0, tension: 0.35 },
          { label: '25th Percentile', data: baseIncomeP25, borderColor: percentileColors.income.p25, backgroundColor: 'transparent', pointRadius: 0, tension: 0.35 },
          { label: '75th Percentile', data: baseIncomeP75, borderColor: percentileColors.income.p75, backgroundColor: 'transparent', pointRadius: 0, tension: 0.35 },
            { label: '90th Percentile', data: baseIncomeP90, borderColor: percentileColors.income.p90, backgroundColor: 'transparent', pointRadius: 0, tension: 0.35 }
        ],
        step: 5000,
        axisLabels: {
          x: 'Age (Years)',
          y: 'Median Employment Income ($ - Individuals / Households)'
        },
        tooltip: {
          enabled: true,
          mode: 'index',
          intersect: false,
          itemSort: (a, b) => {
            const label = (it) => (it?.dataset?.label || '').toLowerCase();
            const rank = (it) => {
              const l = label(it);
              if (l.includes('men p90') || (l.includes('p90') && l.includes('men'))) return 1;
              if (l.includes('women p90') || (l.includes('p90') && l.includes('women'))) return 2;
              if (l.includes('men (median)') || (l.includes('median') && l.includes('men'))) return 3;
              if (l.includes('women (median)') || (l.includes('median') && l.includes('women'))) return 4;
              if (l.includes('men p10') || (l.includes('p10') && l.includes('men'))) return 5;
              if (l.includes('women p10') || (l.includes('p10') && l.includes('women'))) return 6;
              return 999;
            };
            return rank(a) - rank(b);
          }
        }
      }, 'line');

      // Build the income composition chart.  This stacked area chart will show the
      // breakdown of total income into employment, investment, pension and transfer
      // components.  Each dataset is initially populated with zeros; actual values
      // are computed in updateCharts() based on the selected region and age.

      compositionChartInstance = createChart('compositionChart', {
  labels: ageLabels,
  datasets: [
    {
      label: 'Employment Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#42a5f5',
      backgroundColor: 'rgba(66,165,245,0.30)',
      fill: true,
      noGradient: true,
      stack: 'income'
    },
    {
      label: 'Investment Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#66bb6a',
      backgroundColor: 'rgba(102,187,106,0.30)',
      fill: true,
      noGradient: true,
      stack: 'income'
    },
    {
      label: 'Pension Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#ffa726',
      backgroundColor: 'rgba(255,167,38,0.30)',
      fill: true,
      noGradient: true,
      stack: 'income'
    },
    {
      label: 'Government Transfers',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#ab47bc',
      backgroundColor: 'rgba(171,71,188,0.30)',
      fill: true,
      noGradient: true,
      stack: 'income'
    }
  ],
  step: 5000,
  axisLabels: {
    x: 'Age (Years)',
    y: 'Income Components ($ - Individuals / Households)'
  }
}, 'line');

      // Build the combined net worth chart (households vs individuals).  Both series
      // are shown by default; additional percentile lines can be toggled via the
      // percentile selector.
      netWorthChartInstance = createChart('netWorthChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Median Net Worth (Households)', data: baseNetWorth, color: '#66bb6a' }
        ],
        step: 200000,
        axisLabels: {
          x: 'Age (Years)',
          y: 'Median Net Worth ($ - Households / Individuals)'
        }
      }, 'line');
      // Build the scatter chart for income vs net worth.  This uses the median total income
      // as the x-value and the median net worth (households) as the y-value for each age.
      scatterChartInstance = createChart('scatterChart', {
        labels: ageLabels,
        datasets: [
          {
            label: 'Income vs Net Worth',
            data: [],
            borderColor: '#66bb6a',
            backgroundColor: '#66bb6a',
            pointBackgroundColor: '#66bb6a',
            pointBorderColor: '#66bb6a',
            // Increase the base point size to improve visibility.  A larger
            // point radius and hover radius make scatter points easier to see.
            pointRadius: 5,
            pointHoverRadius: 6,
            showLine: false
          }
        ],
        // We will update the step sizes dynamically in updateCharts
        step: null,
        axisLabels: {
          x: 'Median Total Income ($ - Households / Individuals)',
          y: 'Median Net Worth ($ - Households / Individuals)'
        }
      }, 'scatter');
      // The province chart remains the same; median provincial values are used as bars.
      // Build the province bar chart. Use a default color for all bars; the
      // selected province will be highlighted via updateCharts().
      provinceChartInstance = createChart('provinceChart', {
        labels: baseProvinceLabels,
        datasets: [ { label: 'Median Net Worth', data: baseProvinceValues, backgroundColor: '#66bb6a', borderColor: '#66bb6a', borderWidth: 0 } ],
        step: 50000,
        axisLabels: {
          x: 'Province',
          y: 'Median Net Worth ($ - Households)'
        }
      }, 'bar');

      // Build the provincial median income chart.  This bar chart displays
      // typical median employment income for each province using the
      // baseProvinceIncomeValues array.  Percentile lines are drawn on top
      // via updateCharts() when selected from the percentile selector.
      provinceIncomeChartInstance = createChart('provinceIncomeChart', {
        labels: baseProvinceLabels,
        datasets: [ { label: 'Median Income', data: baseProvinceIncomeValues, backgroundColor: '#42a5f5' } ],
        step: 5000,
        axisLabels: {
          x: 'Province',
          y: 'Median Employment Income ($)'
        }
      }, 'bar');

      // Wealth Composition baseline; data is computed in updateCharts per region/unit
      wealthCompositionChartInstance = createChart('wealthCompositionChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Real Estate', data: new Array(ageLabels.length).fill(0), borderColor: '#66bb6a', backgroundColor: 'rgba(102,187,106,0.55)', fill: true, stack: 'assets' },
          { label: 'Financial Assets', data: new Array(ageLabels.length).fill(0), borderColor: '#29b6f6', backgroundColor: 'rgba(41,182,246,0.55)', fill: true, stack: 'assets' },
          { label: 'Pensions', data: new Array(ageLabels.length).fill(0), borderColor: '#ab47bc', backgroundColor: 'rgba(171,71,188,0.55)', fill: true, stack: 'assets' },
          { label: 'Debts', data: new Array(ageLabels.length).fill(0), borderColor: '#ffa726', backgroundColor: 'rgba(255,167,38,0.55)', fill: true, stack: 'debts' },
          { label: 'Median Net Worth', data: new Array(ageLabels.length).fill(0), borderColor: '#ffffff', backgroundColor: 'transparent', color: '#ffffff', type: 'line', pointRadius: 0, borderWidth: 2, fill: false, order: 9999, z: 99 }
        ],
        step: 200000,
        axisLabels: {
          x: 'Age (Years)',
          y: 'Assets & Liabilities ($ - Households / Individuals)'
        }
      }, 'line');

      // Income Percentile by Gender - line chart similar to individual income by age (placeholder ratios)
      genderIncomeChartInstance = createChart('genderIncomeChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Women p10', data: new Array(ageLabels.length).fill(0), borderColor: 'rgba(0,0,0,0)', backgroundColor: 'rgba(171,71,188,0)', borderWidth: 0, fill: false, pointRadius: 0, pointHoverRadius: 0, tension: 0.3, order: 0, tooltip: { enabled: false }, inlineLabel: false, noGradient: true },
          { label: 'Women p90', data: new Array(ageLabels.length).fill(0), borderColor: 'rgba(0,0,0,0)', backgroundColor: 'rgba(171,71,188,0.10)', borderWidth: 0, fill: '-1', pointRadius: 0, pointHoverRadius: 0, tension: 0.3, order: 0, tooltip: { enabled: false }, inlineLabel: false, noGradient: true },
          { label: 'Men p10', data: new Array(ageLabels.length).fill(0), borderColor: 'rgba(0,0,0,0)', backgroundColor: 'rgba(41,182,246,0)', borderWidth: 0, fill: false, pointRadius: 0, pointHoverRadius: 0, tension: 0.3, order: 0, tooltip: { enabled: false }, inlineLabel: false, noGradient: true },
          { label: 'Men p90', data: new Array(ageLabels.length).fill(0), borderColor: 'rgba(0,0,0,0)', backgroundColor: 'rgba(41,182,246,0.10)', borderWidth: 0, fill: '-1', pointRadius: 0, pointHoverRadius: 0, tension: 0.3, order: 0, tooltip: { enabled: false }, inlineLabel: false, noGradient: true },
          { label: 'Women (Median)', data: new Array(ageLabels.length).fill(0), color: '#ab47bc', backgroundColor: 'transparent', fill: false, order: 10 },
          { label: 'Men (Median)', data: new Array(ageLabels.length).fill(0), color: '#1e88e5', backgroundColor: 'transparent', fill: false, order: 10 }
        ],
        step: 5000,
        axisLabels: {
          x: 'Age (Years)',
          y: 'Median Employment Income ($ - Individuals / Households)'
        }
      }, 'line');

      // Initialize distribution charts as bar (histogram-like)
      percentileNetWorthChartInstance = createChart('percentileNetWorthChart', {
        labels: [],
        datasets: [ { label: 'Net Worth Distribution', data: [], backgroundColor: '#66bb6a' } ],
        step: null,
        axisLabels: {
          x: 'Net Worth ($)',
          y: 'Share of Households (%)'
        }
      }, 'bar');
      percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: null };

      percentileIncomeChartInstance = createChart('percentileIncomeChart', {
        labels: [],
        datasets: [ { label: 'Income Distribution', data: [], backgroundColor: '#29bbf6' } ],
        step: null,
        axisLabels: {
          x: 'Employment Income ($)',
          y: 'Share of Tax Filers (%)'
        }
      }, 'bar');
      percentileIncomeChartInstance.options.plugins.userVLine = { xValue: null };
      // Hook up the dropdown to update the charts when a region is selected
      const select = document.getElementById('provinceSelect');
      select.addEventListener('change', function() {
        const region = this.value;
        updateCharts(region);
      });

      // Wrap the existing updateCharts() function to leverage ChartUpdater for
      // income and net worth charts.  This decorator ensures that after the
      // legacy logic has updated all charts, the new scalable update logic
      // overrides the income and net worth datasets and axes using the
      // DataMetric abstractions.  Without this wrapper, changes to
      // percentile logic would require editing multiple places.
      const legacyUpdateCharts = updateCharts;
      updateCharts = function(region) {
        legacyUpdateCharts(region);
        // Determine the selected unit (households or individuals).  Fallback to
        // households if the select element is not found.
        const unitEl = document.getElementById('unitSelect');
        const unit = unitEl ? unitEl.value : 'households';
        // Default percentiles to display: 10th, 25th, 75th, 90th.  We omit
        // the median (p50) here because ChartUpdater always includes it.
        const selectedPcts = ['p10','p25','p75','p90'];
        // Use globally stored user values if the user has entered data; otherwise
        // ChartUpdater will ignore the user overlay.
        chartUpdater.updateIncomeChart(region, unit, selectedPcts, userActive, userIncomeVal);
        chartUpdater.updateNetWorthChart(region, unit, selectedPcts, userActive, userNetWorthVal);
      };

      // Percentiles are always shown by default; no selector to watch.
      // Unit selector: switch between Households and Individuals across all charts
      const unitSelectEl = document.getElementById('unitSelect');
      if (unitSelectEl) {
        unitSelectEl.addEventListener('change', function() {
          const region = document.getElementById('provinceSelect').value;
          updateCharts(region);
        });
      }
      // Initialize with Canada selected
      updateCharts('Canada');

      // Add per-chart download buttons once charts are created
      addDownloadFooters();

      // Attach event listeners for user comparison and reset
      document.getElementById('compareBtn').addEventListener('click', function() {
        ensureChartsInitialized();
        plotUserData();
      });
      document.getElementById('resetBtn').addEventListener('click', function() {
        ensureChartsInitialized();
        resetUserData();
      });
      chartsInitialized = true;
    }

    function ensureChartsInitialized() { if (!chartsInitialized) initCharts(); }

    // Setup nav interactions and lazy initialization once DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      setupNav();
      const firstSection = document.getElementById('section-income-charts');
      if (firstSection && 'IntersectionObserver' in window) {
        const io = new IntersectionObserver((entries, obs) => {
          entries.forEach(e => { if (e.isIntersecting) { initCharts(); obs.disconnect(); } });
        }, { root: null, rootMargin: '300px', threshold: 0.02 });
        io.observe(firstSection);
      } else {
        // Fallback: initialize immediately
        initCharts();
      }
    });

    /* Navigation setup: smooth scrolling and active-section highlighting */
    function setupNav() {
      try {
        // Smooth scroll (CSS fallback is applied globally)
        const links = Array.from(document.querySelectorAll('#topNav .nav-link'));
        links.forEach(a => {
          a.addEventListener('click', function(e){
            e.preventDefault();
            const id = this.getAttribute('href').replace('#','');
            const el = document.getElementById(id);
            if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
          });
        });

        // Active link highlighting via IntersectionObserver
        if ('IntersectionObserver' in window) {
          const sections = links.map(l => document.getElementById(l.getAttribute('href').replace('#',''))).filter(Boolean);
          const io = new IntersectionObserver((entries) => {
            entries.forEach(ent => {
              const id = ent.target.id;
              const link = document.querySelector(`#topNav .nav-link[href='#${id}']`);
              if (link) link.classList.toggle('active', ent.isIntersecting);
            });
          }, { root: null, threshold: 0.3 });
          sections.forEach(s => io.observe(s));
        }
      } catch(e){ console.error('Nav setup failed', e); }
    }

    // Flags and storage for user input comparison
    let userActive = false;
    let userAgeVal, userIncomeVal, userNetWorthVal;

    /**
     * Handle plotting the user's input across all charts. Validates input
     * values and stores them in global variables. If validation fails,
     * notifies the user.
     */
    function plotUserData() {
      const warnEl = document.getElementById('inputWarning');
      const setWarn = (msg='') => { if (warnEl) warnEl.textContent = msg; };
      setWarn('');
      const ageInputRaw = document.getElementById('userAge').value;
      const ageInput = parseInt(ageInputRaw, 10);
      const incomeInput = parseFloat(document.getElementById('userIncome').value);
      const netWorthInput = parseFloat(document.getElementById('userNetWorth').value);
      if (!ageInput || ageInput < 18 || ageInput > 100 || isNaN(incomeInput) || isNaN(netWorthInput)) {
        alert('Please enter a valid age between 18 and 100, and numeric values for income and net worth.');
        return;
      }
      if (incomeInput > 1000000) {
        alert('Please enter an income of $1,000,000 or less.');
        return;
      }
      if (netWorthInput > 100000000) {
        alert('Please enter a net worth of $100,000,000 or less.');
        return;
      }
      let warnings = [];
      const clampedAge = Math.min(ageInput, 80);
      if (ageInput > 80) { warnings.push('Age capped to 80 (data coverage limit).'); if (document.getElementById('userAge')) document.getElementById('userAge').value = clampedAge; }
      if (netWorthInput < 0) warnings.push('Net worth entered as debt; percentile floors applied.');
      setWarn(warnings.join(' '));

      userActive = true;
      userAgeVal = clampedAge;
      userIncomeVal = incomeInput;
      userNetWorthVal = netWorthInput;
      // After storing the user values, rescale all charts to include the new marker and redraw
      const region = document.getElementById('provinceSelect').value;
      updateCharts(region);
      // Update insight panel text after charts are refreshed
      try{ showYouVsEveryone(); }catch(e){}
    }

    /**
     * Add or update the user's markers on all charts using the stored values.
     */
    function addUserMarkers() {
      if (!userActive) return;
      const index = Math.max(0, Math.min(userAgeVal - 18, ageLabels.length - 1));
      // Add marker to each line chart
      addUserMarkerToChart(incomeChartInstance, userIncomeVal, index, 'You');
      // Place a marker on the income composition chart representing the user's total income
      addUserMarkerToChart(compositionChartInstance, userIncomeVal, index, 'You');
      addUserMarkerToChart(netWorthChartInstance, userNetWorthVal, index, 'You');
      addUserLineToBarChart(provinceChartInstance, userNetWorthVal, 'You');
      // Add a horizontal line on the provincial income chart for the user's income
      addUserLineToBarChart(provinceIncomeChartInstance, userIncomeVal, 'You');
      // Add a red "You" point to the scatter chart (income vs net worth)
      addUserPointToScatter(scatterChartInstance, userIncomeVal, userNetWorthVal, 'You');
      // Update vertical dashed user percentile lines on percentile charts
      try {
        const region = document.getElementById('provinceSelect').value;
        // Rebuild percentile curves for current region
        const provinceIndex = baseProvinceLabels.indexOf(region);
        const unitEl = document.getElementById('unitSelect');
        const unit = unitEl ? unitEl.value : 'households';
        const equivalenceScale = Math.sqrt(DEFAULT_HOUSEHOLD_SIZE);
        const nationalMedianNetWorthHousehold = 652286;
        const nationalMedianIncomeIndividual = baseIncome[22];
        const nationalMedianNetWorth = (unit === 'households') ? nationalMedianNetWorthHousehold : Math.round(nationalMedianNetWorthHousehold / equivalenceScale);
        const nationalMedianIncome = (unit === 'households') ? Math.round(nationalMedianIncomeIndividual * equivalenceScale) : nationalMedianIncomeIndividual;
        // Percentiles using the same thresholds as tiles for consistency
        const ageIdx = Math.max(0, Math.min(userAgeVal - 18, ageLabels.length - 1));
        const incPcts = getScaledIncomePercentiles(ageIdx, region, unit);
        const netPcts = getScaledNetWorthPercentiles(ageIdx, region, unit);
        const incThresh = [
          {p:10, v: incPcts.p10},
          {p:25, v: incPcts.p25},
          {p:50, v: incPcts.p50},
          {p:75, v: incPcts.p75},
          {p:90, v: incPcts.p90},
          {p:99, v: baseTotalIncomeP99[ageIdx] * (incomeRatios[region] || 1) * (unit==='households'? EQUIVALENCE_SCALE:1)}
        ];
        const netThresh = [
          {p:10, v: netPcts.p10},
          {p:25, v: netPcts.p25},
          {p:50, v: netPcts.p50},
          {p:75, v: netPcts.p75},
          {p:90, v: netPcts.p90},
          {p:99, v: (unit==='households' ? baseNetWorthP99[ageIdx] : baseIndNetWorthP99[ageIdx]) * (netWorthRatios[region] || 1)}
        ];
        const incPct = clampPercentile(computePercentileFromThresholds(userIncomeVal, incThresh));
        const netPct = clampPercentile(computePercentileFromThresholds(userNetWorthVal, netThresh));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: userNetWorthVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(netPct)} percentile` };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: userIncomeVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(incPct)} percentile` };
        percentileNetWorthChartInstance.update();
        percentileIncomeChartInstance.update();
      } catch (e) { /* no-op */ }
    }

    /**
     * Add or update a single-point marker on a line chart. The marker is
     * represented as a dataset with mostly null values except for the
     * specified index where the user value is placed.
     * @param {Chart} chart The Chart.js instance
     * @param {number} value The y-value to plot
     * @param {number} index The index corresponding to the user's age
     * @param {string} label The label used to identify the user's dataset
     */
    function addUserMarkerToChart(chart, value, index, label) {
      if (!chart) return;
      const length = chart.data.labels.length;
      const dataArray = new Array(length).fill(null);
      dataArray[index] = value;
      const existingIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const markerDataset = {
        label: label,
        data: dataArray,
        borderColor: 'rgba(244,67,54,1)',
        backgroundColor: 'rgba(244,67,54,1)',
        pointStyle: 'circle',
        pointRadius: 5,
        pointHoverRadius: 6,
        fill: false,
        showLine: false,
        borderWidth: 0,
        order: 9999,
        clip: false
      };
      if (existingIndex >= 0) {
        chart.data.datasets[existingIndex].data = dataArray;
      } else {
        chart.data.datasets.push(markerDataset);
      }
      // After placing the user marker, dynamically expand the y-axis
      // so that the user value is always visible. We recompute the axis
      // bounds based on all non-user datasets and the user value. This
      // prevents the chart from being clipped when the comparison value
      // exceeds the existing range.
      const step = chart.__step || null;
      let allVals = [];
      chart.data.datasets.forEach(ds => {
        if (ds.label !== label) {
          ds.data.forEach(v => {
            if (typeof v === 'number' && !isNaN(v)) allVals.push(v);
          });
        }
      });
      // Include the user-provided value in the axis computation
      allVals.push(value);
      // Compute new axis bounds
      let axis = computeAxis(allVals, step);
      // For income charts (employment and total), clamp minimum at zero
      // Clamp the y-axis minimum at zero for income charts (employment and composition)
      if (chart === incomeChartInstance || chart === compositionChartInstance) {
        axis.min = 0;
      }
      chart.options.scales.y.min = axis.min;
      chart.options.scales.y.max = axis.max;
      chart.update();
    }

    /**
     * Add or update a horizontal dashed line on the bar chart representing
     * the user's net worth across all provinces.
     * @param {Chart} chart The bar chart instance
     * @param {number} value The y-value for the horizontal line
     * @param {string} label The label used to identify the user's dataset
     */
    function addUserLineToBarChart(chart, value, label) {
      if (!chart) return;
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return;
      const dataArray = new Array(chart.data.labels.length).fill(numeric);
      const existingIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const lineDataset = {
        label: label,
        data: dataArray,
        type: 'line',
        borderColor: 'rgba(244,67,54,1)',
        borderDash: [6,3],
        borderWidth: 3,
        fill: false,
        pointRadius: 0,
        // Ensure the user/reference line is drawn in front of bars and percentile lines
        order: 100,
        z: 10,
        // Avoid being clipped beneath chart area edges
        clip: false
      };
      if (existingIndex >= 0) {
        chart.data.datasets[existingIndex].data = dataArray;
      } else {
        chart.data.datasets.push(lineDataset);
      }
      chart.update();
    }

    /**
     * Reset and remove all user markers from every chart.
     */
    function resetUserData() {
      userActive = false;
      userAgeVal = null;
      userIncomeVal = null;
      userNetWorthVal = null;
      // Reset input fields
      const ageEl = document.getElementById('userAge');
      const incEl = document.getElementById('userIncome');
      const nwEl = document.getElementById('userNetWorth');
      if (ageEl) ageEl.value = '';
      if (incEl) incEl.value = '';
      if (nwEl) nwEl.value = '';
      // Reset dropdowns to defaults
      const provEl = document.getElementById('provinceSelect');
      const unitEl = document.getElementById('unitSelect');
      if (provEl) provEl.value = 'Canada';
      if (unitEl) unitEl.value = 'households';
      const warnEl = document.getElementById('inputWarning');
      if (warnEl) warnEl.textContent = '';

      // Remove user overlays from charts
      removeUserDataset(incomeChartInstance, 'You');
      removeUserDataset(compositionChartInstance, 'You');
      removeUserDataset(netWorthChartInstance, 'You');
      removeUserDataset(provinceChartInstance, 'You');
      removeUserDataset(provinceIncomeChartInstance, 'You');
      removeUserDataset(scatterChartInstance, 'You');
      // Clear percentile chart vertical lines
      if (percentileNetWorthChartInstance?.options?.plugins) {
        percentileNetWorthChartInstance.options.plugins.userVLine = { index: null, xValue: null };
        percentileNetWorthChartInstance.update();
      }
      if (percentileIncomeChartInstance?.options?.plugins) {
        percentileIncomeChartInstance.options.plugins.userVLine = { index: null, xValue: null };
        percentileIncomeChartInstance.update();
      }
      // Rescale charts back to default ranges after removing user data
      updateCharts('Canada');
      // Hide insight tiles and projection section if present
      try{ showYouVsEveryone(); }catch(e){}
      try{
        const tiles = document.getElementById('resultTiles'); if (tiles) tiles.style.display = 'none';
        const projSection = document.getElementById('projectionSection'); if (projSection) projSection.style.display = 'none';
        const projCard = document.getElementById('projCard'); if (projCard) projCard.querySelector('.value').textContent = '-';
        const median65Card = document.getElementById('median65Card'); if (median65Card) median65Card.querySelector('.value').textContent = '-';
        const requiredRateCard = document.getElementById('requiredRateCard'); if (requiredRateCard) { requiredRateCard.querySelector('.value').textContent = '-'; requiredRateCard.querySelector('.label').textContent = 'Required savings rate'; }
        ['incomePercentileValue','netWorthPercentileValue','avgIncomeValue','medianIncomeValue','avgNetWorthValue','medianNetWorthValue'].forEach(id=>{
          const el = document.getElementById(id); if (el) el.textContent = '—';
        });
      }catch(e){}
    }

    /**
     * Helper to remove a dataset with the given label from a chart.
     * @param {Chart} chart The chart instance
     * @param {string} label The label identifying the dataset to remove
     */
    function removeUserDataset(chart, label) {
      if (!chart) return;
      const index = chart.data.datasets.findIndex(ds => ds.label === label);
      if (index >= 0) {
        chart.data.datasets.splice(index, 1);
        chart.update();
      }
    }

    /* Helper: return ordinal string (e.g., 1st, 2nd, 3rd, 4th) */
    function ordinal(n) {
      const nn = Math.round(n);
      const s = ['th','st','nd','rd'];
      const v = nn % 100;
      return nn + (s[(v-20)%10] || s[v] || s[0]);
    }

    /* Interpolate percentile between known percentile thresholds */
    function computePercentileFromThresholds(value, thresholds) {
      if (!thresholds || thresholds.length === 0) return 50;
      if (value <= thresholds[0].v) return thresholds[0].p;
      for (let i = 1; i < thresholds.length; i++) {
        const lo = thresholds[i-1];
        const hi = thresholds[i];
        if (value <= hi.v) {
          const frac = (value - lo.v) / Math.max(1, (hi.v - lo.v));
          return lo.p + frac * (hi.p - lo.p);
        }
      }
      const last = thresholds[thresholds.length-1];
      const prev = thresholds[thresholds.length-2] || last;
      const extra = (value - last.v) / Math.max(1, (last.v - prev.v));
      return Math.min(99, last.p + extra * (99 - last.p));
    }

    function clampPercentile(p) {
      const num = Number(p);
      if (!Number.isFinite(num)) return 0.5;
      return Math.max(0.5, Math.min(99, num));
    }

    /* Convert percentile anchors into an approximate mean using a log-normal fit. */
    function computeMeanFromPercentiles(pcts) {
      if (!pcts) return null;
      const z90 = 1.2815515655446004;
      const { p10, p50, p90 } = pcts;
      if (p10 > 0 && p50 > 0 && p90 > 0) {
        const sigma = (Math.log(p90) - Math.log(p10)) / (2 * z90);
        const mu = Math.log(p50);
        return Math.exp(mu + 0.5 * sigma * sigma);
      }
      const vals = [p10, p50, p90, pcts.p25, pcts.p75].filter(v => typeof v === 'number' && isFinite(v));
      if (!vals.length) return null;
      return vals.reduce((a, b) => a + b, 0) / vals.length;
    }

    /* Scale income percentile anchors for the selected region/unit. */
    function getScaledIncomePercentiles(ageIdx, region, unit) {
      const ratio = incomeRatios[region] || 1;
      const mult = (unit === 'households') ? EQUIVALENCE_SCALE : 1;
      return {
        p10: baseTotalIncomeP10[ageIdx] * ratio * mult,
        p25: baseTotalIncomeP25[ageIdx] * ratio * mult,
        p50: baseTotalIncome[ageIdx] * ratio * mult,
        p75: baseTotalIncomeP75[ageIdx] * ratio * mult,
        p90: baseTotalIncomeP90[ageIdx] * ratio * mult
      };
    }

    /* Scale net worth percentile anchors for the selected region/unit. */
    function getScaledNetWorthPercentiles(ageIdx, region, unit) {
      const ratio = netWorthRatios[region] || 1;
      const base = (unit === 'households') ? {
        p10: baseNetWorthP10, p25: baseNetWorthP25, p50: baseNetWorth, p75: baseNetWorthP75, p90: baseNetWorthP90
      } : {
        p10: baseIndNetWorthP10, p25: baseIndNetWorthP25, p50: baseIndNetWorth, p75: baseIndNetWorthP75, p90: baseIndNetWorthP90
      };
      return {
        p10: base.p10[ageIdx] * ratio,
        p25: base.p25[ageIdx] * ratio,
        p50: base.p50[ageIdx] * ratio,
        p75: base.p75[ageIdx] * ratio,
        p90: base.p90[ageIdx] * ratio
      };
    }

    function getMedianIncome(age, region, unit) {
      const idx = Math.max(0, Math.min(age - 18, ageLabels.length - 1));
      return getScaledIncomePercentiles(idx, region, unit).p50;
    }

    function getAverageIncome(age, region, unit) {
      const idx = Math.max(0, Math.min(age - 18, ageLabels.length - 1));
      return computeMeanFromPercentiles(getScaledIncomePercentiles(idx, region, unit));
    }

    function getMedianNetWorth(age, region, unit) {
      const idx = Math.max(0, Math.min(age - 18, ageLabels.length - 1));
      return getScaledNetWorthPercentiles(idx, region, unit).p50;
    }

    function getAverageNetWorth(age, region, unit) {
      const idx = Math.max(0, Math.min(age - 18, ageLabels.length - 1));
      return computeMeanFromPercentiles(getScaledNetWorthPercentiles(idx, region, unit));
    }

    function getRecommendedSavingsRate(age, income) {
      if (!income || income <= 0) return null;
      let rate = 15;
      if (income > 150000) rate += 3;
      if (income < 60000) rate -= 3;
      if (age < 30) rate -= 2;
      if (age > 45) rate += 2;
      rate = Math.max(5, Math.min(35, rate));
      const annualTarget = income * rate / 100;
      return { rate, annualTarget };
    }

    function getDebtToIncomeBenchmark(income) {
      if (!income || income <= 0) return null;
      const ratio = 0.36; // placeholder: typical total debt-to-income benchmark
      return { ratio, annualLimit: income * ratio };
    }

    function setTile(tileId, valueText, subtitleText) {
      const tile = document.getElementById(tileId);
      if (!tile) return;
      const valueEl = tile.querySelector('.tile-value');
      const subEl = tile.querySelector('.tile-sub');
      if (valueEl) valueEl.textContent = (valueText !== undefined && valueText !== null) ? valueText : '-';
      if (subEl && subtitleText !== undefined) subEl.textContent = subtitleText;
    }

    /* Show the You vs Everyone insight text based on the stored user values */
    function showYouVsEveryone() {
      const incTile = document.getElementById('incomePctTile');
      const netTile = document.getElementById('netPctTile');
      const tilesWrap = document.getElementById('resultTiles');
      if (!incTile || !netTile || !tilesWrap) return;
      if (!userActive) {
        tilesWrap.style.display = 'none';
        setTile('incomePctTile', '-');
        setTile('netPctTile', '-');
        ['avgIncomeTile','medianIncomeTile','avgNetWorthTile','medianNetWorthTile'].forEach(id => setTile(id, '-', 'for - - age -'));
        return;
      }
      const age = Math.max(18, Math.min(80, userAgeVal));
      const idx = age - 18;
      const region = document.getElementById('provinceSelect').value || 'Canada';
      const unit = (document.getElementById('unitSelect') || {value:'households'}).value || 'households';
      const incPcts = getScaledIncomePercentiles(idx, region, unit);
      const netPcts = getScaledNetWorthPercentiles(idx, region, unit);
      const incThresh = [
        {p:10, v: incPcts.p10},
        {p:25, v: incPcts.p25},
        {p:50, v: incPcts.p50},
        {p:75, v: incPcts.p75},
        {p:90, v: incPcts.p90},
        {p:99, v: baseTotalIncomeP99[idx] * (incomeRatios[region] || 1) * (unit==='households'? EQUIVALENCE_SCALE:1)}
      ];
      const netThresh = [
        {p:10, v: netPcts.p10},
        {p:25, v: netPcts.p25},
        {p:50, v: netPcts.p50},
        {p:75, v: netPcts.p75},
        {p:90, v: netPcts.p90},
        {p:99, v: (unit==='households' ? baseNetWorthP99[idx] : baseIndNetWorthP99[idx]) * (netWorthRatios[region] || 1)}
      ];
      const incomePct = clampPercentile(computePercentileFromThresholds(userIncomeVal, incThresh));
      const netPct = clampPercentile(computePercentileFromThresholds(userNetWorthVal, netThresh));
      const unitLabel = (unit==='households') ? `${region} households` : `${region} individuals`;
      const subtitle = `for ${region} - age ${age}`;
      tilesWrap.style.display = 'flex';
      setTile('incomePctTile', ordinal(incomePct), `among ${unitLabel} - age ${age}`);
      setTile('netPctTile', ordinal(netPct), `among ${unitLabel} - age ${age}`);
      setTile('avgIncomeTile', incPcts ? formatCurrency(getAverageIncome(age, region, unit)) : '-', subtitle);
      setTile('medianIncomeTile', incPcts ? formatCurrency(incPcts.p50) : '-', subtitle);
      setTile('avgNetWorthTile', netPcts ? formatCurrency(getAverageNetWorth(age, region, unit)) : '-', subtitle);
      setTile('medianNetWorthTile', netPcts ? formatCurrency(netPcts.p50) : '-', subtitle);
      // Savings rate and DTI tiles removed
    }
    // Override with compact footer layout (PNG + Sources inline)
    function addDownloadFooters() {
      const canvases = document.querySelectorAll('.chart-card canvas');
      canvases.forEach(canvas => {
        const card = canvas.closest('.chart-card');
        if (!card) return;
        const chartContainer = card.querySelector('.chart-container');
        let footer = card.querySelector('.chart-footer-row');
        if (!footer) {
          footer = document.createElement('div');
          footer.className = 'chart-footer-row';
          if (chartContainer) {
            chartContainer.insertAdjacentElement('afterend', footer);
          } else {
            card.appendChild(footer);
          }
        }
        // Remove PNG download controls (user requested).
        footer.querySelectorAll('.download-btn, .chart-footer-actions').forEach(el => el.remove());

        let sourcesRow = footer.querySelector('.chart-footer-sources');
        if (!sourcesRow) {
          sourcesRow = document.createElement('div');
          sourcesRow.className = 'chart-footer-sources';
          footer.appendChild(sourcesRow);
        }
        const sourceBox = card.querySelector('.source-box');
        if (sourceBox && sourceBox.parentElement !== sourcesRow) {
          sourcesRow.appendChild(sourceBox);
        }
      });
    }

    function downloadChart(canvasId) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) { alert('Chart not found'); return; }
      let chart = null;
      try { chart = Chart.getChart(canvas); } catch(e) { chart = null; }
      if (!chart) {
        const altName = canvasId + 'Instance';
        chart = window[altName] || null;
      }
      if (!chart) { alert('Chart instance not available for download.'); return; }

      const card = canvas.closest('.chart-card');
      const titleEl = card ? card.querySelector('h3') : null;
      const titleText = titleEl ? titleEl.textContent.trim() : 'Chart';

      const dpr = window.devicePixelRatio || 1;
      const sourceWidth = canvas.width;
      const sourceHeight = canvas.height;
      const padding = 16 * dpr;
      const titleHeight = 28 * dpr;
      const outCanvas = document.createElement('canvas');
      outCanvas.width = sourceWidth;
      outCanvas.height = sourceHeight + titleHeight + padding;
      const ctx = outCanvas.getContext('2d');
      ctx.fillStyle = '#13294b';
      ctx.fillRect(0, 0, outCanvas.width, outCanvas.height);
      ctx.fillStyle = '#bfe0ff';
      ctx.font = `${16 * dpr}px 'Segoe UI', 'Helvetica Neue', Arial, sans-serif`;
      ctx.textBaseline = 'top';
      ctx.fillText(titleText, padding, padding);
      ctx.drawImage(canvas, 0, titleHeight + padding / 2);

      const url = outCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = `${canvasId}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    /* ------ Savings projection tools ------ */
    function formatCurrency(n) {
      return '$' + Math.round(n).toLocaleString();
    }

    function projectNetWorthToAge(savingsRatePct, targetAge, opts = {}) {
      // savingsRatePct is percent (0-100)
      const r = opts.returnRate !== undefined ? opts.returnRate : 0.03; // annual real return
      if (!userActive) { return { error: 'Enter your age, income and net worth and click Compare first.' }; }
      const startAge = Math.max(18, Math.min(80, userAgeVal));
      const idxStart = startAge - 18;
      const idxTarget = Math.max(0, Math.min(ageLabels.length-1, targetAge - 18));
      if (targetAge <= startAge) {
        return { projected: userNetWorthVal, years: 0 };
      }
      const unit = (document.getElementById('unitSelect') || {value:'households'}).value || 'households';
      const region = document.getElementById('provinceSelect').value || 'Canada';
      const incomeRatio = (incomeRatios[region] || 1);
      const householdMult = (unit==='households') ? EQUIVALENCE_SCALE : 1;
      // Map user's income growth to baseTotalIncome growth curve
      const baseAtStart = baseTotalIncome[idxStart] * incomeRatio * householdMult;
      let balance = userNetWorthVal;
      for (let a = startAge; a < targetAge; a++) {
        const idx = Math.max(0, Math.min(ageLabels.length-1, a - 18));
        const idxNext = Math.max(0, Math.min(ageLabels.length-1, a+1 - 18));
        // Projected income next year based on growth factor from baseTotalIncome
        const growthFactor = baseTotalIncome[idxNext] / Math.max(1, baseTotalIncome[idx]);
        // Estimate this year's income as scaled from user's current income
        // Use ratio of baseTotalIncome at this age to base at start
        const incomeThisYear = userIncomeVal * (baseTotalIncome[idx] / baseTotalIncome[idxStart]) * incomeRatio * householdMult;
        const saving = incomeThisYear * (savingsRatePct/100);
        // Apply return then add saving (assume saving at year end)
        balance = balance * (1 + r) + saving;
      }
      return { projected: balance, years: targetAge - startAge };
    }

    function requiredSavingsRateForPercentile(targetPct, targetAge, opts = {}) {
      if (!userActive) { return { error: 'Enter your age, income and net worth and click Compare first.' }; }
      const maxRate = 100; // percent
      const tol = 0.1; // 0.1% precision
      let lo = 0, hi = maxRate, mid = 0;
      const desired = targetPct;
      // Determine goal net worth at target age for 90th percentile using base arrays scaled
      const ageIdx = Math.max(0, Math.min(ageLabels.length-1, targetAge - 18));
      const unit = (document.getElementById('unitSelect') || {value:'households'}).value || 'households';
      const region = document.getElementById('provinceSelect').value || 'Canada';
      const netBase = unit==='households' ? baseNetWorthP90 : baseIndNetWorthP90;
      // Project the percentile baseline forward to the year the user reaches targetAge.
      // base arrays are 2025 values; yearsToTarget is how many years from now until the user
      // reaches the target age: targetAge - userAgeVal. Use 3.5% real growth per year.
      const yearsToTarget = Math.max(0, targetAge - userAgeVal);
      const growth = opts.percentileGrowth !== undefined ? opts.percentileGrowth : NET_WORTH_GROWTH_NOMINAL;
      const netGoal = netBase[ageIdx] * (netWorthRatios[region] || 1) * Math.pow(1 + growth, yearsToTarget);
      // Quick check: if current net worth already >= goal
      if (userNetWorthVal >= netGoal) return { rate: 0, reachable: true, goal: netGoal };
      // Binary search for required savings rate
      let resultRate = null;
      for (let i=0;i<40;i++) {
        mid = (lo + hi) / 2;
        const proj = projectNetWorthToAge(mid, targetAge, opts);
        if (proj.error) return { error: proj.error };
        const val = proj.projected;
        if (Math.abs(val - netGoal) < Math.max(1000, 0.01 * netGoal)) { resultRate = mid; break; }
        if (val < netGoal) lo = mid; else hi = mid;
        resultRate = mid;
      }
      const reachable = resultRate <= maxRate;
      return { rate: Math.min(resultRate, maxRate), reachable, goal: netGoal };
    }

    /**
     * Debug and testing utilities exposed globally for vibe coding.
     * Access these in browser console:
     *   window.DEBUG.metrics.get('employmentIncome')
     *   window.DEBUG.testRatio('Alberta')
     *   validateDataIntegrity() 
     *   timeChartUpdate('Canada')
     */
    window.DEBUG = {
      metrics: metrics,
      ratios: { income: incomeRatios, netWorth: netWorthRatios },
      getMetric: (key) => {
        try { return metrics.get(key); } 
        catch (e) { console.error(`Metric not found: ${key}`); return null; }
      },
      testRatio: (region) => {
        const incRatio = incomeRatios[region];
        const nwRatio = netWorthRatios[region];
        console.log(`Region: ${region}\n  Income ratio: ${incRatio}\n  Net worth ratio: ${nwRatio}`);
        return { incRatio, nwRatio };
      },
      testMetric: (key, region = 'Canada') => {
        const metric = this.getMetric(key);
        if (!metric) return null;
        const ratio = key.includes('NetWorth') ? (netWorthRatios[region] || 1) : (incomeRatios[region] || 1);
        const data = metric.getAllScaledData(ratio, ['p10', 'p25', 'p75', 'p90']);
        console.log(`${key} @ ${region}:`, data);
        return data;
      },
      getPercentileColors: () => percentileColors,
      charts: {
        get income() { return incomeChartInstance; },
        get netWorth() { return netWorthChartInstance; },
        get province() { return provinceChartInstance; },
        get scatter() { return scatterChartInstance; },
        get composition() { return compositionChartInstance; },
        get gender() { return genderChartInstance; },
        get provinceIncome() { return provinceIncomeChartInstance; }
      },
      benchmark: (region = 'Canada', iterations = 1) => {
        const times = [];
        for (let i = 0; i < iterations; i++) times.push(timeChartUpdate(region));
        const avg = times.reduce((a, b) => a + b) / times.length;
        console.log(`Benchmark: ${iterations} updates @ ${region}\n  Min: ${Math.min(...times).toFixed(1)}ms\n  Max: ${Math.max(...times).toFixed(1)}ms\n  Avg: ${avg.toFixed(1)}ms`);
        return { times, avg };
      }
    };
    
    // Enable debug mode via ?debug=1 in URL
    const debugMode = new URLSearchParams(window.location.search).get('debug') === '1';
    if (debugMode) {
      console.log('%c?? DEBUG MODE ENABLED', 'color: #00bfa5; font-size: 14px; font-weight: bold;');
      console.log('%cAccess utilities via window.DEBUG or call:', 'color: #b0c5e8;');
      console.log('  validateDataIntegrity()\n  timeChartUpdate("Canada")\n  window.DEBUG.testRatio("Ontario")\n  window.DEBUG.testMetric("employmentIncome", "Alberta")\n  window.DEBUG.benchmark("Canada", 5)');
      console.log('%cValidating data...', 'color: #ffeb3b;');
      validateDataIntegrity();
    }

    // Wire projection buttons
    document.addEventListener('click', function(e){
      if (e.target && e.target.id === 'projectBtn') {
        // Combined action: project to 65 using the supplied savings rate,
        // and compute the required savings rate to reach the 90th percentile
        // by the chosen target age. Results are merged into a single output.
        const sr = parseFloat(document.getElementById('savingsRate').value);
        const tgtAge = parseInt(document.getElementById('targetAge').value,10);
        if (isNaN(sr) || sr < 0 || sr > 200) { alert('Enter a valid savings rate (0-200%).'); return; }
        if (isNaN(tgtAge) || tgtAge < 18 || tgtAge > 100) { alert('Enter a valid target age (18-100).'); return; }
        // Run projection to age 65 (user's projected net worth at that age)
        const proj = projectNetWorthToAge(sr, 65);
        if (proj.error) { alert(proj.error); return; }
        // Compute the calendar year for that projection and the base-year-adjusted value
        const yearsToProj65 = Math.max(0, 65 - userAgeVal);
        const yearAt65 = BASE_YEAR + yearsToProj65;
        const pctGrowth = NET_WORTH_GROWTH_NOMINAL; // nominal net-worth growth for forward projection/discounting
        const projAdjBase = proj.projected / Math.pow(1 + pctGrowth, yearsToProj65);
        // Compare to median net worth at 65 for region/unit
        // Compare to projected median net worth at 65 for region/unit
        const region = document.getElementById('provinceSelect').value || 'Canada';
        const unit = (document.getElementById('unitSelect') || {value:'households'}).value || 'households';
        const ageIdx65 = 65 - 18;
        // Project the base-year median at age 65 forward by the number of years until the user reaches 65
        const yearsTo65 = yearsToProj65;
        const medianNet65 = ((unit==='households') ? baseNetWorth[ageIdx65] : baseIndNetWorth[ageIdx65]) * (netWorthRatios[region] || 1) * Math.pow(1 + pctGrowth, yearsTo65);
        // Populate projection cards
        const projCard = document.getElementById('projCard');
        const median65Card = document.getElementById('median65Card');
        const requiredRateCard = document.getElementById('requiredRateCard');
        if (projCard) projCard.querySelector('.value').textContent = formatCurrency(proj.projected) + ` (${yearAt65})`;
        if (median65Card) median65Card.querySelector('.value').textContent = formatCurrency(medianNet65) + ` (${yearAt65})`;
        // Run required savings rate calculation for 90th percentile by target age
        const req = requiredSavingsRateForPercentile(90, tgtAge);
        if (req.error) { alert(req.error); return; }
        // Build combined output
        let html = '';
        // Also show the target-year and base-year-adjusted value for the 90th percentile goal
        const yearsToReq = Math.max(0, tgtAge - userAgeVal);
        const yearAtReq = BASE_YEAR + yearsToReq;
        const reqAdjBase = req.goal / Math.pow(1 + pctGrowth, yearsToReq);
        // Update the required-rate card
        if (requiredRateCard) {
          if (!req.reachable) {
            requiredRateCard.querySelector('.value').textContent = 'Unrealistic';
            requiredRateCard.querySelector('.label').textContent = `Goal (${yearAtReq}) ${formatCurrency(req.goal)}`;
          } else {
            requiredRateCard.querySelector('.value').textContent = req.rate.toFixed(1) + '%';
            requiredRateCard.querySelector('.label').textContent = `Goal (${yearAtReq}) ${formatCurrency(req.goal)}`;
          }
        }
        // Show projection section if hidden
        const projSection = document.getElementById('projectionSection');
        if (projSection) projSection.style.display = 'block';
      }
    });

    /**
     * Add or update the user's point on the scatter chart (income vs net worth).
     * Ensures the axes include the user's point and draws it prominently in red.
     * @param {Chart} chart The scatter chart instance
     * @param {number} incomeX The user's income (x value)
     * @param {number} netWorthY The user's net worth (y value)
     * @param {string} label Dataset label (e.g., 'You')
     */
    function addUserPointToScatter(chart, incomeX, netWorthY, label) {
      if (!chart) return;
      const userDsIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const userDs = {
        label: label,
        type: 'scatter',
        data: [ { x: incomeX, y: netWorthY } ],
        borderColor: 'rgba(244,67,54,1)',
        backgroundColor: 'rgba(244,67,54,1)',
        pointStyle: 'circle',
        pointBackgroundColor: 'rgba(244,67,54,1)',
        pointBorderColor: 'rgba(244,67,54,1)',
        pointRadius: 6,
        pointHoverRadius: 7,
        showLine: false,
        order: 9999,
        clip: false
      };
      if (userDsIndex >= 0) {
        chart.data.datasets[userDsIndex] = Object.assign(chart.data.datasets[userDsIndex], userDs);
      } else {
        chart.data.datasets.push(userDs);
      }

      // Recompute axes to include the user's point alongside the base series
      const baseData = (chart.data.datasets[0] && Array.isArray(chart.data.datasets[0].data)) ? chart.data.datasets[0].data : [];
      const xVals = baseData.map(p => p.x);
      const yVals = baseData.map(p => p.y);
      xVals.push(incomeX);
      yVals.push(netWorthY);
      const xAxis = computeAxis(xVals, 5000);
      const yAxis = computeAxis(yVals, 200000);
      if (!chart.options.scales) chart.options.scales = {};
      if (!chart.options.scales.x) chart.options.scales.x = { type: 'linear', position: 'bottom' };
      if (!chart.options.scales.y) chart.options.scales.y = {};
      chart.options.scales.x.min = Math.max(0, xAxis.min);
      chart.options.scales.x.max = xAxis.max;
      chart.options.scales.y.min = yAxis.min;
      chart.options.scales.y.max = yAxis.max;
      chart.update();
    }

    /* Capture a snapshot of the small summary tiles + projection area and download as PNG */
    async function captureSnapshot() {
      try {
        ensureChartsInitialized();
        const tiles = document.getElementById('resultTiles');
        const proj = document.getElementById('projectionSection');
        // Build a temporary container and clone the nodes we want to capture
        const container = document.createElement('div');
        container.style.background = getComputedStyle(document.body).background || '#0a1931';
        container.style.color = getComputedStyle(document.body).color || '#e0e6ed';
        container.style.padding = '18px';
        container.style.width = '1200px';
        container.style.boxSizing = 'border-box';
        // Add a small header
        const h = document.createElement('div');
        h.style.fontWeight = '700';
        h.style.marginBottom = '8px';
        h.textContent = 'Your Snapshot - Summary';
        container.appendChild(h);
        if (tiles) container.appendChild(tiles.cloneNode(true));
        if (proj && proj.style.display !== 'none') container.appendChild(proj.cloneNode(true));
        // Place off-screen so it doesn't flash
        container.style.position = 'fixed';
        container.style.left = '-9999px';
        container.style.top = '0';
        document.body.appendChild(container);
        // Use html2canvas to capture
        const canvas = await html2canvas(container, { scale: 2, useCORS: true, backgroundColor: null });
        const url = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = url;
        a.download = 'my_snapshot.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
        // Clean up
        container.remove();
      } catch (err) {
        console.error('Snapshot failed', err);
        alert('Snapshot failed. Please try again or use the chart download buttons.');
      }
    }

    function applyBaseYearTextSwap(fromYear, toYear) {
      // Replace visible text and accessibility labels without touching scripts/styles
      const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
      while (walker.nextNode()) {
        const node = walker.currentNode;
        const parent = node.parentElement;
        if (!parent) continue;
        const tag = parent.tagName;
        if (tag === 'SCRIPT' || tag === 'STYLE') continue;
        if (node.nodeValue && node.nodeValue.includes(fromYear)) {
          node.nodeValue = node.nodeValue.replaceAll(fromYear, toYear);
        }
      }
      ['aria-label', 'title'].forEach(attr => {
        document.querySelectorAll(`[${attr}]`).forEach(el => {
          const val = el.getAttribute(attr);
          if (val && val.includes(fromYear)) el.setAttribute(attr, val.replaceAll(fromYear, toYear));
        });
      });
    }

    // Wire snapshot button and set footer date after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      applyBaseYearTextSwap(String(PRIOR_BASE_YEAR), String(BASE_YEAR));
    });
  </script>
  <script>
    // Accessible toggle for the "View as" info tooltip (hover, focus, click, ESC)
    (function() {
      const icon = document.getElementById('unitInfoIcon');
      if (!icon) return;
      const tooltip = icon.querySelector('.info-tooltip');
      if (!tooltip) return;

      let open = false;
      const show = () => { tooltip.style.visibility = 'visible'; tooltip.style.opacity = '1'; open = true; };
      const hide = () => { tooltip.style.visibility = 'hidden'; tooltip.style.opacity = '0'; open = false; };

      icon.addEventListener('mouseenter', show);
      icon.addEventListener('mouseleave', hide);
      icon.addEventListener('focus', show);
      icon.addEventListener('blur', hide);
      icon.addEventListener('click', (e) => {
        e.stopPropagation();
        open ? hide() : show();
      });
      document.addEventListener('click', (e) => {
        if (!icon.contains(e.target)) hide();
      });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') hide();
      });
    })();

    try {
      if (window.VIBE && typeof VIBE.triggerReady === 'function') VIBE.triggerReady();
    } catch (e) { /* no-op */ }
  </script>
</body>
</html>
