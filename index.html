<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Canadian Wealth &amp; Income Dashboard</title>
  <!-- Open Graph tags make the site attractive when shared on social media -->
  <meta property="og:title" content="Canadian Wealth &amp; Income Dashboard" />
  <meta property="og:description" content="Explore detailed charts of Canadian median income, net worth by age, wealth distribution and more. Built using multiple data sources for the most comprehensive view available." />
  <meta property="og:image" content="https://example.com/share-image.png" />
  <meta property="og:type" content="website" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Global styles */
    body {
      background: #0a1931;
      color: #e0e6ed;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      color: #ffffff;
      text-align: center;
    }
    p.lead {
      font-size: 1.1rem;
      line-height: 1.6;
      text-align: center;
      margin: 0 auto 40px;
      max-width: 800px;
    }
    /* Chart card styling */
    .charts-grid {
      display: grid;
      gap: 20px;
    }
    @media (min-width: 768px) {
      .charts-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    .chart-card {
      background: #13294b;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    .chart-card h3 {
      margin: 0 0 10px;
      font-size: 1.4rem;
      color: #00bfa5;
    }
    .chart-container {
      position: relative;
      height: 400px;
      width: 100%;
    }
    /* Footnotes */
    .footnotes {
      margin-top: 40px;
      font-size: 0.8rem;
      line-height: 1.4;
      color: #8aa2c1;
    }
    .footnotes a {
      color: #6aa3f4;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Canadian Wealth &amp; Income Dashboard</h1>
    <p class="lead">
      Welcome! This dashboard aggregates Canadian income and net worth data from several
      credible sources. Use it to see how your finances compare with others by age
      group, province and percentile. All figures are in Canadian dollars.
    </p>
    <!-- Region selector to filter data by province -->
    <div style="text-align:center; margin: 20px 0;">
      <label for="provinceSelect" style="margin-right:10px; font-weight:bold;">Select region:</label>
      <select id="provinceSelect" style="padding: 5px 10px; border-radius:5px;">
        <option value="Canada">Canada</option>
        <option value="Newfoundland & Labrador">Newfoundland & Labrador</option>
        <option value="Prince Edward Island">Prince Edward Island</option>
        <option value="Nova Scotia">Nova Scotia</option>
        <option value="New Brunswick">New Brunswick</option>
        <option value="Quebec">Quebec</option>
        <option value="Ontario">Ontario</option>
        <option value="Manitoba">Manitoba</option>
        <option value="Saskatchewan">Saskatchewan</option>
        <option value="Alberta">Alberta</option>
        <option value="British Columbia">British Columbia</option>
      </select>
    </div>

    <!-- User input form for comparison -->
    <div style="text-align:center; margin: 20px 0;">
      <label for="userAge" style="margin-right:8px;">Your age:</label>
      <input id="userAge" type="number" min="18" max="100" style="width:60px; padding:5px; border-radius:4px;" />
      <label for="userIncome" style="margin-left:12px; margin-right:8px;">Income:</label>
      <input id="userIncome" type="number" step="1000" max="1000000" style="width:100px; padding:5px; border-radius:4px;" />
      <label for="userNetWorth" style="margin-left:12px; margin-right:8px;">Net worth:</label>
      <input id="userNetWorth" type="number" step="1000" max="100000000" style="width:120px; padding:5px; border-radius:4px;" />
      <button id="compareBtn" style="padding:6px 12px; margin-left:10px; border-radius:4px; background-color:#ef5350; color:#fff; border:none; cursor:pointer;">Compare</button>
      <button id="resetBtn" style="padding:6px 12px; margin-left:6px; border-radius:4px; background-color:#455a64; color:#fff; border:none; cursor:pointer;">Reset</button>
    </div>

    <!-- Percentile selector: allows users to overlay additional percentile lines on the charts.  A multi‑select dropdown
         is used so the user can choose any combination of percentiles.  The median (50th percentile) is always
         displayed by default; selecting other percentiles will add those lines to all charts. -->
    <div style="text-align:center; margin: 10px 0 30px 0;">
      <label for="percentileSelect" style="margin-right:10px; font-weight:bold;">Select percentiles to display:</label>
      <select id="percentileSelect" multiple size="4" style="padding: 5px 10px; border-radius:5px; min-width:200px;">
        <!-- Preselect the median (p50) so that the dropdown reflects the default state.  
             Users can hold Ctrl/Cmd to select additional percentiles.  -->
        <option value="p10">10th Percentile</option>
        <option value="p25">25th Percentile</option>
        <option value="p50" selected>Median (50th Percentile)</option>
        <option value="p75">75th Percentile</option>
        <option value="p90">90th Percentile</option>
        <option value="p99">99th Percentile</option>
      </select>
      <p style="font-size:0.8rem; color:#8aa2c1; margin-top:8px;">Hold Ctrl (or Cmd on Mac) to select multiple lines. Default shows only the median.</p>
    </div>
    <!-- Global unit selector: toggle entire dashboard between Households and Individuals (default: Households) -->
    <div style="text-align:center; margin: 10px 0 30px 0;">
      <label for="unitSelect" style="margin-right:10px; font-weight:bold;">View as:</label>
      <select id="unitSelect" style="padding: 5px 10px; border-radius:5px; min-width:180px;">
        <option value="households" selected>Households</option>
        <option value="individuals">Individuals</option>
      </select>
      <p style="font-size:0.8rem; color:#8aa2c1; margin-top:8px;">Applies to all charts. Default shows Households.</p>
    </div>
      <div class="charts-grid">
      <!-- Median Income Chart (2025 estimate) -->
      <div class="chart-card">
        <h3 id="incomeTitle">Estimated Median Employment Income by Age (Individuals, 2025)</h3>
        <div class="chart-container">
          <canvas id="incomeChart"></canvas>
        </div>
      </div>

      <!-- Income composition breakdown chart (2025) -->
      <div class="chart-card">
        <h3 id="compositionTitle">Income Composition Breakdown by Age (2025)</h3>
        <div class="chart-container">
          <canvas id="compositionChart"></canvas>
        </div>
      </div>
      <!-- Median Net Worth Chart (2025 estimate) -->
      <div class="chart-card">
        <h3 id="netWorthTitle">Estimated Median Net Worth by Age (Households, 2025)</h3>
        <div class="chart-container">
          <canvas id="netWorthChart"></canvas>
        </div>
      </div>
      <!-- Income vs Net Worth Scatter Plot (2025) -->
      <div class="chart-card">
        <h3 id="scatterTitle">Income vs Net Worth by Age (2025)</h3>
        <div class="chart-container">
          <canvas id="scatterChart"></canvas>
        </div>
      </div>
      <!-- Net Worth Distribution (Histogram) -->
      <div class="chart-card">
        <h3 id="percentileNetWorthTitle">Net Worth Distribution (Histogram, 2025)</h3>
        <div class="chart-container">
          <canvas id="percentileNetWorthChart"></canvas>
        </div>
      </div>
      <!-- Income Distribution (Histogram) -->
      <div class="chart-card">
        <h3 id="percentileIncomeTitle">Income Distribution (Histogram, 2025)</h3>
        <div class="chart-container">
          <canvas id="percentileIncomeChart"></canvas>
        </div>
      </div>

      <!-- Wealth Composition by Age (stacked area) -->
      <div class="chart-card">
        <h3 id="wealthCompositionTitle">Wealth Composition by Age (2025)</h3>
        <div class="chart-container">
          <canvas id="wealthCompositionChart"></canvas>
        </div>
      </div>

      <!-- Income Percentile by Gender -->
      <div class="chart-card">
        <h3 id="genderIncomeTitle">Income Percentile by Gender (2025)</h3>
        <div class="chart-container">
          <canvas id="genderIncomeChart"></canvas>
        </div>
      </div>
      <!-- Projected Median Net Worth by Province (2025) -->
      <div class="chart-card">
        <h3 id="provinceTitle">Projected Median Net Worth by Province (2025)</h3>
        <div class="chart-container">
          <canvas id="provinceChart"></canvas>
        </div>
      </div>

      <!-- Median Income by Province (2025) -->
      <div class="chart-card">
        <h3 id="provinceIncomeTitle">Median Income by Province (2025)</h3>
        <div class="chart-container">
          <canvas id="provinceIncomeChart"></canvas>
        </div>
      </div>
    </div>
    <!-- Footnotes Section -->
    <div class="footnotes">
      <p><strong>Sources</strong>:</p>
      <ol>
        <li>Statistics Canada’s Survey of Financial Security datasets for 2019 and 2023 were used to calculate compound annual growth rates and project 2025 median net worth by age【642847066579513†L396-L403】【488464190137828†L64-L74】.</li>
        <li>Blueprint Financial’s summary of median employment income by age for 2022 served as the base for estimating 2025 income【212804967053546†L60-L70】.</li>
        <li>To estimate total income by age, we combined employment earnings with typical investment returns, pensions and government transfers.  Because data on total income by age is sparse, we used economic reasoning and available statistics on average retirement incomes (e.g., median senior family after‑tax income around $74,200) to set anchor points and smoothed values between them.</li>
        <li>Kickass Entrepreneur’s top‑1% net worth data by age (2025) informed the highest wealth percentile chart【540391994608617†L194-L207】.</li>
        <li>Savvy New Canadians compiled Statistics Canada’s 2019 median net worth and provincial data【642847066579513†L454-L465】, which were scaled to 2025 using national growth rates.</li>
        <li>Blueprint Financial’s analysis of average net worth by age from 2020–2024 informed the projection of 2025 average household net worth【708036326161211†L33-L41】【708036326161211†L109-L115】.</li>
        <li>Statistics Canada’s Q1&nbsp;2024 household debt survey as reported by Moving2Canada provided average non‑mortgage debt levels by age group, which were used to set negative net worth values for 18‑ to 22‑year‑olds (e.g., 18‑25‑year‑olds carry about $8,085 in debt, 26‑35‑year‑olds about $17,197, and so on)【474449702923231†screenshot】.</li>
      </ol>
    </div>
    <!-- Methods Section -->
    <div class="footnotes" style="margin-top: 20px;">
      <p><strong>Methods</strong>:</p>
      <p>
        To produce age‑specific estimates for 2025, the most recent public data were smoothed
        and projected using straightforward calculations:
      </p>
      <ul>
        <li><strong>Median net worth by age:</strong> We began with Statistics Canada’s 2019 and 2023
        median net worth figures, calculated a compound annual growth rate for each age
        bracket and applied it to project values for 2025【642847066579513†L396-L403】【488464190137828†L64-L74】.
        Anchor points were set at ages&nbsp;30, 40, 50, 60, 70 and 80, corresponding
        approximately to the 2025 projections for each bracket (for example, ≈$175k
        at age&nbsp;30 for the under‑35 group, ≈$400k at age&nbsp;40 for the 35–44 group,
        ≈$600k at age&nbsp;50 for the 45–54 group, ≈$750k at age&nbsp;60 for the 55–64
        group, ≈$700k at age&nbsp;70 for seniors and ≈$600k at age&nbsp;80). We assumed that
        wealth draws down in later retirement. The values between anchors were
        smoothed by linear interpolation. To capture the debt burden that many
        young adults face, we incorporated average non‑mortgage debt levels from
        Statistics Canada’s Q1&nbsp;2024 survey (e.g., roughly $8,085 for 18–25‑year‑olds
        and $17,197 for 26–35‑year‑olds【474449702923231†screenshot】). These debt figures were
        used to set the net‑worth baseline at –$10,000 for age&nbsp;18 and 0 for
        age&nbsp;22 before rising toward the projected median at age&nbsp;30.</li>
        <li><strong>Median income by age:</strong> Median employment income from 2022 was increased by
        approximately 3% per year to approximate 2025 incomes. To capture the early career
        years more realistically, anchor points were set at ages&nbsp;18 ($25k), 22 ($35k),
        30 ($52k), 40 ($60k), 45 ($62k), 50 ($62k), 60 ($58k), 65 ($52k), 70 ($45k),
        75 ($38k) and 80 ($25k). These anchors were derived from the 2022 medians and
        adjusted to create a realistic earnings trajectory: income climbs through
        mid‑career and begins to decline around retirement age. All values between anchors
        were smoothed using linear interpolation.</li>
        <li><strong>Total income by age:</strong> To reflect the fact that many Canadians receive income
        from multiple sources—wages, investments, CPP/QPP, OAS and private pensions—we
        introduced a separate <em>total income</em> series. Anchor values were informed by
        typical after‑tax incomes for senior families (≈$74k), average CPP and OAS
        benefits and reasonable estimates for early‑career investment income. We set
        anchors at ages&nbsp;18 ($26k), 22 ($35k), 30 ($53k), 40 ($62k), 45 ($62k),
        50 ($60k), 60 ($55k), 65 ($50k), 70 ($45k), 75 ($40k) and 80 ($35k) and
        interpolated between them to produce a smooth curve. This series helps
        illustrate that total income declines less sharply in retirement than employment
        income alone.</li>
        <li><strong>Top‑1% net worth threshold:</strong> Kickass Entrepreneur’s 2025 data on the
        wealth required to join the top&nbsp;1% of net worth holders by age was used
        to build the high‑wealth chart. Anchor points were set at ages 18 (≈$300k),
        25 (≈$450k), 30 (≈$800k), 35 (≈$2M), 40 (≈$4M), 45 (≈$5M), 50 (≈$6M),
        55 (≈$7M), 60 (≈$8M), 65 (≈$8.5M), 70 (≈$7.5M), 75 (≈$6.5M) and 80 (≈$6M).
        The values between these anchors were smoothed via linear interpolation to
        reflect how the threshold climbs rapidly through mid‑career and then
        tapers off in later retirement.</li>
        <li><strong>Average net worth (households vs individuals):</strong> Blueprint Financial’s 2020–2024
        average household net worth by age was used to derive growth rates; these rates were
        applied to 2024 values to estimate 2025 household net worth. Individual net worth
        values from 2019 were grown at the same rates to estimate 2025 individual net
        worth. Both datasets were smoothed between age‑bracket anchors.</li>
        <li><strong>Provincial projections and scaling:</strong> Median net worth by province (2019) was scaled to
        2025 by applying the national median net worth growth rate observed between 2019
        and 2023. Income and net worth values for each province are calculated by
        multiplying the national age‑specific data by provincial ratios. Income ratios
        come from average individual incomes in 2023【118231790205128†L100-L108】, while net worth ratios
        are based on the 2023 provincial median net worth values relative to the national
        median【488464190137828†L64-L74】.</li>
        <li><strong>Smoothing &amp; rounding:</strong> All charts display smoothed values for each age from
        18–80. Axis scales are rounded to the nearest thousand dollars and ages are spaced
        evenly. Hovering over a point reveals the exact estimated value for that age.</li>
      </ul>
    </div>
  </div>
  <script>
    // Register a custom watermark plugin.  This draws faint text behind each
    // chart using the specified colour.  The plugin reads the watermark
    // configuration from the chart options (plugins.watermark) and falls
    // back to a default colour if none is provided.  Opacity is set via
    // the canvas globalAlpha to ensure the watermark remains subtle.
    const watermarkPlugin = {
      id: 'watermark',
      beforeDraw: function(chart, args, options) {
        const opts = chart.options.plugins.watermark || {};
        const ctx = chart.ctx;
        const { left, right, top, bottom } = chart.chartArea;
        // Use user‑defined values or fall back to sensible defaults.  The
        // watermark is placed near the bottom right of the chart.
        const text = opts.text || 'wealthdashboard.ca';
        const color = opts.color || '#4fc3f7';
        // Use a slightly higher opacity for better visibility and a smaller font size
        const opacity = opts.opacity !== undefined ? opts.opacity : 0.10;
        const fontSize = opts.fontSize || 16;
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.fillStyle = color;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        const x = right - 10;
        const y = bottom - 10;
        ctx.fillText(text, x, y);
        ctx.restore();
      }
    };
    Chart.register(watermarkPlugin);
    // Data definitions for 2025 smoothed estimates
    // Age labels for 18–80 inclusive
    const ageLabels = [
      '18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50','51','52','53','54','55','56','57','58','59','60','61','62','63','64','65','66','67','68','69','70','71','72','73','74','75','76','77','78','79','80'
    ];
    /*
     * Base datasets for Canada. These arrays serve as the foundation for all
     * regions; when a province is selected, values are scaled by the appropriate
     * income or net worth ratio. The earliest ages are adjusted to reflect
     * typical negative or low net worth in early adulthood.
     */
    const baseIncome = [
      25000,27500,30000,32500,35000,37188,39375,41562,43750,45938,48125,50312,52500,53450,54400,55350,56300,57250,58200,59150,60100,61050,62000,62200,62400,62600,62800,63000,62800,62600,62400,62200,62000,61100,60200,59300,58400,57500,56600,55700,54800,53900,53000,51700,50400,49100,47800,46500,45200,43900,42600,41300,40000,38500,37000,35500,34000,32500,31000,29500,28000,26500,25000
    ];

    // Base total income values (all sources) for 2025.  These values
    // reflect estimated median total income by age, including wages,
    // investment returns, pensions and government transfers.  Anchor
    // points were chosen at ages 18, 22, 30, 40, 45, 50, 60, 65, 70,
    // 75 and 80 based on typical earnings patterns and average retirement
    // incomes reported by senior households.  Linear interpolation was
    // used between anchors to create a smooth curve across ages.  See
    // Methods for a full explanation.
    const baseTotalIncome = [
      26000,28250,30500,32750,35000,37500,40000,42500,45000,47500,50000,52500,55000,56500,58000,59500,61000,62500,64000,65500,67000,68500,70000,70400,70800,71200,71600,72000,71600,71200,70800,70400,70000,69000,68000,67000,66000,65000,64000,63000,62000,61000,60000,59000,58000,57000,56000,55000,54000,53000,52000,51000,50000,49000,48000,47000,46000,45000,44000,43000,42000,41000,40000
    ];
    // Base net worth values have been recalibrated using projected 2025 median
    // net worth by age groups from Statistics Canada’s 2019–2023 Survey of
    // Financial Security. The curve starts negative to reflect that many
    // people in their late teens and early twenties carry more debt than
    // assets. Median net worth is projected for 2025 using compound annual
    // growth between 2019 and 2023 and then linearly interpolated between
    // anchor ages of 30, 40, 50, 60, 70 and 80. A downward adjustment is
    // applied after age 70 to reflect draw‑downs in retirement. See Methods
    // for details.
    const baseNetWorth = [
      -10000,-7500,-5000,-2500,0,35875,71750,107625,143500,179375,215250,251125,
      287000,312300,337600,362900,388200,413500,438800,464100,489400,514700,
      540000,563000,586000,609000,632000,655000,678000,701000,724000,747000,
      770000,791200,812400,833600,854800,876000,897200,918400,939600,960800,
      982000,969900,957800,945700,933600,921500,909400,897300,885200,873100,
      861000,834900,808800,782700,756600,730500,704400,678300,652200,626100,
      600000
    ];
    // Kickass median net worth ranges (2025) smoothed across ages (base values).
    // These values are kept for reference but are not plotted as a separate chart.
    const baseRanges = [
      70000,72500,75000,77500,80000,82500,85000,87500,92500,97500,102500,107500,112500,116500,120500,124500,128500,132500,142500,152500,162500,172500,182500,188500,194500,200500,206500,212500,218500,224500,230500,236500,242500,246500,250500,254500,258500,262500,276500,290500,304500,318500,332500,332900,333300,333700,334100,334500,334900,335300,335700,336100,336500,337700,338900,340100,341300,342500,350500,358500,366500,374500,382500
    ];
    // Kickass top‑1% net worth (2025) smoothed across ages (base values)
    const baseTop1 = [
      300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000
    ];
    // Estimated average net worth (households vs individuals) for 2025, smoothed (base values)
    const baseAvgHouseholds = [
      250000,270833,291667,312500,333333,354167,375000,395833,416667,437500,458333,479167,500000,540000,580000,620000,660000,700000,740000,780000,820000,860000,900000,955000,1010000,1065000,1120000,1175000,1230000,1285000,1340000,1395000,1450000,1480000,1510000,1540000,1570000,1600000,1630000,1660000,1690000,1720000,1750000,1680000,1610000,1540000,1470000,1400000,1360000,1320000,1280000,1240000,1200000,1180000,1160000,1140000,1120000,1100000,1080000,1060000,1040000,1020000,1000000
    ];
    const baseAvgIndividuals = [
      50000,58333,66667,75000,83333,91667,100000,108333,116667,125000,133333,141667,150000,170000,190000,210000,230000,250000,270000,290000,310000,330000,350000,375000,400000,425000,450000,475000,500000,525000,550000,575000,600000,610000,620000,630000,640000,650000,660000,670000,680000,690000,700000,680000,660000,640000,620000,600000,580000,560000,540000,520000,500000,490000,480000,470000,460000,450000,440000,430000,420000,410000,400000
    ];
    // Projected provincial median net worth (2025) – base values. These values
    // represent the estimated 2025 median net worth for each province and will
    // remain constant regardless of the selected region. When a province is
    // selected in the dropdown, the bar corresponding to that province is
    // highlighted.
    const baseProvinceLabels = ['Newfoundland & Labrador','Prince Edward Island','Nova Scotia','New Brunswick','Quebec','Ontario','Manitoba','Saskatchewan','Alberta','British Columbia'];
    // Updated provincial median net worth projections for 2025.  These
    // values were derived from Statistics Canada’s 2019 and 2023 survey
    // results【749321692766873†L68-L79】【254363627897504†L52-L63】.  We calculated a compound
    // annual growth rate for each province between 2019 and 2023 and
    // projected that forward two years to 2025.  The numbers below are
    // rounded to the nearest dollar.
    const baseProvinceValues = [
      387286, // Newfoundland & Labrador (≈$387.3k)
      549809, // Prince Edward Island (≈$549.8k)
      415798, // Nova Scotia (≈$415.8k)
      355974, // New Brunswick (≈$356.0k)
      463399, // Quebec (≈$463.4k)
      823806, // Ontario (≈$823.8k)
      441531, // Manitoba (≈$441.5k)
      431171, // Saskatchewan (≈$431.2k)
      548633, // Alberta (≈$548.6k)
      1045108 // British Columbia (≈$1.045M)
    ];

    /**
     * Ratio dictionaries for scaling by province. Income ratios are based on
     * average individual incomes in 2023 by province relative to the national
     * average (≈$63,181)【118231790205128†L100-L108】, while net worth ratios
     * are derived from Statistics Canada’s 2023 provincial median net worth
     * values relative to the national median (≈$519,700)【488464190137828†L64-L74】.
     * These ratios are used to scale the Canadian base data for each region.
     */
    const incomeRatios = {
      'Canada': 1,
      'Newfoundland & Labrador': 0.8319,
      'Prince Edward Island': 0.7306,
      'Nova Scotia': 0.8950,
      'New Brunswick': 0.9075,
      'Quebec': 0.9102,
      'Ontario': 1.0030,
      'Manitoba': 0.9259,
      // Corrected: Saskatchewan is near national average, not 1.3995
      'Saskatchewan': 0.9995,
      'Alberta': 1.1750,
      'British Columbia': 1.0483
    };
    // Net‑worth scaling ratios based on projected 2025 provincial medians.
    // Each value represents the province’s projected median net worth (2025)
    // divided by the projected national median (~$652,286).  These
    // projections use province‑specific growth rates derived from
    // 2019–2023 data【749321692766873†L68-L79】【254363627897504†L52-L63】.
    const netWorthRatios = {
      'Canada': 1,
      'Newfoundland & Labrador': 0.5937,
      'Prince Edward Island': 0.8429,
      'Nova Scotia': 0.6374,
      'New Brunswick': 0.5457,
      'Quebec': 0.7104,
      'Ontario': 1.2630,
      'Manitoba': 0.6769,
      'Saskatchewan': 0.6610,
      'Alberta': 0.8411,
      'British Columbia': 1.6022
    };

    // Compute typical median income by province using the national median employment income at
    // age 40 (index 22 in the baseIncome array).  This provides a single representative
    // figure for each province that can be displayed in the provincial income bar chart.
    // The values are calculated by multiplying the national baseline (baseIncome[22]) by the
    // appropriate income ratio for each region.  For example, Ontario’s value is
    // baseIncome[22] * incomeRatios['Ontario'] ≈ 62,000 × 1.003.
    const baseProvinceIncomeValues = baseProvinceLabels.map(label => {
      // Select the national baseline at age 40 (approximately the peak median employment income)
      const medianIncome = baseIncome[22];
      const ratio = incomeRatios[label] || 1;
      return Math.round(medianIncome * ratio);
    });

    /*
     * Percentile datasets
     *
     * The following arrays represent smoothed percentile estimates for each age 18–80.
     * They were derived by taking ratios from the 2016 income percentile table
     * (10th/25th/75th/90th/99th relative to the median) and applying those ratios to
     * our 2025 base series.  For net worth and average net worth, constant multipliers
     * were used (e.g., 10% of the median for the 10th percentile, 35% for 25th, 150% for 75th,
     * 180% for 90th and the top‑1% threshold for 99th).  See Methods for details.
     */
    // Income percentiles (individual employment income)
    const baseIncomeP10 = [5125,5637,6150,6662,7175,7623,8071,8520,9205,9914,10646,11403,12183,12386,12589,12791,12993,13194,13315,13432,13546,13657,13765,13704,13643,13581,13518,13455,13309,13163,13019,12875,12731,12446,12163,11884,11607,11334,10814,10305,9808,9321,8845,9212,9549,9858,10137,10386,12930,15310,17527,19582,21473,20668,19863,19057,18252,17447,16642,15836,15031,14226,13421];
    const baseIncomeP25 = [13386,14725,16064,17402,18741,19913,21084,22255,23513,24779,26054,27338,28630,29136,29640,30145,30649,31152,31548,31940,32327,32711,33091,33068,33044,33020,32994,32968,32637,32306,31978,31650,31325,30649,29980,29318,28662,28012,27034,26073,25129,24202,23292,22765,22237,21705,21172,20637,22524,24270,25875,27337,28658,27583,26508,25434,24359,23284,22210,21135,20060,18986,17911];
    const baseIncomeP75 = [39849,43834,47819,51804,55789,59276,62762,66248,69232,72166,75048,77879,80662,82417,84183,85959,87745,89543,91558,93590,95640,97707,99792,100679,101571,102466,103364,104266,104141,104014,103885,103756,103625,102321,101010,99694,98372,97044,95392,93745,92102,90463,88828,86641,84455,82268,80083,77897,75843,73783,71715,69640,67557,65024,62490,59957,57424,54890,52357,49823,47290,44757,42223];
    const baseIncomeP90 = [57099,62809,68519,74229,79939,84936,89931,94926,98619,102181,105610,108910,112080,114587,117110,119651,122208,124783,128049,131354,134699,138082,141504,143239,144981,146732,148491,150258,150677,151090,151497,151898,152294,150954,149589,148198,146782,145340,144183,142990,141761,140498,139198,134978,130798,126659,122560,118501,115810,113082,110319,107520,104686,100760,96834,92909,88983,85057,81132,77206,73280,69354,65429];
    const baseIncomeP99 = [103655,114021,124387,134752,145118,154190,163257,172325,180128,187803,195348,202765,210060,218828,227773,236895,246193,255667,270804,286296,302143,318347,334906,347628,360426,373299,386246,399269,404079,408850,413583,418277,422932,422706,422305,421731,420982,420059,417386,414589,411668,408623,405453,391530,377807,364284,350961,337838,329318,320745,312119,303439,294706,283655,272603,261552,250500,239449,228397,217346,206294,195243,184191];
    // Total income percentiles (all income sources)
    const baseTotalIncomeP10 = [5330,5791,6252,6713,7175,7687,8199,8712,9468,10251,11061,11898,12763,13093,13422,13750,14078,14404,14642,14874,15102,15324,15541,15511,15480,15447,15413,15377,15174,14972,14771,14572,14374,14055,13739,13427,13118,12812,12228,11656,11096,10549,10013,10512,10989,11444,11876,12285,15447,18484,21395,24181,26841,26305,25768,25231,24694,24157,23620,23084,22547,22010,21473];
    const baseTotalIncomeP25 = [13922,15127,16331,17536,18741,20080,21418,22757,24184,25622,27069,28526,29994,30798,31602,32405,33207,34009,34692,35368,36039,36703,37361,37427,37493,37556,37618,37678,37210,36745,36282,35823,35367,34612,33865,33125,32392,31666,30568,29490,28430,27390,26368,25980,25590,25198,24804,24409,26910,29301,31584,33758,35822,35106,34389,33673,32957,32240,31524,30807,30091,29374,28658];
    const baseTotalIncomeP75 = [41443,45029,48616,52202,55789,59773,63758,67743,71210,74620,77972,81266,84503,87120,89753,92404,95071,97754,100682,103638,106621,109631,112668,113952,115244,116542,117848,119161,118734,118303,117870,117434,116996,115550,114098,112639,111174,109702,107864,106031,104203,102379,100561,98875,97190,95505,93821,92136,90609,89077,87539,85996,84447,82758,81069,79380,77691,76002,74313,72624,70935,69246,67557];
    const baseTotalIncomeP90 = [59383,64522,69661,74800,79939,85648,91358,97068,101436,105655,109725,113646,117418,121126,124860,128622,132410,136226,140810,145456,150163,154932,159763,162122,164498,166890,169299,171724,171791,171846,171890,171923,171945,170472,168971,167442,165884,164297,163033,161730,160387,159005,157583,154036,150521,147037,143585,140163,138357,136523,134662,132773,130857,128240,125623,123006,120389,117772,115154,112537,109920,107303,104686];
    const baseTotalIncomeP99 = [107802,117131,126460,135789,145118,155483,165849,176214,185274,194189,202959,211583,220063,231315,242846,254656,266745,279113,297791,317031,336832,357195,378119,393457,408945,424583,440370,456307,460701,465018,469258,473419,477504,477360,477023,476492,475767,474849,471956,468925,465756,462449,459004,446814,434778,422896,411168,399593,393433,387232,380990,374707,368383,361015,353647,346280,338912,331544,324177,316809,309441,302074,294706];
    // Net worth percentiles
    const baseNetWorthP10 = [-1000,-750,-500,-250,0,3588,7175,10762,14350,17938,21525,25112,28700,31230,33760,36290,38820,41350,43880,46410,48940,51470,54000,56300,58600,60900,63200,65500,67800,70100,72400,74700,77000,79120,81240,83360,85480,87600,89720,91840,93960,96080,98200,96990,95780,94570,93360,92150,90940,89730,88520,87310,86100,83490,80880,78270,75660,73050,70440,67830,65220,62610,60000];
    const baseNetWorthP25 = [-3500,-2625,-1750,-875,0,12556,25112,37669,50225,62781,75338,87894,100450,109305,118160,127015,135870,144725,153580,162435,171290,180145,189000,197050,205100,213150,221200,229250,237300,245350,253400,261450,269500,276920,284340,291760,299180,306600,314020,321440,328860,336280,343700,339465,335230,330995,326760,322525,318290,314055,309820,305585,301350,292215,283080,273945,264810,255675,246540,237405,228270,219135,210000];
    const baseNetWorthP75 = [-15000,-11250,-7500,-3750,0,53812,107625,161438,215250,269062,322875,376688,430500,468450,506400,544350,582300,620250,658200,696150,734100,772050,810000,844500,879000,913500,948000,982500,1017000,1051500,1086000,1120500,1155000,1186800,1218600,1250400,1282200,1314000,1345800,1377600,1409400,1441200,1473000,1454850,1436700,1418550,1400400,1382250,1364100,1345950,1327800,1309650,1291500,1252350,1213200,1174050,1134900,1095750,1056600,1017450,978300,939150,900000];
    const baseNetWorthP90 = [-18000,-13500,-9000,-4500,0,64575,129150,193725,258300,322875,387450,452025,516600,562140,607680,653220,698760,744300,789840,835380,880920,926460,972000,1013400,1054800,1096200,1137600,1179000,1220400,1261800,1303200,1344600,1386000,1424160,1462320,1500480,1538640,1576800,1614960,1653120,1691280,1729440,1767600,1745820,1724040,1702260,1680480,1658700,1636920,1615140,1593360,1571580,1549800,1502820,1455840,1408860,1361880,1314900,1267920,1220940,1173960,1126980,1080000];
    const baseNetWorthP99 = [300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000];
    // Average net worth percentiles (households)
    const baseAvgHouseholdsP10 = [25000,27083,29167,31250,33333,35417,37500,39583,41667,43750,45833,47917,50000,54000,58000,62000,66000,70000,74000,78000,82000,86000,90000,95500,101000,106500,112000,117500,123000,128500,134000,139500,145000,148000,151000,154000,157000,160000,163000,166000,169000,172000,175000,168000,161000,154000,147000,140000,136000,132000,128000,124000,120000,118000,116000,114000,112000,110000,108000,106000,104000,102000,100000];
    const baseAvgHouseholdsP25 = [87500,94792,102083,109375,116667,123958,131250,138542,145833,153125,160417,167708,175000,189000,203000,217000,231000,245000,259000,273000,287000,301000,315000,334250,353500,372750,392000,411250,430500,449750,469000,488250,507500,518000,528500,539000,549500,560000,570500,581000,591500,602000,612500,588000,563500,539000,514500,490000,476000,462000,448000,434000,420000,413000,406000,399000,392000,385000,378000,371000,364000,357000,350000];
    const baseAvgHouseholdsP75 = [375000,406250,437500,468750,500000,531250,562500,593750,625000,656250,687500,718750,750000,810000,870000,930000,990000,1050000,1110000,1170000,1230000,1290000,1350000,1432500,1515000,1597500,1680000,1762500,1845000,1927500,2010000,2092500,2175000,2220000,2265000,2310000,2355000,2400000,2445000,2490000,2535000,2580000,2625000,2520000,2415000,2310000,2205000,2100000,2040000,1980000,1920000,1860000,1800000,1770000,1740000,1710000,1680000,1650000,1620000,1590000,1560000,1530000,1500000];
    const baseAvgHouseholdsP90 = [450000,487499,525001,562500,599999,637501,675000,712499,750001,787500,824999,862501,900000,972000,1044000,1116000,1188000,1260000,1332000,1404000,1476000,1548000,1620000,1719000,1818000,1917000,2016000,2115000,2214000,2313000,2412000,2511000,2610000,2664000,2718000,2772000,2826000,2880000,2934000,2988000,3042000,3096000,3150000,3024000,2898000,2772000,2646000,2520000,2448000,2376000,2304000,2232000,2160000,2124000,2088000,2052000,2016000,1980000,1944000,1908000,1872000,1836000,1800000];
    const baseAvgHouseholdsP99 = [300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000];
    // Average net worth percentiles (individuals)
    const baseAvgIndividualsP10 = [5000,5833,6667,7500,8333,9167,10000,10833,11667,12500,13333,14167,15000,17000,19000,21000,23000,25000,27000,29000,31000,33000,35000,37500,40000,42500,45000,47500,50000,52500,55000,57500,60000,61000,62000,63000,64000,65000,66000,67000,68000,69000,70000,68000,66000,64000,62000,60000,58000,56000,54000,52000,50000,49000,48000,47000,46000,45000,44000,43000,42000,41000,40000];
    const baseAvgIndividualsP25 = [17500,20417,23333,26250,29167,32083,35000,37917,40833,43750,46667,49583,52500,59500,66500,73500,80500,87500,94500,101500,108500,115500,122500,131250,140000,148750,157500,166250,175000,183750,192500,201250,210000,213500,217000,220500,224000,227500,231000,234500,238000,241500,245000,238000,231000,224000,217000,210000,203000,196000,189000,182000,175000,171500,168000,164500,161000,157500,154000,150500,147000,143500,140000];
    const baseAvgIndividualsP75 = [75000,87500,100000,112500,125000,137500,150000,162500,175000,187500,200000,212500,225000,255000,285000,315000,345000,375000,405000,435000,465000,495000,525000,562500,600000,637500,675000,712500,750000,787500,825000,862500,900000,915000,930000,945000,960000,975000,990000,1005000,1020000,1035000,1050000,1020000,990000,960000,930000,900000,870000,840000,810000,780000,750000,735000,720000,705000,690000,675000,660000,645000,630000,615000,600000];
    const baseAvgIndividualsP90 = [90000,104999,120001,135000,149999,165001,180000,194999,210001,225000,239999,255001,270000,306000,342000,378000,414000,450000,486000,522000,558000,594000,630000,675000,720000,765000,810000,855000,900000,945000,990000,1035000,1080000,1098000,1116000,1134000,1152000,1170000,1188000,1206000,1224000,1242000,1260000,1224000,1188000,1152000,1116000,1080000,1044000,1008000,972000,936000,900000,882000,864000,846000,828000,810000,792000,774000,756000,738000,720000];
    const baseAvgIndividualsP99 = [150000,162500,175000,187500,200000,212500,225000,237500,270000,302500,335000,367500,400000,470000,540000,610000,680000,750000,850000,950000,1050000,1150000,1250000,1400000,1550000,1700000,1850000,2000000,2100000,2200000,2300000,2400000,2500000,2600000,2700000,2800000,2900000,3000000,3300000,3600000,3900000,4200000,4500000,4650000,4800000,4950000,5100000,5250000,5250000,5250000,5250000,5250000,5250000,5150000,5050000,4950000,4850000,4750000,4650000,4550000,4450000,4350000,4250000];

    // Individuals median net worth estimates for 2025.  Because Statistics
    // Canada reports net worth at the family/household level, there is no
    // official individual median net worth series.  We therefore approximate
    // individual median net worth as 60% of the household median net worth
    // at each age.  This ratio reflects the fact that unattached persons
    // typically hold less wealth than multi‑person households.  Percentile
    // estimates for individuals use the same 60% ratio applied to the
    // household percentile arrays.
    function scaleIndividualNetWorthArray(arr) {
      return arr.map(v => {
        // For negative values, scale by 1.5 to reflect deeper debt for
        // individuals; for positive values, scale by 0.6.  This ensures
        // individuals remain below households at every age.
        return v < 0 ? Math.round(v * 1.5) : Math.round(v * 0.6);
      });
    }
    const baseIndNetWorth = scaleIndividualNetWorthArray(baseNetWorth);
    const baseIndNetWorthP10 = scaleIndividualNetWorthArray(baseNetWorthP10);
    const baseIndNetWorthP25 = scaleIndividualNetWorthArray(baseNetWorthP25);
    const baseIndNetWorthP75 = scaleIndividualNetWorthArray(baseNetWorthP75);
    const baseIndNetWorthP90 = scaleIndividualNetWorthArray(baseNetWorthP90);
    const baseIndNetWorthP99 = scaleIndividualNetWorthArray(baseNetWorthP99);

    // Colour palettes for percentile lines.  Each chart type has its own set of
    // shades.  Colours progress from lighter to darker as the percentile
    // increases.  Median uses the base colour for each chart.
    const percentileColors = {
      income: {
        p10: '#B3E5FC',
        p25: '#81D4FA',
        p50: '#29B6F6',
        p75: '#0288D1',
        p90: '#01579B',
        p99: '#002F6C'
      },
      totalIncome: {
        p10: '#FFECB3',
        p25: '#FFE082',
        p50: '#FFC107',
        p75: '#FFA000',
        p90: '#FF6F00',
        p99: '#E65100'
      },
      netWorth: {
        p10: '#C8E6C9',
        p25: '#A5D6A7',
        p50: '#66BB6A',
        p75: '#388E3C',
        p90: '#1B5E20',
        p99: '#004D40'
      },
      top1: {
        p10: '#F8BBD0',
        p25: '#F48FB1',
        p50: '#F06292',
        p75: '#C2185B',
        p90: '#880E4F',
        p99: '#560027'
      },
      avgHouseholds: {
        p10: '#B2EBF2',
        p25: '#80DEEA',
        p50: '#26C6DA',
        p75: '#0097A7',
        p90: '#006064',
        p99: '#004D40'
      },
      avgIndividuals: {
        p10: '#FFCDD2',
        p25: '#EF9A9A',
        p50: '#EF5350',
        p75: '#E53935',
        p90: '#B71C1C',
        p99: '#880E4F'
      }
      ,
      // Individual median net worth chart colors (similar palette to avgIndividuals)
      indNetWorth: {
        p10: '#FFCDD2',
        p25: '#EF9A9A',
        p50: '#EF5350',
        p75: '#E53935',
        p90: '#B71C1C',
        p99: '#880E4F'
      }
    };

    // Chart instance holders for dynamic updates
    let incomeChartInstance;
    let netWorthChartInstance;
    let provinceChartInstance;
    let compositionChartInstance;
    let provinceIncomeChartInstance;
    let scatterChartInstance;
    let percentileNetWorthChartInstance;
    let percentileIncomeChartInstance;
    let wealthCompositionChartInstance;
    let genderIncomeChartInstance;

    // Labels for percentile charts (1..99)
    const percentileLabels = Array.from({ length: 99 }, (_, i) => String(i + 1));

    // Anchors for constructing percentile curves (ratios of median)
    const netWorthPercentileAnchors = [
      { p: 1, r: 0.05 }, { p: 10, r: 0.10 }, { p: 25, r: 0.35 },
      { p: 50, r: 1.00 }, { p: 75, r: 1.50 }, { p: 90, r: 1.80 }, { p: 99, r: 12.0 }
    ];
    const incomePercentileAnchors = [
      { p: 1, r: 0.10 }, { p: 10, r: 0.22 }, { p: 25, r: 0.54 },
      { p: 50, r: 1.00 }, { p: 75, r: 1.64 }, { p: 90, r: 2.44 }, { p: 99, r: 6.0 }
    ];

    // Build a 1..99 curve from anchors using log-linear interpolation for smooth heavy tails
    function buildPercentileCurveFromAnchors(anchors) {
      const sorted = anchors.slice().sort((a, b) => a.p - b.p);
      const curve = new Array(99);
      let idx = 0;
      for (let p = 1; p <= 99; p++) {
        while (idx < sorted.length - 1 && p > sorted[idx + 1].p) idx++;
        const a = sorted[Math.max(0, idx)];
        const b = sorted[Math.min(sorted.length - 1, idx + 1)];
        const t = (p - a.p) / Math.max(1, (b.p - a.p));
        const lr = Math.exp(Math.log(a.r) + (Math.log(b.r) - Math.log(a.r)) * Math.max(0, Math.min(1, t)));
        curve[p - 1] = lr;
      }
      return curve;
    }

    // Given a median value and anchor ratios, return absolute values for 1..99 percentiles
    function makePercentileValues(median, anchors) {
      const ratios = buildPercentileCurveFromAnchors(anchors);
      return ratios.map(r => Math.round(median * r));
    }

    // Find the percentile index (0-based) closest to the given value on the curve
    function findPercentileIndex(value, curveValues) {
      let bestIdx = 0;
      let bestDiff = Infinity;
      for (let i = 0; i < curveValues.length; i++) {
        const d = Math.abs(curveValues[i] - value);
        if (d < bestDiff) { bestDiff = d; bestIdx = i; }
      }
      return bestIdx;
    }

    // Plugin to draw a user reference line: vertical (by index or numeric x) or horizontal (by y)
    const userVLinePlugin = {
      id: 'userVLine',
      afterDraw(chart, args, options) {
        if (!options) return;
        const { ctx, chartArea, scales } = chart;
        ctx.save();
        ctx.strokeStyle = (options.color || 'rgba(244,67,54,1)');
        ctx.setLineDash(options.dash || [6,3]);
        ctx.lineWidth = options.width || 2;
        if (options.index != null && scales.x) {
          // Vertical line aligned to a categorical tick index
          const x = scales.x.getPixelForTick(options.index);
          ctx.beginPath();
          ctx.moveTo(x, chartArea.top);
          ctx.lineTo(x, chartArea.bottom);
          ctx.stroke();
          if (options.label) {
            ctx.setLineDash([]);
            ctx.fillStyle = options.color || 'rgba(244,67,54,1)';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(options.label, x + 6, chartArea.top + 6);
          }
        } else if (options.xValue != null && scales.x) {
          // Vertical line at a numeric x-value (e.g., user value on histogram)
          const x = scales.x.getPixelForValue(options.xValue);
          ctx.beginPath();
          ctx.moveTo(x, chartArea.top);
          ctx.lineTo(x, chartArea.bottom);
          ctx.stroke();
          if (options.label) {
            ctx.setLineDash([]);
            ctx.fillStyle = options.color || 'rgba(244,67,54,1)';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(options.label, x + 6, chartArea.top + 6);
          }
        } else if (options.yValue != null && scales.y) {
          // Horizontal line at a numeric y-value (e.g., percentile)
          const y = scales.y.getPixelForValue(options.yValue);
          ctx.beginPath();
          ctx.moveTo(chartArea.left, y);
          ctx.lineTo(chartArea.right, y);
          ctx.stroke();
        }
        ctx.restore();
      }
    };
    Chart.register(userVLinePlugin);

    // Plugin to draw one or more reference vertical lines (e.g., Median)
    const medianVLinePlugin = {
      id: 'medianVLine',
      afterDraw(chart, args, options) {
        if (!options) return;
        const { ctx, chartArea, scales } = chart;
        const lines = Array.isArray(options) ? options : [options];
        ctx.save();
        lines.forEach(line => {
          if (line && line.xValue != null && scales?.x) {
            const x = scales.x.getPixelForValue(line.xValue);
            ctx.strokeStyle = line.color || 'rgba(255,255,255,0.6)';
            ctx.setLineDash(line.dash || [2,2]);
            ctx.lineWidth = line.width || 1;
            ctx.beginPath();
            ctx.moveTo(x, chartArea.top);
            ctx.lineTo(x, chartArea.bottom);
            ctx.stroke();
            if (line.label) {
              ctx.setLineDash([]);
              ctx.fillStyle = line.color || 'rgba(255,255,255,0.7)';
              ctx.font = '12px sans-serif';
              ctx.textAlign = 'left';
              ctx.textBaseline = 'top';
              ctx.fillText(line.label, x + 6, chartArea.top + 6);
            }
          }
        });
        ctx.restore();
      }
    };
    Chart.register(medianVLinePlugin);

    /**
     * Compute axis bounds given an array of values and a desired step size.
     * Returns an object containing min and max. Padding and rounding to the
     * nearest thousand are applied to create clean axes. The range is
     * extended if necessary so that it is divisible by the step size.
     * @param {number[]} values
     * @param {number} step
     */
    function computeAxis(values, step) {
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);
      const pad = (maxVal - minVal) * 0.05;
      // Do not clamp negative values to zero. Allow the axis to extend
      // below zero so that negative net worth at younger ages is visible.
      let yMin = minVal - pad;
      let yMax = maxVal + pad;
      // Round bounds to the nearest thousand for clean tick labels
      yMin = Math.floor(yMin / 1000) * 1000;
      yMax = Math.ceil(yMax / 1000) * 1000;
      if (step) {
        const range = yMax - yMin;
        const remainder = range % step;
        if (remainder !== 0) {
          yMax += step - remainder;
        }
      }
      return { min: yMin, max: yMax };
    }

    /**
     * Update all charts according to the selected region. This function scales
     * base datasets by the appropriate income and net worth ratios, updates
     * chart data and axis bounds, updates chart titles, and highlights the
     * selected province in the provincial bar chart.
     * @param {string} region The selected province name or 'Canada'
     */
    function updateCharts(region) {
      const incomeRatio = incomeRatios[region] || 1;
      const netRatio = netWorthRatios[region] || 1;
      const unitEl = document.getElementById('unitSelect');
      const unit = unitEl ? unitEl.value : 'households';
      const HOUSEHOLD_INCOME_MULTIPLIER = 1.6; // assumption: median household employment income ~1.6x individual
      // Determine which percentile lines the user has selected
      const selectedPcts = (function() {
        const sel = document.getElementById('percentileSelect');
        if (!sel) return [];
        const vals = Array.from(sel.selectedOptions).map(opt => opt.value);
        return vals;
      })();
      /*
       * Helper to build datasets and axis for a line chart.  Accepts the base
       * median array and an object of percentile arrays keyed by p10/p25/etc.
       * Colours are drawn from the percentileColours dictionary for the given
       * chart type.  The function returns an object with a new dataset array
       * and an array of all values used for axis computation.
       */
      function buildPercentileDatasets(type, baseArray, pctArrays, colorMap, labelBase) {
        const datasets = [];
        // Median (50th percentile)
        datasets.push({
          label: labelBase,
          data: baseArray,
          borderColor: colorMap.p50,
          backgroundColor: 'transparent'
        });
        // Add selected percentile lines (excluding median)
        selectedPcts.forEach(p => {
          // If the user selects p50 (median), we skip because median is always present
          if (p === 'p50') return;
          const arr = pctArrays[p];
          if (!arr) return;
          let pctLabel = '';
          switch (p) {
            case 'p10': pctLabel = '10th Percentile'; break;
            case 'p25': pctLabel = '25th Percentile'; break;
            case 'p75': pctLabel = '75th Percentile'; break;
            case 'p90': pctLabel = '90th Percentile'; break;
            case 'p99': pctLabel = '99th Percentile'; break;
            default: pctLabel = p; break;
          }
          // Append chart type to label for clarity on average net worth chart
          if (type === 'avgHouseholds') {
            pctLabel += ' (Households)';
          } else if (type === 'avgIndividuals') {
            pctLabel += ' (Individuals)';
          } else if (type === 'top1' && p === 'p99') {
            pctLabel = '99th Percentile (Top 1% Threshold)';
          }
          datasets.push({
            label: pctLabel,
            data: arr,
            borderColor: colorMap[p],
            backgroundColor: 'transparent',
            pointRadius: 0,
            pointHoverRadius: 0,
            pointHitRadius: 0
          });
        });
        // Gather values for axis computation
        let allVals = baseArray.slice();
        selectedPcts.forEach(p => {
          if (p === 'p50') return;
          if (pctArrays[p]) allVals = allVals.concat(pctArrays[p]);
        });
        return { datasets, values: allVals };
      }
      // Prepare scaled arrays for each percentile for incomes
      // Scale employment income by region; adjust for unit (households vs individuals)
      let scaledIncome = baseIncome.map(v => Math.round(v * incomeRatio));
      if (unit === 'households') {
        scaledIncome = scaledIncome.map(v => Math.round(v * HOUSEHOLD_INCOME_MULTIPLIER));
      }
      const incomePctArrays = {
        p10: baseIncomeP10.map(v => Math.round(v * incomeRatio)),
        p25: baseIncomeP25.map(v => Math.round(v * incomeRatio)),
        p50: scaledIncome,
        p75: baseIncomeP75.map(v => Math.round(v * incomeRatio)),
        p90: baseIncomeP90.map(v => Math.round(v * incomeRatio)),
        p99: baseIncomeP99.map(v => Math.round(v * incomeRatio))
      };
      const incomeLabelBase = unit === 'households' ? 'Median Employment Income (Households)' : 'Median Employment Income (Individuals)';
      const incomeResult = buildPercentileDatasets('income', scaledIncome, incomePctArrays, percentileColors.income, incomeLabelBase);
      // Preserve user dataset if present
      const incomeUserIdx = incomeChartInstance.data.datasets.findIndex(ds => ds.label === 'You');
      let incomeUserDs = null;
      if (incomeUserIdx >= 0 && userActive) incomeUserDs = incomeChartInstance.data.datasets[incomeUserIdx];
      incomeChartInstance.data.datasets = incomeResult.datasets.slice();
      if (incomeUserDs) incomeChartInstance.data.datasets.push(incomeUserDs);
      // Compute axis and update chart
      let incVals = incomeResult.values.slice();
      if (userActive) incVals.push(userIncomeVal);
      let incAxis = computeAxis(incVals, 5000);
      incomeChartInstance.options.scales.y.min = 0;
      incomeChartInstance.options.scales.y.max = incAxis.max;
      incomeChartInstance.update();

      // Update gender income chart (lines for Women and Men) — use individuals baseline shape with simple ratios
      const womenRatio = 0.88; // placeholder; replace with StatsCan data when available
      const menRatio = 1.00;
      const womenIncome = baseIncome.map(v => Math.round(v * incomeRatio * (unit==='households' ? HOUSEHOLD_INCOME_MULTIPLIER : 1) * womenRatio));
      const menIncome = baseIncome.map(v => Math.round(v * incomeRatio * (unit==='households' ? HOUSEHOLD_INCOME_MULTIPLIER : 1) * menRatio));
      genderIncomeChartInstance.data.labels = ageLabels;
      genderIncomeChartInstance.data.datasets[0].data = womenIncome;
      genderIncomeChartInstance.data.datasets[1].data = menIncome;
      // Force axes to start at zero
      let gVals = womenIncome.concat(menIncome);
      const gAxis = computeAxis(gVals, 5000);
      genderIncomeChartInstance.options.scales.y.min = 0;
      genderIncomeChartInstance.options.scales.y.max = gAxis.max;
      genderIncomeChartInstance.update();

      // Income composition breakdown chart
      // Compute total income values for the selected region.  These values include
      // all income sources.  The composition shares below determine how
      // employment, investment, pension and transfer income contribute at each age.
      let scaledTotalIncome = baseTotalIncome.map(v => Math.round(v * incomeRatio));
      if (unit === 'households') {
        scaledTotalIncome = scaledTotalIncome.map(v => Math.round(v * HOUSEHOLD_INCOME_MULTIPLIER));
      }
      const empData = [];
      const invData = [];
      const penData = [];
      const transData = [];
      for (let i = 0; i < ageLabels.length; i++) {
        const age = 18 + i;
        let empShare, invShare, penShare, transShare;
        if (age <= 55) {
          empShare = 0.90; invShare = 0.05; penShare = 0.03; transShare = 0.02;
        } else if (age <= 65) {
          const t = (age - 55) / 10;
          // Interpolate between 90/5/3/2 and 60/10/20/10
          empShare = 0.90 * (1 - t) + 0.60 * t;
          invShare = 0.05 * (1 - t) + 0.10 * t;
          penShare = 0.03 * (1 - t) + 0.20 * t;
          transShare = 0.02 * (1 - t) + 0.10 * t;
        } else {
          const t = (age - 65) / 15;
          // Interpolate between 60/10/20/10 and 10/25/50/15
          empShare = 0.60 * (1 - t) + 0.10 * t;
          invShare = 0.10 * (1 - t) + 0.25 * t;
          penShare = 0.20 * (1 - t) + 0.50 * t;
          transShare = 0.10 * (1 - t) + 0.15 * t;
        }
        const totalVal = scaledTotalIncome[i];
        empData.push(Math.round(totalVal * empShare));
        invData.push(Math.round(totalVal * invShare));
        penData.push(Math.round(totalVal * penShare));
        transData.push(Math.round(totalVal * transShare));
      }
      // Update the composition chart datasets with the computed component values
      if (compositionChartInstance) {
        compositionChartInstance.data.datasets[0].data = empData;
        compositionChartInstance.data.datasets[1].data = invData;
        compositionChartInstance.data.datasets[2].data = penData;
        compositionChartInstance.data.datasets[3].data = transData;
        // Determine the axis bounds based on total income values and user income
        let compVals = scaledTotalIncome.slice();
        if (userActive) compVals.push(userIncomeVal);
        let compAxis = computeAxis(compVals, 5000);
        compositionChartInstance.options.scales.y.stacked = true;
        compositionChartInstance.options.scales.y.min = 0;
        compositionChartInstance.options.scales.y.max = compAxis.max;
        compositionChartInstance.update();
      }

      // Net worth chart (median net worth) for selected unit
      const scaledNet = (unit === 'households' ? baseNetWorth : baseIndNetWorth).map(v => Math.round(v * netRatio));
      const netPctArrays = (unit === 'households') ? {
        p10: baseNetWorthP10.map(v => Math.round(v * netRatio)),
        p25: baseNetWorthP25.map(v => Math.round(v * netRatio)),
        p50: scaledNet,
        p75: baseNetWorthP75.map(v => Math.round(v * netRatio)),
        p90: baseNetWorthP90.map(v => Math.round(v * netRatio)),
        p99: baseNetWorthP99.map(v => Math.round(v * netRatio))
      } : {
        p10: baseIndNetWorthP10.map(v => Math.round(v * netRatio)),
        p25: baseIndNetWorthP25.map(v => Math.round(v * netRatio)),
        p50: scaledNet,
        p75: baseIndNetWorthP75.map(v => Math.round(v * netRatio)),
        p90: baseIndNetWorthP90.map(v => Math.round(v * netRatio)),
        p99: baseIndNetWorthP99.map(v => Math.round(v * netRatio))
      };
      const netLabelBase = unit === 'households' ? 'Median Net Worth (Households)' : 'Median Net Worth (Individuals)';
      const netColorMap = unit === 'households' ? percentileColors.netWorth : percentileColors.indNetWorth;
      const netResult = buildPercentileDatasets(unit === 'households' ? 'netWorth' : 'indNetWorth', scaledNet, netPctArrays, netColorMap, netLabelBase);
      // Preserve zero line dataset (Zero Net Worth) and user dataset
      let zeroNetDs = null;
      let netUserDs = null;
      netWorthChartInstance.data.datasets.forEach(ds => {
        if (ds.label === 'Zero Net Worth') zeroNetDs = ds;
        if (ds.label === 'You' && userActive) netUserDs = ds;
      });
      // Build new datasets: median + selected percentiles + zero line + user
      let netDatasets = netResult.datasets.slice();
      if (zeroNetDs) netDatasets.push(zeroNetDs);
      if (netUserDs) netDatasets.push(netUserDs);
      netWorthChartInstance.data.datasets = netDatasets;
      // Compute axis for net worth chart
      let netVals = netResult.values.slice();
      if (userActive) netVals.push(userNetWorthVal);
      // include zero line values (it's 0 across ages) in axis to guarantee zero appears but computeAxis will handle automatically
      netVals = netVals.concat(new Array(ageLabels.length).fill(0));
      let netAxis = computeAxis(netVals, 200000);
      netWorthChartInstance.options.scales.y.min = netAxis.min;
      netWorthChartInstance.options.scales.y.max = netAxis.max;
      netWorthChartInstance.update();

      // Wealth Composition chart — assets stacked above zero, debts stacked below, plus net worth line
      (function updateWealthComposition(){
        const useNet = (unit==='households' ? baseNetWorth : baseIndNetWorth).map(v => Math.round(v * netRatio));
        // Approximate debt curve: peaks near mid-30s, declines after 50
        const peak = unit==='households' ? 200000 : 120000;
        const centerAge = 37; const sigma = 10;
        const debts = ageLabels.map((ageStr,i)=>{
          const age = parseInt(ageStr,10);
          const gauss = Math.exp(-0.5 * Math.pow((age - centerAge)/sigma, 2));
          let val = Math.round(peak * gauss);
          if (age < 20) val = Math.round(val*0.4);
          if (age > 70) val = Math.round(val*0.2);
          return val; // positive magnitude; we'll plot negative
        });
        // Total assets approximated as net worth + debt
        const totalAssets = useNet.map((nw,i)=> Math.max(0, nw + debts[i]));
        // Split assets by shares varying with age (more financial/pension later)
        const shares = ageLabels.map((aStr,i)=>{
          const t = i/(ageLabels.length-1);
          const realEstate = 0.55 - 0.15*t; // falls with age
          const financial = 0.25 + 0.15*t; // rises with age
          const pensions = 0.20 + 0.00*t;
          const sum = realEstate + financial + pensions;
          return { re: realEstate/sum, fin: financial/sum, pen: pensions/sum };
        });
        const re = totalAssets.map((TA,i)=> Math.round(TA * shares[i].re));
        const fin = totalAssets.map((TA,i)=> Math.round(TA * shares[i].fin));
        const pen = totalAssets.map((TA,i)=> Math.round(TA * shares[i].pen));
        const deb = debts.map(d=> -d); // negative for plotting
        const net = useNet; // already median net worth
        wealthCompositionChartInstance.data.labels = ageLabels;
        wealthCompositionChartInstance.data.datasets[0].data = re;
        wealthCompositionChartInstance.data.datasets[1].data = fin;
        wealthCompositionChartInstance.data.datasets[2].data = pen;
        wealthCompositionChartInstance.data.datasets[3].data = deb;
        wealthCompositionChartInstance.data.datasets[4].data = net;
        // Stacking: assets vs debts separated
        wealthCompositionChartInstance.options.scales.y.stacked = true;
        wealthCompositionChartInstance.options.scales.x.stacked = true;
        // Compute axis from combined arrays
        let wVals = re.concat(fin, pen, deb, net);
        const wAxis = computeAxis(wVals, 200000);
        wealthCompositionChartInstance.options.scales.y.min = wAxis.min;
        wealthCompositionChartInstance.options.scales.y.max = wAxis.max;
        wealthCompositionChartInstance.update();
      })();

      // Update scatter chart (Income vs Net Worth, Median). X = median total income, Y = median net worth for selected unit.
      const scaledTotal = (unit === 'households'
        ? baseTotalIncome.map(v => Math.round(v * incomeRatio * HOUSEHOLD_INCOME_MULTIPLIER))
        : baseTotalIncome.map(v => Math.round(v * incomeRatio)));
      const scaledNetForScatter = (unit === 'households'
        ? baseNetWorth.map(v => Math.round(v * netRatio))
        : baseIndNetWorth.map(v => Math.round(v * netRatio)));
      const scatterData = [];
      for (let i = 0; i < ageLabels.length; i++) {
        scatterData.push({ x: scaledTotal[i], y: scaledNetForScatter[i] });
      }
      // Base dataset is median
      scatterChartInstance.data.datasets[0].label = 'Median';
      scatterChartInstance.data.datasets[0].data = scatterData;
      // Add faint percentile overlays when selected (p10, p25, p75, p90, p99)
      const pToArray = (pKey) => {
        const incMap = { p10: baseTotalIncomeP10, p25: baseTotalIncomeP25, p50: baseTotalIncome, p75: baseTotalIncomeP75, p90: baseTotalIncomeP90, p99: baseTotalIncomeP99 };
        const netMapH = { p10: baseNetWorthP10, p25: baseNetWorthP25, p50: baseNetWorth, p75: baseNetWorthP75, p90: baseNetWorthP90, p99: baseNetWorthP99 };
        const netMapI = { p10: baseIndNetWorthP10, p25: baseIndNetWorthP25, p50: baseIndNetWorth, p75: baseIndNetWorthP75, p90: baseIndNetWorthP90, p99: baseIndNetWorthP99 };
        const incArr = (incMap[pKey] || baseTotalIncome).map(v => Math.round(v * incomeRatio * (unit === 'households' ? HOUSEHOLD_INCOME_MULTIPLIER : 1)));
        const netArr = ((unit === 'households' ? netMapH[pKey] : netMapI[pKey]) || (unit==='households'?baseNetWorth:baseIndNetWorth)).map(v => Math.round(v * netRatio));
        return { incArr, netArr };
      };
      // Remove any previous percentile overlay datasets (keep index 0 for median and any 'You' dataset)
      scatterChartInstance.data.datasets = scatterChartInstance.data.datasets.filter((ds, i) => i === 0 || ds.label === 'You');
      const faintGreen = 'rgba(102,187,106,0.18)';
      const faintBlue = 'rgba(41,182,246,0.18)';
      const selectedPctsForScatter = selectedPcts.filter(p => p !== 'p50');
      selectedPctsForScatter.forEach(p => {
        const { incArr, netArr } = pToArray(p);
        const pts = incArr.map((x, i) => ({ x, y: netArr[i] }));
        scatterChartInstance.data.datasets.push({
          label: p.toUpperCase(),
          type: 'scatter',
          data: pts,
          borderColor: unit === 'households' ? faintGreen : faintGreen,
          backgroundColor: unit === 'households' ? faintGreen : faintGreen,
          pointBackgroundColor: unit === 'households' ? faintGreen : faintGreen,
          pointBorderColor: unit === 'households' ? faintGreen : faintGreen,
          pointRadius: 2,
          pointHoverRadius: 2,
          showLine: false,
          order: 1
        });
      });
      // Colour code the scatter points by age.  We map age from blue to red across the
      // entire age range using an HSL colour gradient.  Each point is given a
      // corresponding colour so that younger ages appear blue and older ages fade to red.
      const scatterColors = ageLabels.map((lbl, idx) => {
        // Compute a colour gradient from blue to red.  We slightly raise the
        // lightness to improve visibility against the dark background.
        const t = idx / (ageLabels.length - 1);
        const hue = 240 - 240 * t; // 240 (blue) to 0 (red)
        // Use higher lightness (60%) for better contrast and keep saturation at 70%
        return `hsl(${hue}, 70%, 60%)`;
      });
      scatterChartInstance.data.datasets[0].pointBackgroundColor = scatterColors;
      scatterChartInstance.data.datasets[0].pointBorderColor = scatterColors;
      scatterChartInstance.data.datasets[0].backgroundColor = scatterColors;
      // Compute separate axis bounds for scatter chart (x and y). x step 5000, y step 200000.
      const xValues = scatterData.map(pt => pt.x);
      const yValues = scatterData.map(pt => pt.y);
      const xAxis = computeAxis(xValues, 5000);
      const yAxis = computeAxis(yValues, 200000);
      scatterChartInstance.options.scales = {
        x: {
          type: 'linear',
          position: 'bottom',
          min: Math.max(0, xAxis.min),
          max: xAxis.max,
          ticks: {
            color: '#b0c5e8',
            callback: function(value) {
              const rounded = Math.round(value / 1000) * 1000;
              return '$' + rounded.toLocaleString();
            },
            stepSize: 5000,
            maxTicksLimit: 10
          },
          grid: { color: '#1f3a64' }
        },
        y: {
          min: yAxis.min,
          max: yAxis.max,
          ticks: {
            color: '#b0c5e8',
            callback: function(value) {
              const rounded = Math.round(value / 1000) * 1000;
              return '$' + rounded.toLocaleString();
            },
            stepSize: 200000
          },
          grid: { color: '#1f3a64' }
        }
      };
      scatterChartInstance.update();

      // Province bar chart with percentile overlays and user line
      // Rebuild the bar dataset and percentile line datasets for the province chart.
      // Highlight the selected province by changing its bar colour.
      const barColors = baseProvinceLabels.map(label => label === region ? '#ffa726' : '#66bb6a');
      // Remove any existing user dataset before rebuilding the chart
      const existingDs = provinceChartInstance.data.datasets;
      let userLine = null;
      // Extract the bar dataset and existing user line if present
      let barDataset = null;
      existingDs.forEach(ds => {
        if (ds.type === 'bar' || !ds.type) {
          barDataset = ds;
        } else if (ds.label === 'You') {
          userLine = ds;
        }
      });
      if (!barDataset) {
        // Fallback in case of unexpected structure
        barDataset = { label: 'Median Net Worth', data: baseProvinceValues.slice(), backgroundColor: barColors, type: 'bar' };
      }
      // Update bar data and colours
      barDataset.data = baseProvinceValues.slice();
      barDataset.backgroundColor = barColors;
      barDataset.order = 1;
      // Determine percentile bar datasets for provinces based on selected percentiles
      const provincePctRatios = { p10: 0.10, p25: 0.35, p75: 1.50, p90: 1.80, p99: 12 };
      const provinceBarDatasets = [];
      // Deterministic order for percentiles so median appears in the middle
      const pctOrder = ['p10','p25','p75','p90','p99'];
      const colorScaleNW = {
        p10: 'rgba(102,187,106,0.18)',
        p25: 'rgba(102,187,106,0.28)',
        p75: 'rgba(102,187,106,0.50)',
        p90: 'rgba(102,187,106,0.65)',
        p99: 'rgba(102,187,106,0.80)'
      };
      pctOrder.forEach(p => {
        if (!selectedPcts.includes(p)) return;
        const ratio = provincePctRatios[p];
        if (!ratio) return;
        const values = baseProvinceValues.map(v => Math.round(v * ratio));
        const labels = {p10:'10th Percentile',p25:'25th Percentile',p75:'75th Percentile',p90:'90th Percentile',p99:'99th Percentile'};
        provinceBarDatasets.push({ label: labels[p], data: values, type: 'bar', backgroundColor: colorScaleNW[p], borderWidth: 0, order: 2 });
      });
      // Assemble new dataset list: lower percentiles, median, then upper percentiles
      const newProvinceDatasets = [];
      const lower = provinceBarDatasets.filter(ds => /10th|25th/.test(ds.label));
      const upper = provinceBarDatasets.filter(ds => /75th|90th|99th/.test(ds.label));
      lower.forEach(ds => newProvinceDatasets.push(ds));
      newProvinceDatasets.push(barDataset); // median in the middle
      upper.forEach(ds => newProvinceDatasets.push(ds));
      // Note: user line will be re-added by addUserMarkers() after updateCharts.
      provinceChartInstance.data.datasets = newProvinceDatasets;
      // Compute axis bounds including bars, percentile lines and user value if present
      let provinceValsForAxis = baseProvinceValues.slice();
      provinceBarDatasets.forEach(ds => { provinceValsForAxis = provinceValsForAxis.concat(ds.data); });
      if (userActive) provinceValsForAxis.push(userNetWorthVal);
      let provinceAxis = computeAxis(provinceValsForAxis, 50000);
      provinceChartInstance.options.scales.y.min = 0;
      provinceChartInstance.options.scales.y.max = provinceAxis.max;
      provinceChartInstance.update();

      // Province income chart (median and percentile income by province)
      // Compute a representative median income for each province using the national
      // median employment income at age 40 (baseIncome[22]) scaled by the
      // province-specific income ratio.  This yields a single value per
      // province suitable for bar display.
      const baseMedianIncome = (unit === 'households') ? Math.round(baseIncome[22] * HOUSEHOLD_INCOME_MULTIPLIER) : baseIncome[22];
      const provinceIncomeBars = baseProvinceLabels.map(lbl => {
        const ratio = incomeRatios[lbl] || 1;
        return Math.round(baseMedianIncome * ratio);
      });
      // Highlight the selected province in orange
      const incomeBarColors = baseProvinceLabels.map(lbl => lbl === region ? '#ffa726' : '#42a5f5');
      // Define constant percentile ratios for income across provinces.  These
      // values approximate the 10th, 25th, 75th, 90th and 99th percentile as
      // proportions of the median income, based on 2016 census income
      // distributions【605841652791315†L220-L244】.
      const provinceIncomePctRatios = { p10: 0.22, p25: 0.54, p75: 1.64, p90: 2.44, p99: 6 };
      const incomeBarPctDatasets = [];
      const pctOrderInc = ['p10','p25','p75','p90','p99'];
      const colorScaleInc = {
        p10: 'rgba(41,182,246,0.18)',
        p25: 'rgba(41,182,246,0.28)',
        p75: 'rgba(41,182,246,0.50)',
        p90: 'rgba(41,182,246,0.65)',
        p99: 'rgba(41,182,246,0.80)'
      };
      pctOrderInc.forEach(p => {
        if (!selectedPcts.includes(p)) return;
        const ratio = provinceIncomePctRatios[p];
        if (!ratio) return;
        const values = provinceIncomeBars.map(v => Math.round(v * ratio));
        const labels = {p10:'10th Percentile',p25:'25th Percentile',p75:'75th Percentile',p90:'90th Percentile',p99:'99th Percentile'};
        incomeBarPctDatasets.push({ label: labels[p], data: values, type: 'bar', backgroundColor: colorScaleInc[p], borderWidth: 0, order: 2 });
      });
      // Assemble datasets: bar dataset plus percentile bars
      const newIncomeDatasets = [];
      const lowerI = incomeBarPctDatasets.filter(ds => /10th|25th/.test(ds.label));
      const upperI = incomeBarPctDatasets.filter(ds => /75th|90th|99th/.test(ds.label));
      lowerI.forEach(ds => newIncomeDatasets.push(ds));
      newIncomeDatasets.push({ label: 'Median Income', data: provinceIncomeBars, backgroundColor: incomeBarColors, type: 'bar', order: 1 });
      upperI.forEach(ds => newIncomeDatasets.push(ds));
      // Assign datasets to the chart
      provinceIncomeChartInstance.data.datasets = newIncomeDatasets;
      // Compute axis bounds including percentile lines and the user's income
      let provinceIncomeVals = provinceIncomeBars.slice();
      incomeBarPctDatasets.forEach(ds => { provinceIncomeVals = provinceIncomeVals.concat(ds.data); });
      if (userActive) provinceIncomeVals.push(userIncomeVal);
      const provinceIncomeAxis = computeAxis(provinceIncomeVals, 5000);
      provinceIncomeChartInstance.options.scales.y.min = 0;
      provinceIncomeChartInstance.options.scales.y.max = provinceIncomeAxis.max;
      provinceIncomeChartInstance.update();
      // Update titles
      const suffix = region === 'Canada' ? 'Canada' : region;
      const unitTitle = unit === 'households' ? 'Households' : 'Individuals';
      document.getElementById('incomeTitle').textContent = `Estimated Median Employment Income by Age (${unitTitle}, 2025) - ${suffix}`;
      document.getElementById('compositionTitle').textContent = `Income Composition Breakdown by Age (Median, 2025) - ${suffix}`;
      document.getElementById('netWorthTitle').textContent = `Estimated Median Net Worth by Age (${unitTitle}, 2025) - ${suffix}`;
      document.getElementById('scatterTitle').textContent = `Income vs Net Worth by Age (Median, 2025) - ${suffix}`;
      // Update percentile charts for current region using region-wide medians
      let regionMedianNetWorth;
      let regionMedianIncome;
      const provinceIndex = baseProvinceLabels.indexOf(region);
      const nationalMedianNetWorthHousehold = 652286; // projected national household median
      const nationalMedianIncomeIndividual = baseIncome[22];
      const nationalMedianNetWorth = (unit === 'households') ? nationalMedianNetWorthHousehold : Math.round(nationalMedianNetWorthHousehold * 0.6);
      const nationalMedianIncome = (unit === 'households') ? Math.round(nationalMedianIncomeIndividual * HOUSEHOLD_INCOME_MULTIPLIER) : nationalMedianIncomeIndividual;
      if (region === 'Canada' || provinceIndex === -1) {
        regionMedianNetWorth = nationalMedianNetWorth;
        regionMedianIncome = nationalMedianIncome;
      } else {
        regionMedianNetWorth = (unit === 'households') ? baseProvinceValues[provinceIndex] : Math.round(baseProvinceValues[provinceIndex] * 0.6);
        regionMedianIncome = Math.round((incomeRatios[region] || 1) * nationalMedianIncome);
      }
      // Estimate normal distribution parameters from anchor ratios
      function estimateNormalParams(median, r10, r90) {
        const z = 1.2815515655446004; // Phi^{-1}(0.90)
        const x10 = median * r10;
        const x90 = median * r90;
        const s10 = (median - x10) / z;
        const s90 = (x90 - median) / z;
        const sigma = Math.max(1, (s10 + s90) / 2);
        return { mu: median, sigma };
      }
      function normInv(p) {
        // Acklam's approximation for inverse normal CDF
        // https://web.archive.org/web/20150910044736/http://home.online.no/~pjacklam/notes/invnorm/
        const a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
        const b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
        const c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
        const d = [7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
        const plow = 0.02425; const phigh = 1 - plow;
        let q, r;
        if (p < plow) {
          q = Math.sqrt(-2 * Math.log(p));
          return (((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
                 ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
        }
        if (p > phigh) {
          q = Math.sqrt(-2 * Math.log(1 - p));
          return -(((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
                   ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
        }
        q = p - 0.5; r = q*q;
        return (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5]) * q /
               (((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1);
      }
      // Build histogram-style distributions from normal approximation
      function buildNormalHistogram(mu, sigma, binCount = 30) {
        const minX = Math.max(0, mu - 3.5 * sigma);
        const maxX = mu + 3.5 * sigma;
        const width = (maxX - minX) / binCount;
        const pts = [];
        const invSQRT2PI = 1 / Math.sqrt(2 * Math.PI);
        for (let i = 0; i < binCount; i++) {
          const xMid = minX + (i + 0.5) * width;
          const z = (xMid - mu) / sigma;
          const pdf = invSQRT2PI * Math.exp(-0.5 * z * z) / sigma; // density per $1
          const prob = pdf * width; // probability mass in this bin
          pts.push({ x: xMid, y: prob * 100 }); // percentage
        }
        return { points: pts, minX, maxX };
      }
      const netParams = estimateNormalParams(regionMedianNetWorth, 0.10, 1.80);
      const incParams = estimateNormalParams(regionMedianIncome, 0.22, 2.44);
      const netHist = buildNormalHistogram(netParams.mu, netParams.sigma);
      const incHist = buildNormalHistogram(incParams.mu, incParams.sigma);

      // Update datasets
      percentileNetWorthChartInstance.data.labels = [];
      percentileNetWorthChartInstance.data.datasets = [ { label: 'Net Worth Distribution', data: netHist.points, backgroundColor: '#66bb6a' } ];
      percentileIncomeChartInstance.data.labels = [];
      percentileIncomeChartInstance.data.datasets = [ { label: 'Income Distribution', data: incHist.points, backgroundColor: '#29b6f6' } ];
      // Axes: X in dollars (linear), Y in percent probability
      percentileNetWorthChartInstance.options.scales = {
        x: { type: 'linear', position: 'bottom', ticks: { color: '#b0c5e8', callback: (v)=> '$' + Math.round(v/1000).toLocaleString() + 'k', maxTicksLimit: 10 }, grid: { color: '#1f3a64' }, min: netHist.minX, max: netHist.maxX },
        y: { min: 0, ticks: { color: '#b0c5e8', callback: (v)=> v + '%' }, grid: { color: '#1f3a64' } }
      };
      percentileIncomeChartInstance.options.scales = {
        x: { type: 'linear', position: 'bottom', ticks: { color: '#b0c5e8', callback: (v)=> '$' + Math.round(v/1000).toLocaleString() + 'k', maxTicksLimit: 10 }, grid: { color: '#1f3a64' }, min: incHist.minX, max: incHist.maxX },
        y: { min: 0, ticks: { color: '#b0c5e8', callback: (v)=> v + '%' }, grid: { color: '#1f3a64' } }
      };
      // Save dist params for tooltips
      percentileNetWorthChartInstance.options.plugins.distParams = { mu: netParams.mu, sigma: netParams.sigma };
      percentileIncomeChartInstance.options.plugins.distParams = { mu: incParams.mu, sigma: incParams.sigma };
      // Draw a subtle median line on both distributions
      percentileNetWorthChartInstance.options.plugins.medianVLine = { xValue: netParams.mu, color: 'rgba(255,255,255,0.6)', dash: [2,2], width: 1, label: 'Median' };
      percentileIncomeChartInstance.options.plugins.medianVLine = { xValue: incParams.mu, color: 'rgba(255,255,255,0.6)', dash: [2,2], width: 1, label: 'Median' };
      // Custom tooltip for histograms (percent at $x)
      const histLabelPctile = (ctx) => {
        const x = ctx.parsed?.x ?? 0;
        const dp = ctx?.chart?.options?.plugins?.distParams || { mu: 0, sigma: 1 };
        function erf(x){ const sign=x<0?-1:1; x=Math.abs(x); const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911; const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x); return sign*y; }
        function normCdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
        const pct = Math.max(0, Math.min(100, 100*normCdf((x - dp.mu)/Math.max(1, dp.sigma))));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        return `Percentile: ${toOrdinal(pct)} — $${Math.round(x).toLocaleString()}`;
      };
      percentileNetWorthChartInstance.options.plugins.tooltip = { mode: 'nearest', intersect: true, callbacks: { label: histLabelPctile } };
      percentileIncomeChartInstance.options.plugins.tooltip = { mode: 'nearest', intersect: true, callbacks: { label: histLabelPctile } };
      document.getElementById('percentileNetWorthTitle').textContent = `Net Worth Distribution (Histogram, 2025) - ${suffix}`;
      document.getElementById('percentileIncomeTitle').textContent = `Income Distribution (Histogram, 2025) - ${suffix}`;
      if (userActive) {
        // Draw vertical line at user's value on histograms with percentile labels
        function erf(x){ const sign=x<0?-1:1; x=Math.abs(x); const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911; const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x); return sign*y; }
        function normCdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
        const netPct = Math.max(0, Math.min(100, 100*normCdf((userNetWorthVal - netParams.mu)/Math.max(1,netParams.sigma))));
        const incPct = Math.max(0, Math.min(100, 100*normCdf((userIncomeVal - incParams.mu)/Math.max(1,incParams.sigma))));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: userNetWorthVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(netPct)} percentile` };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: userIncomeVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(incPct)} percentile` };
      } else {
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: null };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: null };
      }
      percentileNetWorthChartInstance.update();
      percentileIncomeChartInstance.update();
      document.getElementById('provinceTitle').textContent = `Projected Median Net Worth by Province (2025)`;
      document.getElementById('provinceIncomeTitle').textContent = `Median Income by Province (2025)`;
      // If the user has entered comparison data, replot the markers after updating the charts.
      if (userActive) {
        addUserMarkers();
      }
    }

    /**
     * Generic chart creator
     * @param {string} canvasId
     * @param {Object} dataInfo
     * @param {string} type - Chart type (line or bar)
     */
function createChart(canvasId, dataInfo, type = 'line') {
  const ctx = document.getElementById(canvasId).getContext('2d');

  // --- helpers ---
  const toRGBA = (hex, a=1) => {
    if (!hex) return `rgba(79,195,247,${a})`; // fallback light blue
    const h = hex.replace('#','');
    const bigint = parseInt(h, 16);
    const r = (h.length===3) ? ((bigint>>8)&0xF)*17 : (bigint>>16)&0xFF;
    const g = (h.length===3) ? ((bigint>>4)&0xF)*17 : (bigint>>8)&0xFF;
    const b = (h.length===3) ? (bigint&0xF)*17     : (bigint>>0)&0xFF;
    return `rgba(${r},${g},${b},${a})`;
  };

  // Flatten values for y-scaling
  const allValues = dataInfo.datasets.reduce((acc, ds) => acc.concat(ds.data || []), []);
  const minVal = Math.min(...allValues);
  const maxVal = Math.max(...allValues);
  const pad = (maxVal - minVal) * 0.05;
  let yMin = Math.floor((minVal - pad) / 1000) * 1000;
  let yMax = Math.ceil((maxVal + pad) / 1000) * 1000;

  if (dataInfo.step) {
    const range = yMax - yMin;
    const remainder = range % dataInfo.step;
    if (remainder !== 0) yMax += dataInfo.step - remainder;
  }

  // stacking only for non-scatter when at least one dataset has .stack
  const isStacked = type !== 'scatter' && dataInfo.datasets.some(ds => ds.stack);

  // Build datasets w/ safe colors + optional gradient fill
  const datasets = dataInfo.datasets.map((ds) => {
    const stroke = ds.borderColor || ds.color || '#29b6f6';
    let fillColor = ds.backgroundColor || (ds.fill ? toRGBA(stroke, 0.35) : 'transparent');

    // For stacked/filled areas, create a subtle vertical gradient (fade)
    if ((ds.fill || ds.stack) && type !== 'bar' && type !== 'scatter') {
      const grad = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
      grad.addColorStop(0, toRGBA(stroke, 0.45));
      grad.addColorStop(1, toRGBA(stroke, 0.05));
      fillColor = grad;
    }

    return {
      label: ds.label,
      data: ds.data,
      borderColor: stroke,
      backgroundColor: fillColor,
      borderWidth: ds.borderWidth || 2,
      tension: ds.tension ?? 0.3,
      fill: !!(ds.fill || ds.stack),
      stack: ds.stack || undefined,
      type: ds.type || undefined,
      pointRadius: ds.pointRadius ?? (type==='scatter' ? 4 : 2),
      pointHoverRadius: ds.pointHoverRadius ?? (type==='scatter' ? 5 : 5),
      pointHitRadius: ds.pointHitRadius ?? 10,
      borderDash: ds.borderDash || undefined,
      order: ds.order || 1,
      showLine: ds.showLine
    };
  });

  // X ticks
  const labels = dataInfo.labels || [];
  const xTickOptions = {
    color: '#b0c5e8',
    callback: function(value, index) { return labels[index]; }
  };
  if (type === 'bar') {
    xTickOptions.autoSkip = false; xTickOptions.maxRotation = 45; xTickOptions.minRotation = 45;
  } else if (type !== 'scatter') {
    xTickOptions.autoSkip = true; xTickOptions.maxTicksLimit = 10;
  }

  // Watermark colour: consistent faint blue across all charts
  const watermarkColor = '#6aa3f4';

  // Base options; special-case scatter axes below
  const options = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: { mode: 'nearest', intersect: true },
    hover: { mode: 'nearest', intersect: true },
    scales: {
      x: {
        stacked: isStacked,
        ticks: xTickOptions,
        grid: { color: '#1f3a64' }
      },
      y: {
        stacked: isStacked,
        min: yMin,
        max: yMax,
        ticks: {
          color: '#b0c5e8',
          callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); },
          stepSize: dataInfo.step,
          maxTicksLimit: dataInfo.step ? Math.ceil((yMax - yMin)/dataInfo.step) + 1 : undefined
        },
        grid: { color: '#1f3a64' }
      }
    },
    plugins: {
      legend: { display: datasets.length > 1, labels: { color: '#e0e6ed' } },
      tooltip: {
        mode: 'nearest',
        intersect: true,
        callbacks: {
          label: (ctx) => {
            const label = ctx.dataset.label || '';
            const y = (ctx.parsed?.y ?? ctx.raw?.y ?? ctx.raw);
            if (typeof y === 'number') return `${label}: $${y.toLocaleString()}`;
            return label;
          }
        }
      },
      watermark: { text: 'wealthdashboard.ca', color: watermarkColor, opacity: 0.10, fontSize: 18 }
    }
  };

  // Proper axes for scatter from the start (prevents the blank-chart error)
  if (type === 'scatter') {
    options.scales.x = {
      type: 'linear',
      position: 'bottom',
      ticks: {
        color: '#b0c5e8',
        callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); },
        maxTicksLimit: 10
      },
      grid: { color: '#1f3a64' }
    };
    options.scales.y = {
      min: yMin,
      max: yMax,
      ticks: {
        color: '#b0c5e8',
        callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); }
      },
      grid: { color: '#1f3a64' }
    };
  }

  const chartInstance = new Chart(ctx, { type, data: { labels, datasets }, options });
  chartInstance.__step = dataInfo.step || null;
  return chartInstance;
}

    document.addEventListener('DOMContentLoaded', function() {
      // Build Chart.js instances for each canvas using the base (Canada) data
      incomeChartInstance = createChart('incomeChart', {
        labels: ageLabels,
        datasets: [ { label: 'Median Employment Income (Individuals)', data: baseIncome, color: '#29b6f6' } ],
        step: 5000
      }, 'line');

      // Build the income composition chart.  This stacked area chart will show the
      // breakdown of total income into employment, investment, pension and transfer
      // components.  Each dataset is initially populated with zeros; actual values
      // are computed in updateCharts() based on the selected region and age.

      compositionChartInstance = createChart('compositionChart', {
  labels: ageLabels,
  datasets: [
    {
      label: 'Employment Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#42a5f5',
      backgroundColor: 'rgba(66,165,245,0.6)',
      fill: true,
      stack: 'income'
    },
    {
      label: 'Investment Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#66bb6a',
      backgroundColor: 'rgba(102,187,106,0.6)',
      fill: true,
      stack: 'income'
    },
    {
      label: 'Pension Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#ffa726',
      backgroundColor: 'rgba(255,167,38,0.6)',
      fill: true,
      stack: 'income'
    },
    {
      label: 'Government Transfers',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#ab47bc',
      backgroundColor: 'rgba(171,71,188,0.6)',
      fill: true,
      stack: 'income'
    }
  ],
  step: 5000
}, 'line');

      // Define a zero net‑worth reference line for net worth charts. This will appear as a light blue dashed line.
      const baseZeroData = new Array(ageLabels.length).fill(0);
      const zeroLine = {
        label: 'Zero Net Worth',
        data: baseZeroData,
        color: '#4fc3f7',
        borderDash: [4,4],
        borderWidth: 1,
        pointRadius: 0
      };
      // Build the combined net worth chart (households vs individuals).  Both series
      // are shown by default; additional percentile lines can be toggled via the
      // percentile selector.  A zero net worth reference line is included.
      netWorthChartInstance = createChart('netWorthChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Median Net Worth (Households)', data: baseNetWorth, color: '#66bb6a' },
          Object.assign({}, zeroLine, { data: baseZeroData.slice() })
        ],
        step: 200000
      }, 'line');
      // Build the scatter chart for income vs net worth.  This uses the median total income
      // as the x-value and the median net worth (households) as the y-value for each age.
      scatterChartInstance = createChart('scatterChart', {
        labels: ageLabels,
        datasets: [
          {
            label: 'Income vs Net Worth',
            data: [],
            borderColor: '#66bb6a',
            backgroundColor: '#66bb6a',
            pointBackgroundColor: '#66bb6a',
            pointBorderColor: '#66bb6a',
            // Increase the base point size to improve visibility.  A larger
            // point radius and hover radius make scatter points easier to see.
            pointRadius: 5,
            pointHoverRadius: 6,
            showLine: false
          }
        ],
        // We will update the step sizes dynamically in updateCharts
        step: null
      }, 'scatter');
      // The province chart remains the same; median provincial values are used as bars.
      // Build the province bar chart. Use a default color for all bars; the
      // selected province will be highlighted via updateCharts().
      provinceChartInstance = createChart('provinceChart', {
        labels: baseProvinceLabels,
        datasets: [ { label: 'Median Net Worth', data: baseProvinceValues, backgroundColor: '#66bb6a' } ],
        step: 50000
      }, 'bar');

      // Build the provincial median income chart.  This bar chart displays
      // typical median employment income for each province using the
      // baseProvinceIncomeValues array.  Percentile lines are drawn on top
      // via updateCharts() when selected from the percentile selector.
      provinceIncomeChartInstance = createChart('provinceIncomeChart', {
        labels: baseProvinceLabels,
        datasets: [ { label: 'Median Income', data: baseProvinceIncomeValues, backgroundColor: '#42a5f5' } ],
        step: 5000
      }, 'bar');

      // Wealth Composition baseline; data is computed in updateCharts per region/unit
      wealthCompositionChartInstance = createChart('wealthCompositionChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Real Estate', data: new Array(ageLabels.length).fill(0), borderColor: '#66bb6a', backgroundColor: 'rgba(102,187,106,0.55)', fill: true, stack: 'assets' },
          { label: 'Financial Assets', data: new Array(ageLabels.length).fill(0), borderColor: '#29b6f6', backgroundColor: 'rgba(41,182,246,0.55)', fill: true, stack: 'assets' },
          { label: 'Pensions', data: new Array(ageLabels.length).fill(0), borderColor: '#ab47bc', backgroundColor: 'rgba(171,71,188,0.55)', fill: true, stack: 'assets' },
          { label: 'Debts', data: new Array(ageLabels.length).fill(0), borderColor: '#ffa726', backgroundColor: 'rgba(255,167,38,0.55)', fill: true, stack: 'debts' },
          { label: 'Net Worth', data: new Array(ageLabels.length).fill(0), color: '#66bb6a', type: 'line', pointRadius: 0, order: 999 }
        ],
        step: 200000
      }, 'line');

      // Income Percentile by Gender — line chart similar to individual income by age (placeholder ratios)
      genderIncomeChartInstance = createChart('genderIncomeChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Women (Median)', data: new Array(ageLabels.length).fill(0), color: '#42a5f5' },
          { label: 'Men (Median)', data: new Array(ageLabels.length).fill(0), color: '#1e88e5' }
        ],
        step: 5000
      }, 'line');

      // Initialize distribution charts as bar (histogram-like)
      percentileNetWorthChartInstance = createChart('percentileNetWorthChart', {
        labels: [],
        datasets: [ { label: 'Net Worth Distribution', data: [], backgroundColor: '#66bb6a' } ],
        step: null
      }, 'bar');
      percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: null };

      percentileIncomeChartInstance = createChart('percentileIncomeChart', {
        labels: [],
        datasets: [ { label: 'Income Distribution', data: [], backgroundColor: '#29bbf6' } ],
        step: null
      }, 'bar');
      percentileIncomeChartInstance.options.plugins.userVLine = { xValue: null };
      // Hook up the dropdown to update the charts when a region is selected
      const select = document.getElementById('provinceSelect');
      select.addEventListener('change', function() {
        const region = this.value;
        updateCharts(region);
      });

      // When the percentile selection changes, refresh the charts for the current region.
      const percentileSelect = document.getElementById('percentileSelect');
      percentileSelect.addEventListener('change', function() {
        const currentRegion = document.getElementById('provinceSelect').value;
        updateCharts(currentRegion);
      });
      // Unit selector: switch between Households and Individuals across all charts
      const unitSelectEl = document.getElementById('unitSelect');
      if (unitSelectEl) {
        unitSelectEl.addEventListener('change', function() {
          const region = document.getElementById('provinceSelect').value;
          updateCharts(region);
        });
      }
      // Initialize with Canada selected
      updateCharts('Canada');

      // Attach event listeners for user comparison and reset
      document.getElementById('compareBtn').addEventListener('click', function() {
        plotUserData();
      });
      document.getElementById('resetBtn').addEventListener('click', function() {
        resetUserData();
      });
    });

    // Flags and storage for user input comparison
    let userActive = false;
    let userAgeVal, userIncomeVal, userNetWorthVal;

    /**
     * Handle plotting the user's input across all charts. Validates input
     * values and stores them in global variables. If validation fails,
     * notifies the user.
     */
    function plotUserData() {
      const ageInput = parseInt(document.getElementById('userAge').value, 10);
      const incomeInput = parseFloat(document.getElementById('userIncome').value);
      const netWorthInput = parseFloat(document.getElementById('userNetWorth').value);
      if (!ageInput || ageInput < 18 || ageInput > 100 || isNaN(incomeInput) || isNaN(netWorthInput)) {
        alert('Please enter a valid age between 18 and 100, and numeric values for income and net worth.');
        return;
      }
      if (incomeInput > 1000000) {
        alert('Please enter an income of $1,000,000 or less.');
        return;
      }
      if (netWorthInput > 100000000) {
        alert('Please enter a net worth of $100,000,000 or less.');
        return;
      }
      userActive = true;
      userAgeVal = ageInput;
      userIncomeVal = incomeInput;
      userNetWorthVal = netWorthInput;
      // After storing the user values, rescale all charts to include the new marker and redraw
      const region = document.getElementById('provinceSelect').value;
      updateCharts(region);
    }

    /**
     * Add or update the user's markers on all charts using the stored values.
     */
    function addUserMarkers() {
      if (!userActive) return;
      const index = Math.max(0, Math.min(userAgeVal - 18, ageLabels.length - 1));
      // Add marker to each line chart
      addUserMarkerToChart(incomeChartInstance, userIncomeVal, index, 'You');
      // Place a marker on the income composition chart representing the user's total income
      addUserMarkerToChart(compositionChartInstance, userIncomeVal, index, 'You');
      addUserMarkerToChart(netWorthChartInstance, userNetWorthVal, index, 'You');
      addUserLineToBarChart(provinceChartInstance, userNetWorthVal, 'You');
      // Add a horizontal line on the provincial income chart for the user's income
      addUserLineToBarChart(provinceIncomeChartInstance, userIncomeVal, 'You');
      // Add a red "You" point to the scatter chart (income vs net worth)
      addUserPointToScatter(scatterChartInstance, userIncomeVal, userNetWorthVal, 'You');
      // Update vertical dashed user percentile lines on percentile charts
      try {
        const region = document.getElementById('provinceSelect').value;
        // Rebuild percentile curves for current region
        const provinceIndex = baseProvinceLabels.indexOf(region);
        const unitEl = document.getElementById('unitSelect');
        const unit = unitEl ? unitEl.value : 'households';
        const HOUSEHOLD_INCOME_MULTIPLIER = 1.6;
        const nationalMedianNetWorthHousehold = 652286;
        const nationalMedianIncomeIndividual = baseIncome[22];
        const nationalMedianNetWorth = (unit === 'households') ? nationalMedianNetWorthHousehold : Math.round(nationalMedianNetWorthHousehold * 0.6);
        const nationalMedianIncome = (unit === 'households') ? Math.round(nationalMedianIncomeIndividual * HOUSEHOLD_INCOME_MULTIPLIER) : nationalMedianIncomeIndividual;
        const regionMedianNetWorth = (region === 'Canada' || provinceIndex === -1) ? nationalMedianNetWorth : (unit==='households'? baseProvinceValues[provinceIndex] : Math.round(baseProvinceValues[provinceIndex]*0.6));
        const regionMedianIncome = Math.round((incomeRatios[region] || 1) * nationalMedianIncome);
        // Estimate parameters and compute user's percentile via normal CDF
        const z = 1.2815515655446004;
        const sNet = ((regionMedianNetWorth - regionMedianNetWorth*0.10)/z + (regionMedianNetWorth*1.80 - regionMedianNetWorth)/z)/2;
        const sInc = ((regionMedianIncome - regionMedianIncome*0.22)/z + (regionMedianIncome*2.44 - regionMedianIncome)/z)/2;
        function erf(x){ const sign=x<0?-1:1; x=Math.abs(x); const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911; const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x); return sign*y; }
        function normCdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
        // For histogram view, show a vertical line at user's value with percentile labels
        const netPct = Math.max(0, Math.min(100, 100*normCdf((userNetWorthVal - regionMedianNetWorth)/Math.max(1,sNet))));
        const incPct = Math.max(0, Math.min(100, 100*normCdf((userIncomeVal - regionMedianIncome)/Math.max(1,sInc))));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: userNetWorthVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(netPct)} percentile` };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: userIncomeVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(incPct)} percentile` };
        percentileNetWorthChartInstance.update();
        percentileIncomeChartInstance.update();
      } catch (e) { /* no-op */ }
    }

    /**
     * Add or update a single-point marker on a line chart. The marker is
     * represented as a dataset with mostly null values except for the
     * specified index where the user value is placed.
     * @param {Chart} chart The Chart.js instance
     * @param {number} value The y-value to plot
     * @param {number} index The index corresponding to the user's age
     * @param {string} label The label used to identify the user's dataset
     */
    function addUserMarkerToChart(chart, value, index, label) {
      if (!chart) return;
      const length = chart.data.labels.length;
      const dataArray = new Array(length).fill(null);
      dataArray[index] = value;
      const existingIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const markerDataset = {
        label: label,
        data: dataArray,
        borderColor: 'rgba(244,67,54,1)',
        backgroundColor: 'rgba(244,67,54,1)',
        pointRadius: 5,
        pointHoverRadius: 6,
        fill: false,
        showLine: false,
        borderWidth: 0,
        order: 9999,
        clip: false
      };
      if (existingIndex >= 0) {
        chart.data.datasets[existingIndex].data = dataArray;
      } else {
        chart.data.datasets.push(markerDataset);
      }
      // After placing the user marker, dynamically expand the y-axis
      // so that the user value is always visible. We recompute the axis
      // bounds based on all non-user datasets and the user value. This
      // prevents the chart from being clipped when the comparison value
      // exceeds the existing range.
      const step = chart.__step || null;
      let allVals = [];
      chart.data.datasets.forEach(ds => {
        if (ds.label !== label) {
          ds.data.forEach(v => {
            if (typeof v === 'number' && !isNaN(v)) allVals.push(v);
          });
        }
      });
      // Include the user-provided value in the axis computation
      allVals.push(value);
      // Compute new axis bounds
      let axis = computeAxis(allVals, step);
      // For income charts (employment and total), clamp minimum at zero
      // Clamp the y-axis minimum at zero for income charts (employment and composition)
      if (chart === incomeChartInstance || chart === compositionChartInstance) {
        axis.min = 0;
      }
      chart.options.scales.y.min = axis.min;
      chart.options.scales.y.max = axis.max;
      chart.update();
    }

    /**
     * Add or update a horizontal dashed line on the bar chart representing
     * the user's net worth across all provinces.
     * @param {Chart} chart The bar chart instance
     * @param {number} value The y-value for the horizontal line
     * @param {string} label The label used to identify the user's dataset
     */
    function addUserLineToBarChart(chart, value, label) {
      if (!chart) return;
      const dataArray = new Array(chart.data.labels.length).fill(value);
      const existingIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const lineDataset = {
        label: label,
        data: dataArray,
        type: 'line',
        borderColor: 'rgba(244,67,54,1)',
        borderDash: [6,3],
        borderWidth: 3,
        fill: false,
        pointRadius: 0,
        // Ensure the user line is drawn in front of bars and percentile lines
        // Draw the user line on top of all other datasets.  A high order value
        // ensures it appears in front of the bar series and percentile lines.
        order: 9999,
        // Avoid being clipped beneath chart area edges
        clip: false
      };
      if (existingIndex >= 0) {
        chart.data.datasets[existingIndex].data = dataArray;
      } else {
        chart.data.datasets.push(lineDataset);
      }
      // Recalculate the bar chart axis to ensure the user's line is visible.
      // Use the base province values plus the user value. Since the bar chart
      // step size is stored on the chart instance, we can reuse it here.
      let provinceVals = baseProvinceValues.slice();
      provinceVals.push(value);
      const step = chart.__step || 50000;
      const axis = computeAxis(provinceVals, step);
      chart.options.scales.y.min = axis.min;
      chart.options.scales.y.max = axis.max;
      chart.update();
    }

    /**
     * Reset and remove all user markers from every chart.
     */
    function resetUserData() {
      userActive = false;
      removeUserDataset(incomeChartInstance, 'You');
      removeUserDataset(compositionChartInstance, 'You');
      removeUserDataset(netWorthChartInstance, 'You');
      removeUserDataset(provinceChartInstance, 'You');
      removeUserDataset(provinceIncomeChartInstance, 'You');
      removeUserDataset(scatterChartInstance, 'You');
      // Clear percentile chart vertical lines
      if (percentileNetWorthChartInstance?.options?.plugins) {
        percentileNetWorthChartInstance.options.plugins.userVLine = { index: null };
        percentileNetWorthChartInstance.update();
      }
      if (percentileIncomeChartInstance?.options?.plugins) {
        percentileIncomeChartInstance.options.plugins.userVLine = { index: null };
        percentileIncomeChartInstance.update();
      }
      // Rescale charts back to default ranges after removing user data
      const region = document.getElementById('provinceSelect').value;
      updateCharts(region);
    }

    /**
     * Helper to remove a dataset with the given label from a chart.
     * @param {Chart} chart The chart instance
     * @param {string} label The label identifying the dataset to remove
     */
    function removeUserDataset(chart, label) {
      if (!chart) return;
      const index = chart.data.datasets.findIndex(ds => ds.label === label);
      if (index >= 0) {
        chart.data.datasets.splice(index, 1);
        chart.update();
      }
    }

    /**
     * Add or update the user's point on the scatter chart (income vs net worth).
     * Ensures the axes include the user's point and draws it prominently in red.
     * @param {Chart} chart The scatter chart instance
     * @param {number} incomeX The user's income (x value)
     * @param {number} netWorthY The user's net worth (y value)
     * @param {string} label Dataset label (e.g., 'You')
     */
    function addUserPointToScatter(chart, incomeX, netWorthY, label) {
      if (!chart) return;
      const userDsIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const userDs = {
        label: label,
        type: 'scatter',
        data: [ { x: incomeX, y: netWorthY } ],
        borderColor: 'rgba(244,67,54,1)',
        backgroundColor: 'rgba(244,67,54,1)',
        pointBackgroundColor: 'rgba(244,67,54,1)',
        pointBorderColor: 'rgba(244,67,54,1)',
        pointRadius: 6,
        pointHoverRadius: 7,
        showLine: false,
        order: 9999,
        clip: false
      };
      if (userDsIndex >= 0) {
        chart.data.datasets[userDsIndex] = Object.assign(chart.data.datasets[userDsIndex], userDs);
      } else {
        chart.data.datasets.push(userDs);
      }

      // Recompute axes to include the user's point alongside the base series
      const baseData = (chart.data.datasets[0] && Array.isArray(chart.data.datasets[0].data)) ? chart.data.datasets[0].data : [];
      const xVals = baseData.map(p => p.x);
      const yVals = baseData.map(p => p.y);
      xVals.push(incomeX);
      yVals.push(netWorthY);
      const xAxis = computeAxis(xVals, 5000);
      const yAxis = computeAxis(yVals, 200000);
      if (!chart.options.scales) chart.options.scales = {};
      if (!chart.options.scales.x) chart.options.scales.x = { type: 'linear', position: 'bottom' };
      if (!chart.options.scales.y) chart.options.scales.y = {};
      chart.options.scales.x.min = Math.max(0, xAxis.min);
      chart.options.scales.x.max = xAxis.max;
      chart.options.scales.y.min = yAxis.min;
      chart.options.scales.y.max = yAxis.max;
      chart.update();
    }
  </script>
</body>
</html>
