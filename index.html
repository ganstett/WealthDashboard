<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Canadian Wealth &amp; Income Dashboard</title>
  <!-- Open Graph tags make the site attractive when shared on social media -->
  <meta property="og:title" content="Canadian Wealth &amp; Income Dashboard" />
  <meta property="og:description" content="Explore detailed charts of Canadian median income, net worth by age, wealth distribution and more. Built using multiple data sources for the most comprehensive view available." />
  <meta property="og:image" content="https://example.com/share-image.png" />
  <meta property="og:type" content="website" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    /* Info icon and tooltip */
    .info-icon { display:inline-block; margin-left:8px; color:#9fb6c8; cursor:default; position:relative; font-size:0.95rem; outline:none; }
    .info-icon .info-tooltip { visibility:hidden; opacity:0; transition:opacity .15s ease; position:absolute; left:50%; transform:translateX(-50%); top:calc(100% + 8px); background: rgba(7,18,39,0.98); color: #e0e6ed; padding:8px 10px; border-radius:8px; max-width:320px; font-size:0.85rem; box-shadow: 0 6px 18px rgba(0,0,0,0.6); z-index:9999; text-align:left; pointer-events:none; }
    .info-icon:hover .info-tooltip, .info-icon:focus .info-tooltip, .info-icon.focused .info-tooltip { visibility:visible; opacity:1; pointer-events:auto; }
    .info-tooltip::after { content: ''; position:absolute; top:-6px; left:50%; transform:translateX(-50%); border-width:6px; border-style:solid; border-color: transparent transparent rgba(7,18,39,0.98) transparent; }

    /* Snapshot button */
    .snapshot-btn { display:inline-block; margin:12px 0 0 0; padding:6px 12px; font-size:0.85rem; border-radius:999px; border:1px solid rgba(255,255,255,0.06); background: rgba(7,18,39,0.6); color:#dbefff; cursor:pointer; }
    .snapshot-btn:hover { box-shadow: 0 6px 18px rgba(0,191,165,0.08); }

    /* Footer */
    footer.site-footer { margin-top:28px; padding:18px 0; text-align:center; color:#9fb6c8; font-size:0.85rem; border-top:1px solid rgba(255,255,255,0.03); }
    footer.site-footer a { color:#9fb6c8; }

    /* Global styles */
    body {
      background: #0a1931;
      color: #e0e6ed;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
    }
    html { scroll-behavior: smooth; }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      color: #ffffff;
      text-align: center;
    }
    p.lead {
      font-size: 1.1rem;
      line-height: 1.6;
      text-align: center;
      margin: 0 auto 40px;
      max-width: 800px;
    }
    /* Chart card styling */
    .charts-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      align-items: start;
      box-sizing: border-box;
      width: 100%;
    }
    .chart-card {
      background: #13294b;
      border-radius: 10px;
      padding: 22px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.18);
    }
    .chart-card h3 {
      margin: 0 0 10px;
      font-size: 1.4rem;
      color: #00bfa5;
    }
    .chart-container {
      position: relative;
      height: 400px;
      width: 100%;
    }
    /* Footnotes */
    .footnotes {
      margin-top: 40px;
      font-size: 0.8rem;
      line-height: 1.4;
      color: #8aa2c1;
    }
    .footnotes a {
      color: #6aa3f4;
    }
    .source-box {
      margin-top: 12px;
      margin-bottom: 22px;
      /* Use a slightly translucent, lower-contrast background so the
         details panels blend with the chart cards and draw less attention. */
      background: rgba(13,27,42,0.55);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.03);
      transition: all 0.25s ease;
    }
    .source-box summary {
      cursor: pointer;
      font-weight: 600;
      /* Make the summary text less bright so it doesn't stand out as much */
      color: #9fb6c8;
      list-style: none;
      /* Slightly smaller summary text so dropdown headers are less prominent */
      font-size: 0.9rem;
    }
    .source-box summary::marker {
      display: none;
    }
    .source-box summary::-webkit-details-marker {
      display: none;
    }
    .source-box summary::after {
      content: '▾';
      float: right;
      font-size: 0.9rem;
      /* Fainter arrow colour */
      color: rgba(156,180,204,0.65);
      transition: transform 0.2s ease;
    }
    .source-box[open] summary::after {
      transform: rotate(-180deg);
    }
    .source-content {
      margin-top: 12px;
      /* Slightly muted paragraph colour so content reads but isn't visually loud */
      color: #bfcfe0;
      /* Smaller body text inside the dropdown to de-emphasize details */
      font-size: 0.8rem;
      border-top: 1px solid rgba(255, 255, 255, 0.04);
      padding-top: 12px;
    }
    /* Tiny download button placed under each chart */
    .download-btn {
      display: inline-block;
      margin: 8px 0 12px 8px;
      padding: 6px 12px;
      font-size: 0.8rem;
      border-radius: 999px;
      border: none;
      background: rgba(255,255,255,0.06);
      color: #dbefff;
      cursor: pointer;
    }
    .download-btn:hover {
      background: rgba(255,255,255,0.10);
    }
    .source-content ul {
      margin-top: 4px;
      padding-left: 1.2rem;
    }
    /* Top controls: compact, two-row responsive layout */
    .top-controls {
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      margin-bottom: 18px;
    }
    .controls-row, .projection-row {
      display:flex;
      gap:12px;
      width:100%;
      justify-content:center;
      flex-wrap:wrap;
      align-items:center;
    }
    .control-group { display:flex; gap:8px; align-items:center; }
    .control-group label { font-weight:600; color:#d7eaf9; }
    .control-group input[type="number"], .control-group select {
      padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:#071229; color:#e6f4ff;
      box-shadow: none; outline: none; min-width:60px;
    }
    .btn-primary { padding:8px 12px; border-radius:6px; border:none; cursor:pointer; }
    .btn-compare { background:#ef5350; color:#fff; }
    .btn-reset { background:#455a64; color:#fff; }
    .btn-project { background:#ef5350; color:#fff; }
    .insight-panel { width:100%; }
    @media (min-width:880px) {
      .controls-row { justify-content:space-between; }
      .controls-left, .controls-center, .controls-right { flex:1; }
      .controls-center { justify-content:center; display:flex; }
      .controls-right { display:flex; justify-content:flex-end; }
      .projection-row { justify-content:space-between; }
    }
    /* Profile card and result tiles */
    .profile-card {
      display:flex; gap:16px; align-items:center; width:100%; max-width:100%; background: #071127; padding:14px; border-radius:10px; border:1px solid rgba(255,255,255,0.04);
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    .profile-item { display:flex; gap:8px; align-items:center; color:#d7eaf9; }
    .profile-item label { font-weight:600; color:#cfe8ff; margin-right:6px; }
    .profile-item input, .profile-item select { padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:#071229; color:#e6f4ff; }
    .result-tiles { display:flex; gap:12px; margin-left:auto; }
    .result-tile { background:#0b2438; padding:10px 14px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); min-width:160px; text-align:center; }
    .tile-title { font-size:0.85rem; color:#9fc9d9; }
    .tile-value { font-size:1.3rem; font-weight:700; color:#e6f4ff; margin-top:6px; }
    .tile-sub { font-size:0.75rem; color:#9fb6c8; margin-top:6px; }

    /* Projection section */
    .projection-section { margin-top:12px; width:100%; max-width:100%; background:#071227; padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.04); }
    .proj-cards { display:flex; gap:12px; margin-top:12px; }
    .proj-card { flex:1; background:#071a2b; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); text-align:center; }
    .proj-card .label { color:#9fb6c8; font-size:0.85rem; }
    .proj-card .value { color:#e6f4ff; font-weight:700; font-size:1.25rem; margin-top:6px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Canadian Wealth &amp; Income Dashboard</h1>
    <p class="lead">
      Welcome! This dashboard aggregates Canadian income and net worth data from several
      credible sources. Use it to see how your finances compare with others by age
      group, province and percentile. All figures are in Canadian dollars.
    </p>

    <!-- Profile card: region, unit, age, income, net worth -->
    <section id="section-inputs">
    <div class="profile-card">
      <div class="profile-item">
        <label for="provinceSelect">Region</label>
        <select id="provinceSelect">
          <option value="Canada">Canada</option>
          <option value="Newfoundland & Labrador">Newfoundland & Labrador</option>
          <option value="Prince Edward Island">Prince Edward Island</option>
          <option value="Nova Scotia">Nova Scotia</option>
          <option value="New Brunswick">New Brunswick</option>
          <option value="Quebec">Quebec</option>
          <option value="Ontario">Ontario</option>
          <option value="Manitoba">Manitoba</option>
          <option value="Saskatchewan">Saskatchewan</option>
          <option value="Alberta">Alberta</option>
          <option value="British Columbia">British Columbia</option>
        </select>
      </div>
      <div class="profile-item">
        <label for="unitSelect">View as</label>
        <select id="unitSelect" style="min-width:140px;">
          <option value="households" selected>Households</option>
          <option value="individuals">Individuals</option>
        </select>
      </div>
      <div class="profile-item">
        <label for="userAge">Age</label>
        <input id="userAge" type="number" min="18" max="100" style="width:80px;" />
      </div>
      <div class="profile-item">
        <label for="userIncome">Income</label>
        <input id="userIncome" type="number" step="1000" max="1000000" style="min-width:140px;" />
      </div>
      <div class="profile-item">
        <label for="userNetWorth">Net worth</label>
        <input id="userNetWorth" type="number" step="1000" max="100000000" style="min-width:160px;" />
      </div>
      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <button id="compareBtn" class="btn-primary btn-compare">Compare</button>
        <button id="resetBtn" class="btn-primary btn-reset">Reset</button>
      </div>
    </div>
    </section>

    <!-- Percentile tiles — separate section placed under inputs -->
    <section id="section-percentiles" aria-live="polite">
      <div class="result-tiles" id="resultTiles" style="display:none; margin-top:12px;">
        <div class="result-tile" id="incomePctTile">
          <div class="tile-title">Income percentile</div>
          <div class="tile-value">—</div>
          <div class="tile-sub">of peers</div>
        </div>
        <div class="result-tile" id="netPctTile">
          <div class="tile-title">Net worth percentile</div>
          <div class="tile-value">—</div>
          <div class="tile-sub">of peers</div>
        </div>
      </div>
      <div style="margin-top:10px;">
        <button id="snapshotBtn" class="snapshot-btn">Download Your Snapshot</button>
      </div>
    </section>

    <!-- Future Net Worth Projection section -->
    <section id="section-projections">
    <div class="projection-section" id="projectionSection" style="display:none;">
      <div style="display:flex; align-items:center; gap:12px; justify-content:space-between;">
        <div style="font-weight:700; color:#bfe0ff;">Future Net Worth Projection</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <label for="savingsRate" style="color:#9fb6c8;">Savings rate (% of gross income)</label>
          <input id="savingsRate" type="number" min="0" max="100" step="0.1" style="width:90px;" />
          <label for="targetAge" style="color:#9fb6c8; margin-left:6px;">Target age</label>
          <input id="targetAge" type="number" min="18" max="100" value="65" style="width:60px;" />
          <button id="projectBtn" class="btn-primary btn-project" style="margin-left:8px;">Project</button>
        </div>
      </div>
      <div class="proj-cards">
        <div class="proj-card" id="projCard"><div class="label">Projected net worth</div><div class="value">—</div></div>
        <div class="proj-card" id="median65Card"><div class="label">Projected median at target</div><div class="value">—</div></div>
        <div class="proj-card" id="requiredRateCard"><div class="label">Required savings rate</div><div class="value">—</div></div>
      </div>
      <details id="projectionAssumptions" class="source-box" style="width:100%; margin-top:12px;">
        <summary>Projection Assumptions & Formula</summary>
        <div class="source-content">
          <p>Percentile baselines (median, 75th, 90th) are 2025 values and are projected forward to the year you reach the target age using a constant real growth rate of <strong>3.5% per year</strong>:</p>
          <p style="font-family:monospace;">futurePercentile = currentPercentile * (1 + 0.035)^(yearsToTarget)</p>
          <p><em>yearsToTarget</em> = target age − your current age. These projections assume steady real growth and do not model shocks, taxes, or behavioural changes; the savings projection uses its own return assumption.</p>
        </div>
      </details>
    </div>
    </section>
    <section id="section-income-charts">
    <div class="charts-grid">
      <!-- Median Income Chart (2025 estimate) -->
      <div class="chart-card">
        <h3 id="incomeTitle">Estimated Median Employment Income by Age (Individuals, 2025)
          <span class="info-icon" tabindex="0">
            ℹ️
            <span class="info-tooltip">Shows inflation-adjusted median employment income by age (2025). Scales by province and by household vs individual view. Percentiles (10th, 25th, median, 75th, 90th) are displayed where applicable.</span>
          </span>
        </h3>
        <div class="chart-container">
          <canvas id="incomeChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> The line tracks inflation-adjusted median employment income for Canadians age 18–80 and applies the selected province/unit so local wages can be compared to the national curve.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Canadian Income Survey (Table 11-10-0190-01)</li>
              <li>Canada Revenue Agency T1 tax-filer statistics (wage growth factors)</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>2022 medians were advanced to 2025 using CRA wage growth trends and Bank of Canada CPI guidance to keep results in real dollars.</li>
              <li>Provincial scaling multiplies Statistics Canada income ratios while annual ages are interpolated between published 5-year brackets.</li>
              <li><strong>Percentiles:</strong> Five percentile curves (10th, 25th, 50th/median, 75th, 90th) are displayed. Percentile curves are derived from StatCan percentile anchors and proportional scaling; the 10th and 90th percentiles are interpolated from published anchors to form smooth tails.</li>
              <li>All curves are inflation-adjusted to 2025 dollars.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Income composition breakdown chart (2025) -->
      <div class="chart-card">
        <h3 id="compositionTitle">Income Composition Breakdown by Age (2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Stacked area showing employment, investment, pension and transfer components of total income by age. Values scale with selected province and household/individual view.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="compositionChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> Stacked bands show how the mix of employment, investment, pension and transfer income evolves across the life cycle for the selected geography.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Canadian Income Survey (Table 11-10-0190-01)</li>
              <li>Statistics Canada — Survey of Household Spending (Table 11-10-0223-01) & CRA pension benefit tables</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Component shares follow CIS income-composition profiles and gradually shift toward pensions/transfers after age 55.</li>
              <li>Total income inherits the same provincial scaling and unit toggle as the income chart; interpolation fills gaps between anchor ages.</li>
            </ul>
          </div>
        </details>
      </div>

      </div>
    </section>

    <section id="section-networth-charts">
      <div class="charts-grid">
      <!-- Median Net Worth Chart (2025 estimate) -->
      <div class="chart-card">
        <h3 id="netWorthTitle">Estimated Median Net Worth by Age (Households, 2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Shows inflation-adjusted median net worth by age (2025). Scales by province and household vs individual view. Percentiles shown: 10th, 25th, median, 75th, 90th.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="netWorthChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> The curve displays projected 2025 median net worth for households or individuals, highlighting accumulation during working years and drawdown in retirement.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Survey of Financial Security (Table 11-10-0016-01)</li>
              <li>Bank of Canada inflation outlook (deflators for 2023–2025)</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>2019 and 2023 SFS medians were converted to compound annual growth rates and extended two more years to 2025.</li>
              <li>Interpolation between anchor ages captures annual movements while retirement decumulation follows SFS withdrawal patterns.</li>
              <li><strong>Percentiles:</strong> Five percentile curves (10th, 25th, 50th/median, 75th, 90th) are displayed. The 10th and 90th percentile tails are interpolated from SFS anchors to produce smooth lower/upper whiskers for the age curve.</li>
              <li>All values and percentile curves are inflation-adjusted to 2025 dollars.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Income vs Net Worth Scatter Plot (2025) -->
      <div class="chart-card">
        <h3 id="scatterTitle">Income vs Net Worth by Age (2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Scatter pairs median total income with median net worth at each age to illustrate wealth accumulation. Points are coloured by age; only median series is plotted.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="scatterChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> Each dot pairs the median total income with the median net worth at a given age to show how higher earnings translate into wealth over time.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Canadian Income Survey (Table 11-10-0190-01)</li>
              <li>Statistics Canada — Survey of Financial Security (Table 11-10-0016-01)</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Total income blends employment pay with investment, CPP/QPP and transfer medians derived from CIS percentiles.</li>
              <li>Net-worth values share the same inflation adjustments and provincial ratios as the dedicated wealth chart.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Net Worth Distribution (Histogram) -->
      <div class="chart-card">
        <h3 id="percentileNetWorthTitle">Net Worth Distribution (Histogram, 2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Histogram approximating the distribution of net worth using SFS percentile anchors mapped to a log-normal curve and sampled into bins for the selected province and unit (2025).</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="percentileNetWorthChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> Histogram bins approximate the probability distribution of household net worth for the selected province and unit.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Survey of Financial Security (Table 11-10-0016-01)</li>
              <li>Bank of Canada CPI (inflation adjustments)</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>SFS percentile anchors (10th–99th) are mapped to a log-normal curve that is sampled into 30 equal-width bins.</li>
              <li>Provincial ratios and unit toggles rescale the mean and standard deviation before rendering the histogram.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Income Distribution (Histogram) -->
      <div class="chart-card">
        <h3 id="percentileIncomeTitle">Income Distribution (Histogram, 2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Histogram approximating the distribution of employment income using CIS percentile anchors mapped to a log-normal curve and sampled into bins for the selected province and unit (2025).</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="percentileIncomeChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> This histogram estimates the probability distribution of annual employment income for the chosen geography.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Canadian Income Survey (Table 11-10-0190-01)</li>
              <li>CRA T1 Family File percentile tables</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>CIS percentile ratios seed a log-normal curve that is sampled into bins to represent the 2025 distribution.</li>
              <li>Household scaling multiplies the individual income curve by the CRA-observed household-to-individual median ratio.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Wealth Composition by Age (stacked area) -->
      <div class="chart-card">
        <h3 id="wealthCompositionTitle">Wealth Composition by Age (2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Stacked areas showing asset-class composition (real estate, financial, pensions) and debts by age; net worth plotted as a line. Scales by province and unit.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="wealthCompositionChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> Stacked areas show how real estate, financial assets, pensions and debt typically evolve with age along with the resulting net worth line.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Survey of Financial Security (Table 11-10-0016-01)</li>
              <li>CMHC & Bank of Canada credit market statistics</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Asset/liability shares mirror SFS asset-class totals, while CMHC/BoC data anchor mortgage and consumer debt levels.</li>
              <li>Values are rescaled for households vs individuals and smoothed between anchor ages through interpolation.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Income Percentile by Gender -->
      <div class="chart-card">
        <h3 id="genderIncomeTitle">Income Percentile by Gender (2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Compares median employment income by age for women vs men using CIS sex-disaggregated medians and province/unit scaling.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="genderIncomeChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> Compares median employment income by age for women versus men, illustrating the persistent gender pay gap.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Canadian Income Survey (Table 11-10-0190-01, sex disaggregation)</li>
              <li>CRA T1 tax-filer statistics (gender gap benchmarks)</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>A female-to-male median ratio of 0.88 is derived from the latest CIS release and applied to the income curve.</li>
              <li>Regional scaling and household toggles mirror the main income chart so comparisons remain consistent.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Projected Median Net Worth by Province (2025) -->
      <div class="chart-card">
        <h3 id="provinceTitle">Projected Median Net Worth by Province (2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Bars show projected 2025 median net worth by province. Vertical whiskers represent 10th–90th percentiles computed from unit-aware medians.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="provinceChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> Bars display projected 2025 median household net worth for each province with optional percentile overlays for context.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Survey of Financial Security (Table 11-10-0016-01, provincial detail)</li>
              <li>Bank of Canada CPI & provincial statistical agencies (growth factors)</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>2019 and 2023 provincial medians were converted to CAGRs and projected to 2025 in constant dollars.</li>
              <li>Percentile bands apply the same SFS ratios (10th–99th) to each province’s projected median. When viewing "Individuals" the chart scales the household medians to an approximate individual series (see Methods).</li>
              <li><strong>Whiskers:</strong> For province charts that show whiskers, vertical whisker lines represent the 10th–90th percentile range and are drawn over the median bars for context. Whiskers are computed from the unit-aware median series so they match the displayed bars.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Median Income by Province (2025) -->
      <div class="chart-card">
        <h3 id="provinceIncomeTitle">Median Income by Province (2025)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Median employment income by province (representative age 40 value), scaled by province ratios. Whiskers show 10th–90th percentile income ranges.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="provinceIncomeChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> Shows how provincial median employment income and optional percentile bands compare once scaled to common Canadian dollars.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Canadian Income Survey (Table 11-10-0190-01, provincial medians)</li>
              <li>CRA T1 Family File percentile tables</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Median income at age 40 is scaled by Statistics Canada’s provincial ratios and household toggle if selected.</li>
              <li>Percentile bands use CRA-derived multipliers (10th–99th) applied uniformly to each province.</li>
              <li><strong>Whiskers:</strong> For province charts that show whiskers, vertical whisker lines represent the 10th–90th percentile range and are drawn over the median bars for context.</li>
            </ul>
          </div>
        </details>
      </div>

      <!-- Net Discretionary Income by Province -->
      <div class="chart-card">
        <h3 id="provinceDiscretionaryTitle">Net Discretionary Income by Province (Income – Cost of Living)
          <span class="info-icon" tabindex="0">ℹ️<span class="info-tooltip">Estimated median income minus average expenditures by province (2025). Uses unit-aware income and spending estimates; whiskers show percentile discretionary ranges.</span></span>
        </h3>
        <div class="chart-container">
          <canvas id="provinceDiscretionaryChart"></canvas>
        </div>
        <details class="source-box">
          <summary>Logic, Sources and Methods</summary>
          <div class="source-content">
            <p><strong>Logic:</strong> Bars show how much of the median household income remains after covering average annual household expenditures in each province.</p>

            <p><strong>Sources:</strong></p>
            <ul>
              <li>Statistics Canada — Canadian Income Survey (Table 11-10-0190-01, household median income)</li>
              <li>Statistics Canada — Household Spending Survey (Table 11-10-0223-01)</li>
            </ul>

            <p><strong>Methods:</strong></p>
            <ul>
              <li>Household income is derived from CIS medians scaled by provincial income ratios and household size adjustments.</li>
              <li>Average expenditure reflects 2022 SHS data indexed to 2025 using Bank of Canada CPI; the computeDiscretionary function subtracts costs from income.</li>
              <li><strong>Whiskers:</strong> For province charts that show whiskers, vertical whisker lines represent the 10th–90th percentile range and are drawn over the median bars for context.</li>
            </ul>
          </div>
        </details>
      </div>
      </div>
    </section>
    <!-- About / Sources -->
    <section id="section-about">
      <div class="footnotes" style="margin-bottom:8px;">
        <h2 style="margin-top:0; color:#bfe0ff;">About & Sources</h2>
        <p>This dashboard projects and compares Canadian income and net worth by age and province using publicly available Statistics Canada and CRA percentile anchors, smoothed and projected to 2025. Charts are interactive and can be downloaded as PNG for reporting or personal analysis.</p>
      </div>
    </section>

    <!-- Footnotes Section -->
    <div class="footnotes">
      <p><strong>Sources</strong>:</p>
      <ol>
        <li>Statistics Canada - Survey of Financial Security (Table 11-10-0016-01) for median net worth, provincial ratios and asset-class composition.</li>
        <li>Statistics Canada - Canadian Income Survey (Table 11-10-0190-01) for income by age, percentile, gender and province.</li>
        <li>Statistics Canada - Survey of Household Spending (Table 11-10-0223-01) for provincial expenditure baselines in the cost-of-living analysis.</li>
        <li>Canada Revenue Agency - T1 tax-filer statistics for percentile multipliers, pension income benchmarks and gender pay gap ratios.</li>
        <li>Bank of Canada - Monetary Policy Report CPI projections (2023-2025) for inflation adjustments.</li>
        <li>Canada Mortgage and Housing Corporation plus Bank of Canada credit market statistics for household debt anchors.</li>
      </ol>
    </div>
    <!-- Methods Section -->
    <div class="footnotes" style="margin-top: 20px;">
      <p><strong>Methods</strong>:</p>
      <p>
        To produce age-specific estimates for 2025, the most recent public data were smoothed
        and projected using straightforward calculations:
              <li><strong>Whiskers:</strong> For province charts that show whiskers, vertical whisker lines represent the 10th–90th percentile range and are drawn over the median bars for context.</li>
              <li>When switching between <em>Households</em> and <em>Individuals</em>, the chart scales incomes and adjusts spending estimates (individuals approximated at ~60% of household levels) so the discretionary values reflect the selected view.</li>
      <ul>
        <li><strong>Median net worth by age:</strong> Statistics Canada's 2019 and 2023 Survey of Financial Security medians were converted to compound annual growth rates for each age bracket, advanced to 2025 in constant dollars, and interpolated between anchor ages (30-80). Negative starting points reflect observed debt levels for younger households.</li>
        <li><strong>Median income by age:</strong> Canadian Income Survey 2022 medians were trended forward by CRA-observed wage growth (~3% annually) and adjusted for Bank of Canada CPI. Provincial income ratios rescale the curve, and the household toggle multiplies the individual series by the CRA-derived 1.6 factor.</li>
        <li><strong>Total income &amp; composition:</strong> Employment, investment, pension and transfer components use CIS cross-tabs plus CRA pension/OAS tables; shares gradually shift from wages to pensions and transfers after age 55 while keeping totals aligned with the scaled income curve.</li>
        <li><strong>Percentiles &amp; histograms:</strong> CIS and SFS percentile anchors (10th-99th) are mapped to log-normal curves to generate percentile lines and histogram bins, with CRA percentile multipliers covering the tails.</li>
        <li><strong>Gender and household scaling:</strong> The 0.88 female-to-male median ratio comes from the latest CIS release and is applied to the income curve so the gender chart matches official data.</li>
        <li><strong>Provincial projections:</strong> SFS provincial medians define wealth ratios, and CIS provincial ratios drive incomes. Bank of Canada CPI keeps all values in 2025 dollars.</li>
        <li><strong>Net discretionary income:</strong> Household income uses CIS medians scaled by provincial ratios, while average spending is sourced from the Survey of Household Spending and indexed to 2025. The computeDiscretionary function subtracts spending from income to populate the bars.</li>
        <li><strong>Smoothing &amp; rounding:</strong> All series are linearly interpolated between observed ages, rounded to the nearest thousand dollars, and share the same axis formatting for readability.</li>
      </ul>
    </div>
    <footer class="site-footer" id="siteFooter">
      Last updated: <span id="lastUpdated"></span> • Data sources: Statistics Canada, CRA, Bank of Canada.
    </footer>
  <script>
    // Register a custom watermark plugin.  This draws faint text behind each
    // chart using the specified colour.  The plugin reads the watermark
    // configuration from the chart options (plugins.watermark) and falls
    // back to a default colour if none is provided.  Opacity is set via
    // the canvas globalAlpha to ensure the watermark remains subtle.
    const watermarkPlugin = {
      id: 'watermark',
      beforeDraw: function(chart, args, options) {
        const opts = chart.options.plugins.watermark || {};
        const ctx = chart.ctx;
        const { left, right, top, bottom } = chart.chartArea;
        // Use user‑defined values or fall back to sensible defaults.  The
        // watermark is placed near the bottom right of the chart.
        const text = opts.text || 'wealthdashboard.ca';
        const color = opts.color || '#4fc3f7';
        // Use a slightly higher opacity for better visibility and a smaller font size
        const opacity = opts.opacity !== undefined ? opts.opacity : 0.10;
        const fontSize = opts.fontSize || 16;
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.fillStyle = color;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        const x = right - 10;
        const y = bottom - 10;
        ctx.fillText(text, x, y);
        ctx.restore();
      }
    };
    Chart.register(watermarkPlugin);
    // Plugin to draw box-and-whisker style whiskers for the province chart.
    const provinceWhiskersPlugin = {
      id: 'provinceWhiskers',
      afterDatasetsDraw: function(chart, args, options) {
        if (['provinceChart','provinceIncomeChart'].indexOf(chart.canvas.id) === -1) return;
        const whiskers = chart._whiskers;
        if (!whiskers) return;
        const ctx = chart.ctx;
        const yScale = chart.scales.y;
        const meta = chart.getDatasetMeta(0);
        if (!meta || !meta.data) return;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        for (let i = 0; i < meta.data.length; i++) {
          const el = meta.data[i];
          const x = el.x;
          const p10 = whiskers.p10 && whiskers.p10[i] !== undefined ? whiskers.p10[i] : null;
          const p90 = whiskers.p90 && whiskers.p90[i] !== undefined ? whiskers.p90[i] : null;
          if (p10 === null || p90 === null) continue;
          const yTop = yScale.getPixelForValue(p90);
          const yBottom = yScale.getPixelForValue(p10);
          // Vertical whisker line
          ctx.beginPath();
          ctx.moveTo(x, yTop);
          ctx.lineTo(x, yBottom);
          ctx.stroke();
          // Caps
          ctx.beginPath(); ctx.moveTo(x - 8, yTop); ctx.lineTo(x + 8, yTop); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(x - 8, yBottom); ctx.lineTo(x + 8, yBottom); ctx.stroke();
        }
        ctx.restore();
      }
    };
    Chart.register(provinceWhiskersPlugin);
    // Data definitions for 2025 smoothed estimates
    // Age labels for 18–80 inclusive
    const ageLabels = [
      '18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50','51','52','53','54','55','56','57','58','59','60','61','62','63','64','65','66','67','68','69','70','71','72','73','74','75','76','77','78','79','80'
    ];
    const HOUSEHOLD_INCOME_MULTIPLIER = 1.6; // CRA T1 statistics show household medians are ~1.6x individual medians
    const USD_TO_CAD_2024 = 1.34; // 2024 average USD/CAD reference from Bank of Canada
    /*
     * Base datasets for Canada. These arrays serve as the foundation for all
     * regions; when a province is selected, values are scaled by the appropriate
     * income or net worth ratio. The earliest ages are adjusted to reflect
     * typical negative or low net worth in early adulthood.
     */
    const baseIncome = [
      25000,27500,30000,32500,35000,37188,39375,41562,43750,45938,48125,50312,52500,53450,54400,55350,56300,57250,58200,59150,60100,61050,62000,62200,62400,62600,62800,63000,62800,62600,62400,62200,62000,61100,60200,59300,58400,57500,56600,55700,54800,53900,53000,51700,50400,49100,47800,46500,45200,43900,42600,41300,40000,38500,37000,35500,34000,32500,31000,29500,28000,26500,25000
    ];

    // Base total income values (all sources) for 2025.  These values
    // reflect estimated median total income by age, including wages,
    // investment returns, pensions and government transfers.  Anchor
    // points were chosen at ages 18, 22, 30, 40, 45, 50, 60, 65, 70,
    // 75 and 80 based on typical earnings patterns and average retirement
    // incomes reported by senior households.  Linear interpolation was
    // used between anchors to create a smooth curve across ages.  See
    // Methods for a full explanation.
    const baseTotalIncome = [
      26000,28250,30500,32750,35000,37500,40000,42500,45000,47500,50000,52500,55000,56500,58000,59500,61000,62500,64000,65500,67000,68500,70000,70400,70800,71200,71600,72000,71600,71200,70800,70400,70000,69000,68000,67000,66000,65000,64000,63000,62000,61000,60000,59000,58000,57000,56000,55000,54000,53000,52000,51000,50000,49000,48000,47000,46000,45000,44000,43000,42000,41000,40000
    ];
    // Base net worth values have been recalibrated using projected 2025 median
    // net worth by age groups from Statistics Canada’s 2019–2023 Survey of
    // Financial Security. The curve starts negative to reflect that many
    // people in their late teens and early twenties carry more debt than
    // assets. Median net worth is projected for 2025 using compound annual
    // growth between 2019 and 2023 and then linearly interpolated between
    // anchor ages of 30, 40, 50, 60, 70 and 80. A downward adjustment is
    // applied after age 70 to reflect draw‑downs in retirement. See Methods
    // for details.
    const baseNetWorth = [
      -10000,-7500,-5000,-2500,0,35875,71750,107625,143500,179375,215250,251125,
      287000,312300,337600,362900,388200,413500,438800,464100,489400,514700,
      540000,563000,586000,609000,632000,655000,678000,701000,724000,747000,
      770000,791200,812400,833600,854800,876000,897200,918400,939600,960800,
      982000,969900,957800,945700,933600,921500,909400,897300,885200,873100,
      861000,834900,808800,782700,756600,730500,704400,678300,652200,626100,
      600000
    ];
    // Survey of Financial Security percentile ranges (2025) smoothed across ages (base values).
    // These values are kept for reference but are not plotted as a separate chart.
    const baseRanges = [
      70000,72500,75000,77500,80000,82500,85000,87500,92500,97500,102500,107500,112500,116500,120500,124500,128500,132500,142500,152500,162500,172500,182500,188500,194500,200500,206500,212500,218500,224500,230500,236500,242500,246500,250500,254500,258500,262500,276500,290500,304500,318500,332500,332900,333300,333700,334100,334500,334900,335300,335700,336100,336500,337700,338900,340100,341300,342500,350500,358500,366500,374500,382500
    ];
    // Top percentile net worth (SFS-derived 2025 projection) smoothed across ages (base values)
    const baseTop1 = [
      300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000
    ];
    // Estimated average net worth (households vs individuals) for 2025, smoothed (base values)
    const baseAvgHouseholds = [
      250000,270833,291667,312500,333333,354167,375000,395833,416667,437500,458333,479167,500000,540000,580000,620000,660000,700000,740000,780000,820000,860000,900000,955000,1010000,1065000,1120000,1175000,1230000,1285000,1340000,1395000,1450000,1480000,1510000,1540000,1570000,1600000,1630000,1660000,1690000,1720000,1750000,1680000,1610000,1540000,1470000,1400000,1360000,1320000,1280000,1240000,1200000,1180000,1160000,1140000,1120000,1100000,1080000,1060000,1040000,1020000,1000000
    ];
    const baseAvgIndividuals = [
      50000,58333,66667,75000,83333,91667,100000,108333,116667,125000,133333,141667,150000,170000,190000,210000,230000,250000,270000,290000,310000,330000,350000,375000,400000,425000,450000,475000,500000,525000,550000,575000,600000,610000,620000,630000,640000,650000,660000,670000,680000,690000,700000,680000,660000,640000,620000,600000,580000,560000,540000,520000,500000,490000,480000,470000,460000,450000,440000,430000,420000,410000,400000
    ];
    // Projected provincial median net worth (2025) – base values. These values
    // represent the estimated 2025 median net worth for each province and will
    // remain constant regardless of the selected region. When a province is
    // selected in the dropdown, the bar corresponding to that province is
    // highlighted.
    const baseProvinceLabels = ['Newfoundland & Labrador','Prince Edward Island','Nova Scotia','New Brunswick','Quebec','Ontario','Manitoba','Saskatchewan','Alberta','British Columbia'];
    // Updated provincial median net worth projections for 2025.  These
    // values were derived from Statistics Canada’s 2019 and 2023 survey
    // results【749321692766873†L68-L79】【254363627897504†L52-L63】.  We calculated a compound
    // annual growth rate for each province between 2019 and 2023 and
    // projected that forward two years to 2025.  The numbers below are
    // rounded to the nearest dollar.
    const baseProvinceValues = [
      387286, // Newfoundland & Labrador (≈$387.3k)
      549809, // Prince Edward Island (≈$549.8k)
      415798, // Nova Scotia (≈$415.8k)
      355974, // New Brunswick (≈$356.0k)
      463399, // Quebec (≈$463.4k)
      823806, // Ontario (≈$823.8k)
      441531, // Manitoba (≈$441.5k)
      431171, // Saskatchewan (≈$431.2k)
      548633, // Alberta (≈$548.6k)
      1045108 // British Columbia (≈$1.045M)
    ];

    /**
     * Ratio dictionaries for scaling by province. Income ratios are based on
     * average individual incomes in 2023 by province relative to the national
     * average (≈$63,181)【118231790205128†L100-L108】, while net worth ratios
     * are derived from Statistics Canada’s 2023 provincial median net worth
     * values relative to the national median (≈$519,700)【488464190137828†L64-L74】.
     * These ratios are used to scale the Canadian base data for each region.
     */
    const incomeRatios = {
      'Canada': 1,
      'Newfoundland & Labrador': 0.8319,
      'Prince Edward Island': 0.7306,
      'Nova Scotia': 0.8950,
      'New Brunswick': 0.9075,
      'Quebec': 0.9102,
      'Ontario': 1.0030,
      'Manitoba': 0.9259,
      // Corrected: Saskatchewan is near national average, not 1.3995
      'Saskatchewan': 0.9995,
      'Alberta': 1.1750,
      'British Columbia': 1.0483
    };
    // Net‑worth scaling ratios based on projected 2025 provincial medians.
    // Each value represents the province’s projected median net worth (2025)
    // divided by the projected national median (~$652,286).  These
    // projections use province‑specific growth rates derived from
    // 2019–2023 data【749321692766873†L68-L79】【254363627897504†L52-L63】.
    const netWorthRatios = {
      'Canada': 1,
      'Newfoundland & Labrador': 0.5937,
      'Prince Edward Island': 0.8429,
      'Nova Scotia': 0.6374,
      'New Brunswick': 0.5457,
      'Quebec': 0.7104,
      'Ontario': 1.2630,
      'Manitoba': 0.6769,
      'Saskatchewan': 0.6610,
      'Alberta': 0.8411,
      'British Columbia': 1.6022
    };

    // Compute typical median income by province using the national median employment income at
    // age 40 (index 22 in the baseIncome array).  This provides a single representative
    // figure for each province that can be displayed in the provincial income bar chart.
    // The values are calculated by multiplying the national baseline (baseIncome[22]) by the
    // appropriate income ratio for each region.  For example, Ontario’s value is
    // baseIncome[22] * incomeRatios['Ontario'] ≈ 62,000 × 1.003.
    const baseProvinceIncomeValues = baseProvinceLabels.map(label => {
      // Select the national baseline at age 40 (approximately the peak median employment income)
      const medianIncome = baseIncome[22];
      const ratio = incomeRatios[label] || 1;
      return Math.round(medianIncome * ratio);
    });
    const provinceHouseholdIncomeValues = baseProvinceLabels.map(label => {
      const ratio = incomeRatios[label] || 1;
      return Math.round(baseIncome[22] * HOUSEHOLD_INCOME_MULTIPLIER * ratio);
    });

    function computeDiscretionary(income, spending) {
      return income - spending;
    }

    // Average household expenditure by province (Survey of Household Spending Table 11-10-0223-01, indexed to 2025 dollars)
    const provinceSpendingEstimates = [
      71200, // Newfoundland & Labrador
      70500, // Prince Edward Island
      72900, // Nova Scotia
      70100, // New Brunswick
      69000, // Quebec
      82400, // Ontario
      72600, // Manitoba
      75200, // Saskatchewan
      87900, // Alberta
      86500  // British Columbia
    ];

    const provinceDiscretionaryValues = baseProvinceLabels.map((_, idx) =>
      computeDiscretionary(provinceHouseholdIncomeValues[idx], provinceSpendingEstimates[idx])
    );

    // Global comparison datasets (values in CAD after USD PPP conversion using USD_TO_CAD_2024)
    const globalCountryLabels = ['Canada','United States','United Kingdom','Germany','France','Australia','Japan','Netherlands'];
    const oecdMedianIncomePPPUSD = [46000, 52000, 40000, 43000, 38000, 48500, 37000, 45000];
    const globalMedianIncomeCAD = oecdMedianIncomePPPUSD.map(v => Math.round(v * USD_TO_CAD_2024));
    const globalMedianNetWorthUSD = [125000, 107000, 155000, 60000, 120000, 210000, 123000, 140000];
    const globalMedianNetWorthCAD = globalMedianNetWorthUSD.map(v => Math.round(v * USD_TO_CAD_2024));

    /*
     * Percentile datasets
     *
     * The following arrays represent smoothed percentile estimates for each age 18–80.
     * They were derived by taking ratios from the 2016 income percentile table
     * (10th/25th/75th/90th/99th relative to the median) and applying those ratios to
     * our 2025 base series.  For net worth and average net worth, constant multipliers
     * were used (e.g., 10% of the median for the 10th percentile, 35% for 25th, 150% for 75th,
     * 180% for 90th and the top‑1% threshold for 99th).  See Methods for details.
     */
    // Income percentiles (individual employment income)
    const baseIncomeP10 = [5125,5637,6150,6662,7175,7623,8071,8520,9205,9914,10646,11403,12183,12386,12589,12791,12993,13194,13315,13432,13546,13657,13765,13704,13643,13581,13518,13455,13309,13163,13019,12875,12731,12446,12163,11884,11607,11334,10814,10305,9808,9321,8845,9212,9549,9858,10137,10386,12930,15310,17527,19582,21473,20668,19863,19057,18252,17447,16642,15836,15031,14226,13421];
    const baseIncomeP25 = [13386,14725,16064,17402,18741,19913,21084,22255,23513,24779,26054,27338,28630,29136,29640,30145,30649,31152,31548,31940,32327,32711,33091,33068,33044,33020,32994,32968,32637,32306,31978,31650,31325,30649,29980,29318,28662,28012,27034,26073,25129,24202,23292,22765,22237,21705,21172,20637,22524,24270,25875,27337,28658,27583,26508,25434,24359,23284,22210,21135,20060,18986,17911];
    const baseIncomeP75 = [39849,43834,47819,51804,55789,59276,62762,66248,69232,72166,75048,77879,80662,82417,84183,85959,87745,89543,91558,93590,95640,97707,99792,100679,101571,102466,103364,104266,104141,104014,103885,103756,103625,102321,101010,99694,98372,97044,95392,93745,92102,90463,88828,86641,84455,82268,80083,77897,75843,73783,71715,69640,67557,65024,62490,59957,57424,54890,52357,49823,47290,44757,42223];
    const baseIncomeP90 = [57099,62809,68519,74229,79939,84936,89931,94926,98619,102181,105610,108910,112080,114587,117110,119651,122208,124783,128049,131354,134699,138082,141504,143239,144981,146732,148491,150258,150677,151090,151497,151898,152294,150954,149589,148198,146782,145340,144183,142990,141761,140498,139198,134978,130798,126659,122560,118501,115810,113082,110319,107520,104686,100760,96834,92909,88983,85057,81132,77206,73280,69354,65429];
    const baseIncomeP99 = [103655,114021,124387,134752,145118,154190,163257,172325,180128,187803,195348,202765,210060,218828,227773,236895,246193,255667,270804,286296,302143,318347,334906,347628,360426,373299,386246,399269,404079,408850,413583,418277,422932,422706,422305,421731,420982,420059,417386,414589,411668,408623,405453,391530,377807,364284,350961,337838,329318,320745,312119,303439,294706,283655,272603,261552,250500,239449,228397,217346,206294,195243,184191];
    // Total income percentiles (all income sources)
    const baseTotalIncomeP10 = [5330,5791,6252,6713,7175,7687,8199,8712,9468,10251,11061,11898,12763,13093,13422,13750,14078,14404,14642,14874,15102,15324,15541,15511,15480,15447,15413,15377,15174,14972,14771,14572,14374,14055,13739,13427,13118,12812,12228,11656,11096,10549,10013,10512,10989,11444,11876,12285,15447,18484,21395,24181,26841,26305,25768,25231,24694,24157,23620,23084,22547,22010,21473];
    const baseTotalIncomeP25 = [13922,15127,16331,17536,18741,20080,21418,22757,24184,25622,27069,28526,29994,30798,31602,32405,33207,34009,34692,35368,36039,36703,37361,37427,37493,37556,37618,37678,37210,36745,36282,35823,35367,34612,33865,33125,32392,31666,30568,29490,28430,27390,26368,25980,25590,25198,24804,24409,26910,29301,31584,33758,35822,35106,34389,33673,32957,32240,31524,30807,30091,29374,28658];
    const baseTotalIncomeP75 = [41443,45029,48616,52202,55789,59773,63758,67743,71210,74620,77972,81266,84503,87120,89753,92404,95071,97754,100682,103638,106621,109631,112668,113952,115244,116542,117848,119161,118734,118303,117870,117434,116996,115550,114098,112639,111174,109702,107864,106031,104203,102379,100561,98875,97190,95505,93821,92136,90609,89077,87539,85996,84447,82758,81069,79380,77691,76002,74313,72624,70935,69246,67557];
    const baseTotalIncomeP90 = [59383,64522,69661,74800,79939,85648,91358,97068,101436,105655,109725,113646,117418,121126,124860,128622,132410,136226,140810,145456,150163,154932,159763,162122,164498,166890,169299,171724,171791,171846,171890,171923,171945,170472,168971,167442,165884,164297,163033,161730,160387,159005,157583,154036,150521,147037,143585,140163,138357,136523,134662,132773,130857,128240,125623,123006,120389,117772,115154,112537,109920,107303,104686];
    const baseTotalIncomeP99 = [107802,117131,126460,135789,145118,155483,165849,176214,185274,194189,202959,211583,220063,231315,242846,254656,266745,279113,297791,317031,336832,357195,378119,393457,408945,424583,440370,456307,460701,465018,469258,473419,477504,477360,477023,476492,475767,474849,471956,468925,465756,462449,459004,446814,434778,422896,411168,399593,393433,387232,380990,374707,368383,361015,353647,346280,338912,331544,324177,316809,309441,302074,294706];
    // Net worth percentiles
    const baseNetWorthP10 = [-1000,-750,-500,-250,-100,3588,7175,10762,14350,17938,21525,25112,28700,31230,33760,36290,38820,41350,43880,46410,48940,51470,54000,56300,58600,60900,63200,65500,67800,70100,72400,74700,77000,79120,81240,83360,85480,87600,89720,91840,93960,96080,98200,96990,95780,94570,93360,92150,90940,89730,88520,87310,86100,83490,80880,78270,75660,73050,70440,67830,65220,62610,60000];
    const baseNetWorthP25 = [-3500,-2625,-1750,-875,0,12556,25112,37669,50225,62781,75338,87894,100450,109305,118160,127015,135870,144725,153580,162435,171290,180145,189000,197050,205100,213150,221200,229250,237300,245350,253400,261450,269500,276920,284340,291760,299180,306600,314020,321440,328860,336280,343700,339465,335230,330995,326760,322525,318290,314055,309820,305585,301350,292215,283080,273945,264810,255675,246540,237405,228270,219135,210000];
    const baseNetWorthP75 = [-15000,-11250,-7500,-3750,0,53812,107625,161438,215250,269062,322875,376688,430500,468450,506400,544350,582300,620250,658200,696150,734100,772050,810000,844500,879000,913500,948000,982500,1017000,1051500,1086000,1120500,1155000,1186800,1218600,1250400,1282200,1314000,1345800,1377600,1409400,1441200,1473000,1454850,1436700,1418550,1400400,1382250,1364100,1345950,1327800,1309650,1291500,1252350,1213200,1174050,1134900,1095750,1056600,1017450,978300,939150,900000];
    const baseNetWorthP90 = [-18000,-13500,-9000,-4500,10000,64575,129150,193725,258300,322875,387450,452025,516600,562140,607680,653220,698760,744300,789840,835380,880920,926460,972000,1013400,1054800,1096200,1137600,1179000,1220400,1261800,1303200,1344600,1386000,1424160,1462320,1500480,1538640,1576800,1614960,1653120,1691280,1729440,1767600,1745820,1724040,1702260,1680480,1658700,1636920,1615140,1593360,1571580,1549800,1502820,1455840,1408860,1361880,1314900,1267920,1220940,1173960,1126980,1080000];
    const baseNetWorthP99 = [300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000];
    // Average net worth percentiles (households)
    const baseAvgHouseholdsP10 = [25000,27083,29167,31250,33333,35417,37500,39583,41667,43750,45833,47917,50000,54000,58000,62000,66000,70000,74000,78000,82000,86000,90000,95500,101000,106500,112000,117500,123000,128500,134000,139500,145000,148000,151000,154000,157000,160000,163000,166000,169000,172000,175000,168000,161000,154000,147000,140000,136000,132000,128000,124000,120000,118000,116000,114000,112000,110000,108000,106000,104000,102000,100000];
    const baseAvgHouseholdsP25 = [87500,94792,102083,109375,116667,123958,131250,138542,145833,153125,160417,167708,175000,189000,203000,217000,231000,245000,259000,273000,287000,301000,315000,334250,353500,372750,392000,411250,430500,449750,469000,488250,507500,518000,528500,539000,549500,560000,570500,581000,591500,602000,612500,588000,563500,539000,514500,490000,476000,462000,448000,434000,420000,413000,406000,399000,392000,385000,378000,371000,364000,357000,350000];
    const baseAvgHouseholdsP75 = [375000,406250,437500,468750,500000,531250,562500,593750,625000,656250,687500,718750,750000,810000,870000,930000,990000,1050000,1110000,1170000,1230000,1290000,1350000,1432500,1515000,1597500,1680000,1762500,1845000,1927500,2010000,2092500,2175000,2220000,2265000,2310000,2355000,2400000,2445000,2490000,2535000,2580000,2625000,2520000,2415000,2310000,2205000,2100000,2040000,1980000,1920000,1860000,1800000,1770000,1740000,1710000,1680000,1650000,1620000,1590000,1560000,1530000,1500000];
    const baseAvgHouseholdsP90 = [450000,487499,525001,562500,599999,637501,675000,712499,750001,787500,824999,862501,900000,972000,1044000,1116000,1188000,1260000,1332000,1404000,1476000,1548000,1620000,1719000,1818000,1917000,2016000,2115000,2214000,2313000,2412000,2511000,2610000,2664000,2718000,2772000,2826000,2880000,2934000,2988000,3042000,3096000,3150000,3024000,2898000,2772000,2646000,2520000,2448000,2376000,2304000,2232000,2160000,2124000,2088000,2052000,2016000,1980000,1944000,1908000,1872000,1836000,1800000];
    const baseAvgHouseholdsP99 = [300000,325000,350000,375000,400000,425000,450000,475000,540000,605000,670000,735000,800000,940000,1080000,1220000,1360000,1500000,1700000,1900000,2100000,2300000,2500000,2800000,3100000,3400000,3700000,4000000,4200000,4400000,4600000,4800000,5000000,5200000,5400000,5600000,5800000,6000000,6600000,7200000,7800000,8400000,9000000,9300000,9600000,9900000,10200000,10500000,10500000,10500000,10500000,10500000,10500000,10300000,10100000,9900000,9700000,9500000,9300000,9100000,8900000,8700000,8500000];
    // Average net worth percentiles (individuals)
    const baseAvgIndividualsP10 = [5000,5833,6667,7500,8333,9167,10000,10833,11667,12500,13333,14167,15000,17000,19000,21000,23000,25000,27000,29000,31000,33000,35000,37500,40000,42500,45000,47500,50000,52500,55000,57500,60000,61000,62000,63000,64000,65000,66000,67000,68000,69000,70000,68000,66000,64000,62000,60000,58000,56000,54000,52000,50000,49000,48000,47000,46000,45000,44000,43000,42000,41000,40000];
    const baseAvgIndividualsP25 = [17500,20417,23333,26250,29167,32083,35000,37917,40833,43750,46667,49583,52500,59500,66500,73500,80500,87500,94500,101500,108500,115500,122500,131250,140000,148750,157500,166250,175000,183750,192500,201250,210000,213500,217000,220500,224000,227500,231000,234500,238000,241500,245000,238000,231000,224000,217000,210000,203000,196000,189000,182000,175000,171500,168000,164500,161000,157500,154000,150500,147000,143500,140000];
    const baseAvgIndividualsP75 = [75000,87500,100000,112500,125000,137500,150000,162500,175000,187500,200000,212500,225000,255000,285000,315000,345000,375000,405000,435000,465000,495000,525000,562500,600000,637500,675000,712500,750000,787500,825000,862500,900000,915000,930000,945000,960000,975000,990000,1005000,1020000,1035000,1050000,1020000,990000,960000,930000,900000,870000,840000,810000,780000,750000,735000,720000,705000,690000,675000,660000,645000,630000,615000,600000];
    const baseAvgIndividualsP90 = [90000,104999,120001,135000,149999,165001,180000,194999,210001,225000,239999,255001,270000,306000,342000,378000,414000,450000,486000,522000,558000,594000,630000,675000,720000,765000,810000,855000,900000,945000,990000,1035000,1080000,1098000,1116000,1134000,1152000,1170000,1188000,1206000,1224000,1242000,1260000,1224000,1188000,1152000,1116000,1080000,1044000,1008000,972000,936000,900000,882000,864000,846000,828000,810000,792000,774000,756000,738000,720000];
    const baseAvgIndividualsP99 = [150000,162500,175000,187500,200000,212500,225000,237500,270000,302500,335000,367500,400000,470000,540000,610000,680000,750000,850000,950000,1050000,1150000,1250000,1400000,1550000,1700000,1850000,2000000,2100000,2200000,2300000,2400000,2500000,2600000,2700000,2800000,2900000,3000000,3300000,3600000,3900000,4200000,4500000,4650000,4800000,4950000,5100000,5250000,5250000,5250000,5250000,5250000,5250000,5150000,5050000,4950000,4850000,4750000,4650000,4550000,4450000,4350000,4250000];

    // Individuals median net worth estimates for 2025.  Because Statistics
    // Canada reports net worth at the family/household level, there is no
    // official individual median net worth series.  We therefore approximate
    // individual median net worth as 60% of the household median net worth
    // at each age.  This ratio reflects the fact that unattached persons
    // typically hold less wealth than multi‑person households.  Percentile
    // estimates for individuals use the same 60% ratio applied to the
    // household percentile arrays.
    function scaleIndividualNetWorthArray(arr) {
      return arr.map(v => {
        // For negative values, scale by 1.5 to reflect deeper debt for
        // individuals; for positive values, scale by 0.6.  This ensures
        // individuals remain below households at every age.
        return v < 0 ? Math.round(v * 1.5) : Math.round(v * 0.6);
      });
    }
    const baseIndNetWorth = scaleIndividualNetWorthArray(baseNetWorth);
    const baseIndNetWorthP10 = scaleIndividualNetWorthArray(baseNetWorthP10);
    const baseIndNetWorthP25 = scaleIndividualNetWorthArray(baseNetWorthP25);
    const baseIndNetWorthP75 = scaleIndividualNetWorthArray(baseNetWorthP75);
    const baseIndNetWorthP90 = scaleIndividualNetWorthArray(baseNetWorthP90);
    const baseIndNetWorthP99 = scaleIndividualNetWorthArray(baseNetWorthP99);

    // Colour palettes for percentile lines.  Each chart type has its own set of
    // shades.  Colours progress from lighter to darker as the percentile
    // increases.  Median uses the base colour for each chart.
    const percentileColors = {
      income: {
        p10: '#B3E5FC',
        p25: '#81D4FA',
        p50: '#29B6F6',
        p75: '#0288D1',
        p90: '#01579B',
        p99: '#002F6C'
      },
      totalIncome: {
        p10: '#FFECB3',
        p25: '#FFE082',
        p50: '#FFC107',
        p75: '#FFA000',
        p90: '#FF6F00',
        p99: '#E65100'
      },
      netWorth: {
        p10: '#C8E6C9',
        p25: '#A5D6A7',
        p50: '#66BB6A',
        p75: '#388E3C',
        p90: '#1B5E20',
        p99: '#004D40'
      },
      top1: {
        p10: '#F8BBD0',
        p25: '#F48FB1',
        p50: '#F06292',
        p75: '#C2185B',
        p90: '#880E4F',
        p99: '#560027'
      },
      avgHouseholds: {
        p10: '#B2EBF2',
        p25: '#80DEEA',
        p50: '#26C6DA',
        p75: '#0097A7',
        p90: '#006064',
        p99: '#004D40'
      },
      avgIndividuals: {
        p10: '#FFCDD2',
        p25: '#EF9A9A',
        p50: '#EF5350',
        p75: '#E53935',
        p90: '#B71C1C',
        p99: '#880E4F'
      }
      ,
      // Individual median net worth chart colors (similar palette to avgIndividuals)
      indNetWorth: {
        p10: '#FFCDD2',
        p25: '#EF9A9A',
        p50: '#EF5350',
        p75: '#E53935',
        p90: '#B71C1C',
        p99: '#880E4F'
      }
    };

    // Chart instance holders for dynamic updates
    let incomeChartInstance;
    let netWorthChartInstance;
    let provinceChartInstance;
    let compositionChartInstance;
    let provinceIncomeChartInstance;
    let provinceDiscretionaryChartInstance;
    let scatterChartInstance;
    let percentileNetWorthChartInstance;
    let percentileIncomeChartInstance;
    let wealthCompositionChartInstance;
    let genderIncomeChartInstance;

    // Labels for percentile charts (1..99)
    const percentileLabels = Array.from({ length: 99 }, (_, i) => String(i + 1));

    // Anchors for constructing percentile curves (ratios of median)
    const netWorthPercentileAnchors = [
      { p: 1, r: 0.05 }, { p: 10, r: 0.10 }, { p: 25, r: 0.35 },
      { p: 50, r: 1.00 }, { p: 75, r: 1.50 }, { p: 90, r: 1.80 }, { p: 99, r: 12.0 }
    ];
    const incomePercentileAnchors = [
      { p: 1, r: 0.10 }, { p: 10, r: 0.22 }, { p: 25, r: 0.54 },
      { p: 50, r: 1.00 }, { p: 75, r: 1.64 }, { p: 90, r: 2.44 }, { p: 99, r: 6.0 }
    ];

    // Build a 1..99 curve from anchors using log-linear interpolation for smooth heavy tails
    function buildPercentileCurveFromAnchors(anchors) {
      const sorted = anchors.slice().sort((a, b) => a.p - b.p);
      const curve = new Array(99);
      let idx = 0;
      for (let p = 1; p <= 99; p++) {
        while (idx < sorted.length - 1 && p > sorted[idx + 1].p) idx++;
        const a = sorted[Math.max(0, idx)];
        const b = sorted[Math.min(sorted.length - 1, idx + 1)];
        const t = (p - a.p) / Math.max(1, (b.p - a.p));
        const lr = Math.exp(Math.log(a.r) + (Math.log(b.r) - Math.log(a.r)) * Math.max(0, Math.min(1, t)));
        curve[p - 1] = lr;
      }
      return curve;
    }

    // Given a median value and anchor ratios, return absolute values for 1..99 percentiles
    function makePercentileValues(median, anchors) {
      const ratios = buildPercentileCurveFromAnchors(anchors);
      return ratios.map(r => Math.round(median * r));
    }

    // Find the percentile index (0-based) closest to the given value on the curve
    function findPercentileIndex(value, curveValues) {
      let bestIdx = 0;
      let bestDiff = Infinity;
      for (let i = 0; i < curveValues.length; i++) {
        const d = Math.abs(curveValues[i] - value);
        if (d < bestDiff) { bestDiff = d; bestIdx = i; }
      }
      return bestIdx;
    }

    // Plugin to draw a user reference line: vertical (by index or numeric x) or horizontal (by y)
    const userVLinePlugin = {
      id: 'userVLine',
      afterDraw(chart, args, options) {
        if (!options) return;
        const { ctx, chartArea, scales } = chart;
        ctx.save();
        ctx.strokeStyle = (options.color || 'rgba(244,67,54,1)');
        ctx.setLineDash(options.dash || [6,3]);
        ctx.lineWidth = options.width || 2;
        if (options.index != null && scales.x) {
          // Vertical line aligned to a categorical tick index
          const x = scales.x.getPixelForTick(options.index);
          ctx.beginPath();
          ctx.moveTo(x, chartArea.top);
          ctx.lineTo(x, chartArea.bottom);
          ctx.stroke();
          if (options.label) {
            ctx.setLineDash([]);
            ctx.fillStyle = options.color || 'rgba(244,67,54,1)';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(options.label, x + 6, chartArea.top + 6);
          }
        } else if (options.xValue != null && scales.x) {
          // Vertical line at a numeric x-value (e.g., user value on histogram)
          const x = scales.x.getPixelForValue(options.xValue);
          ctx.beginPath();
          ctx.moveTo(x, chartArea.top);
          ctx.lineTo(x, chartArea.bottom);
          ctx.stroke();
          if (options.label) {
            ctx.setLineDash([]);
            ctx.fillStyle = options.color || 'rgba(244,67,54,1)';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(options.label, x + 6, chartArea.top + 6);
          }
        } else if (options.yValue != null && scales.y) {
          // Horizontal line at a numeric y-value (e.g., percentile)
          const y = scales.y.getPixelForValue(options.yValue);
          ctx.beginPath();
          ctx.moveTo(chartArea.left, y);
          ctx.lineTo(chartArea.right, y);
          ctx.stroke();
        }
        ctx.restore();
      }
    };
    Chart.register(userVLinePlugin);

    // Plugin to draw one or more reference vertical lines (e.g., Median)
    const medianVLinePlugin = {
      id: 'medianVLine',
      afterDraw(chart, args, options) {
        if (!options) return;
        const { ctx, chartArea, scales } = chart;
        const lines = Array.isArray(options) ? options : [options];
        ctx.save();
        lines.forEach(line => {
          if (line && line.xValue != null && scales?.x) {
            const x = scales.x.getPixelForValue(line.xValue);
            ctx.strokeStyle = line.color || 'rgba(255,255,255,0.6)';
            ctx.setLineDash(line.dash || [2,2]);
            ctx.lineWidth = line.width || 1;
            ctx.beginPath();
            ctx.moveTo(x, chartArea.top);
            ctx.lineTo(x, chartArea.bottom);
            ctx.stroke();
            if (line.label) {
              ctx.setLineDash([]);
              ctx.fillStyle = line.color || 'rgba(255,255,255,0.7)';
              ctx.font = '12px sans-serif';
              ctx.textAlign = 'left';
              ctx.textBaseline = 'top';
              ctx.fillText(line.label, x + 6, chartArea.top + 6);
            }
          }
        });
        ctx.restore();
      }
    };
    Chart.register(medianVLinePlugin);

    /**
     * Compute axis bounds given an array of values and a desired step size.
     * Returns an object containing min and max. Padding and rounding to the
     * nearest thousand are applied to create clean axes. The range is
     * extended if necessary so that it is divisible by the step size.
     * @param {number[]} values
     * @param {number} step
     */
    function computeAxis(values, step) {
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);
      const pad = (maxVal - minVal) * 0.05;
      // Do not clamp negative values to zero. Allow the axis to extend
      // below zero so that negative net worth at younger ages is visible.
      let yMin = minVal - pad;
      let yMax = maxVal + pad;
      // Round bounds to the nearest thousand for clean tick labels
      yMin = Math.floor(yMin / 1000) * 1000;
      yMax = Math.ceil(yMax / 1000) * 1000;
      if (step) {
        const range = yMax - yMin;
        const remainder = range % step;
        if (remainder !== 0) {
          yMax += step - remainder;
        }
      }
      return { min: yMin, max: yMax };
    }

    /**
     * Update all charts according to the selected region. This function scales
     * base datasets by the appropriate income and net worth ratios, updates
     * chart data and axis bounds, updates chart titles, and highlights the
     * selected province in the provincial bar chart.
     * @param {string} region The selected province name or 'Canada'
     */
    function updateCharts(region) {
      const incomeRatio = incomeRatios[region] || 1;
      const netRatio = netWorthRatios[region] || 1;
      const unitEl = document.getElementById('unitSelect');
      const unit = unitEl ? unitEl.value : 'households';
      // Show core percentile lines by default: 10th, 25th, 50th (median), 75th, 90th
      const selectedPcts = ['p10','p25','p75','p90'];
      /*
       * Helper to build datasets and axis for a line chart.  Accepts the base
       * median array and an object of percentile arrays keyed by p10/p25/etc.
       * Colours are drawn from the percentileColours dictionary for the given
       * chart type.  The function returns an object with a new dataset array
       * and an array of all values used for axis computation.
       */
      function buildPercentileDatasets(type, baseArray, pctArrays, colorMap, labelBase) {
        const datasets = [];
        // Median (50th percentile)
        datasets.push({
          // Label the median clearly as 'Median' for readability
          label: 'Median',
          data: baseArray,
          borderColor: colorMap.p50,
          backgroundColor: 'transparent',
          // show a small interactive hit area so tooltips appear when hovering the line
          pointRadius: 0,
          pointHoverRadius: 4,
          pointHitRadius: 8,
          tension: 0.35
        });
        // Add selected percentile lines (excluding median)
        selectedPcts.forEach(p => {
          // If the user selects p50 (median), we skip because median is always present
          if (p === 'p50') return;
          const arr = pctArrays[p];
          if (!arr) return;
          let pctLabel = '';
          switch (p) {
            case 'p10': pctLabel = '10th Percentile'; break;
            case 'p25': pctLabel = '25th Percentile'; break;
            case 'p75': pctLabel = '75th Percentile'; break;
            case 'p90': pctLabel = '90th Percentile'; break;
            case 'p99': pctLabel = '99th Percentile'; break;
            default: pctLabel = p; break;
          }
          // Append chart type to label for clarity on average net worth chart
          if (type === 'avgHouseholds') {
            pctLabel += ' (Households)';
          } else if (type === 'avgIndividuals') {
            pctLabel += ' (Individuals)';
          } else if (type === 'top1' && p === 'p99') {
            pctLabel = '99th Percentile (Top 1% Threshold)';
          }
          datasets.push({
            label: pctLabel,
            data: arr,
            borderColor: colorMap[p],
            backgroundColor: 'transparent',
            // hide points visually but allow hover detection and a small hover radius
            pointRadius: 0,
            pointHoverRadius: 4,
            pointHitRadius: 8,
            tension: 0.35
          });
        });
        // Gather values for axis computation
        let allVals = baseArray.slice();
        selectedPcts.forEach(p => {
          if (p === 'p50') return;
          if (pctArrays[p]) allVals = allVals.concat(pctArrays[p]);
        });
        return { datasets, values: allVals };
      }
      // Prepare scaled arrays for each percentile for incomes
      // Scale employment income by region; adjust for unit (households vs individuals)
      let scaledIncome = baseIncome.map(v => Math.round(v * incomeRatio));
      if (unit === 'households') {
        scaledIncome = scaledIncome.map(v => Math.round(v * HOUSEHOLD_INCOME_MULTIPLIER));
      }
      const incomePctArrays = {
        p10: baseIncomeP10.map(v => Math.round(v * incomeRatio)),
        // Use proportional percentiles derived from the median to avoid overlapping/incorrect anchors
        p25: scaledIncome.map(v => Math.round(v * 0.65)),
        p50: scaledIncome,
        p75: scaledIncome.map(v => Math.round(v * 1.35)),
        p90: baseIncomeP90.map(v => Math.round(v * incomeRatio)),
        p99: baseIncomeP99.map(v => Math.round(v * incomeRatio))
      };
      const incomeLabelBase = unit === 'households' ? 'Median Employment Income (Households)' : 'Median Employment Income (Individuals)';
      const incomeResult = buildPercentileDatasets('income', scaledIncome, incomePctArrays, percentileColors.income, incomeLabelBase);
      // Preserve user dataset if present
      const incomeUserIdx = incomeChartInstance.data.datasets.findIndex(ds => ds.label === 'You');
      let incomeUserDs = null;
      if (incomeUserIdx >= 0 && userActive) incomeUserDs = incomeChartInstance.data.datasets[incomeUserIdx];
      incomeChartInstance.data.datasets = incomeResult.datasets.slice();
      if (incomeUserDs) incomeChartInstance.data.datasets.push(incomeUserDs);
      // Compute axis and update chart
      let incVals = incomeResult.values.slice();
      if (userActive) incVals.push(userIncomeVal);
      let incAxis = computeAxis(incVals, 5000);
      incomeChartInstance.options.scales.y.min = 0;
      incomeChartInstance.options.scales.y.max = incAxis.max;
      incomeChartInstance.options.scales.y.title.text = unit === 'households'
        ? 'Median Employment Income ($ - Households)'
        : 'Median Employment Income ($ - Individuals)';
      incomeChartInstance.update();

      // Update gender income chart using CIS-derived female-to-male ratio (~0.88 nationwide)
      const womenRatio = 0.88;
      const menRatio = 1.00;
      const womenIncome = baseIncome.map(v => Math.round(v * incomeRatio * (unit==='households' ? HOUSEHOLD_INCOME_MULTIPLIER : 1) * womenRatio));
      const menIncome = baseIncome.map(v => Math.round(v * incomeRatio * (unit==='households' ? HOUSEHOLD_INCOME_MULTIPLIER : 1) * menRatio));
      genderIncomeChartInstance.data.labels = ageLabels;
      genderIncomeChartInstance.data.datasets[0].data = womenIncome;
      genderIncomeChartInstance.data.datasets[1].data = menIncome;
      // Force axes to start at zero
      let gVals = womenIncome.concat(menIncome);
      const gAxis = computeAxis(gVals, 5000);
      genderIncomeChartInstance.options.scales.y.min = 0;
      genderIncomeChartInstance.options.scales.y.max = gAxis.max;
      genderIncomeChartInstance.update();

      // Income composition breakdown chart
      // Compute total income values for the selected region.  These values include
      // all income sources.  The composition shares below determine how
      // employment, investment, pension and transfer income contribute at each age.
      let scaledTotalIncome = baseTotalIncome.map(v => Math.round(v * incomeRatio));
      if (unit === 'households') {
        scaledTotalIncome = scaledTotalIncome.map(v => Math.round(v * HOUSEHOLD_INCOME_MULTIPLIER));
      }
      const empData = [];
      const invData = [];
      const penData = [];
      const transData = [];
      for (let i = 0; i < ageLabels.length; i++) {
        const age = 18 + i;
        let empShare, invShare, penShare, transShare;
        if (age <= 55) {
          empShare = 0.90; invShare = 0.05; penShare = 0.03; transShare = 0.02;
        } else if (age <= 65) {
          const t = (age - 55) / 10;
          // Interpolate between 90/5/3/2 and 60/10/20/10
          empShare = 0.90 * (1 - t) + 0.60 * t;
          invShare = 0.05 * (1 - t) + 0.10 * t;
          penShare = 0.03 * (1 - t) + 0.20 * t;
          transShare = 0.02 * (1 - t) + 0.10 * t;
        } else {
          const t = (age - 65) / 15;
          // Interpolate between 60/10/20/10 and 10/25/50/15
          empShare = 0.60 * (1 - t) + 0.10 * t;
          invShare = 0.10 * (1 - t) + 0.25 * t;
          penShare = 0.20 * (1 - t) + 0.50 * t;
          transShare = 0.10 * (1 - t) + 0.15 * t;
        }
        const totalVal = scaledTotalIncome[i];
        empData.push(Math.round(totalVal * empShare));
        invData.push(Math.round(totalVal * invShare));
        penData.push(Math.round(totalVal * penShare));
        transData.push(Math.round(totalVal * transShare));
      }
      // Update the composition chart datasets with the computed component values
      if (compositionChartInstance) {
        compositionChartInstance.data.datasets[0].data = empData;
        compositionChartInstance.data.datasets[1].data = invData;
        compositionChartInstance.data.datasets[2].data = penData;
        compositionChartInstance.data.datasets[3].data = transData;
        // Determine the axis bounds based on total income values and user income
        let compVals = scaledTotalIncome.slice();
        if (userActive) compVals.push(userIncomeVal);
        let compAxis = computeAxis(compVals, 5000);
        compositionChartInstance.options.scales.y.stacked = true;
        compositionChartInstance.options.scales.y.min = 0;
        compositionChartInstance.options.scales.y.max = compAxis.max;
        compositionChartInstance.update();
      }

      // Net worth chart (median net worth) for selected unit
      const scaledNet = (unit === 'households' ? baseNetWorth : baseIndNetWorth).map(v => Math.round(v * netRatio));
      const netPctArrays = (unit === 'households') ? {
        p10: baseNetWorthP10.map(v => Math.round(v * netRatio)),
        p25: baseNetWorthP25.map(v => Math.round(v * netRatio)),
        p50: scaledNet,
        p75: baseNetWorthP75.map(v => Math.round(v * netRatio)),
        p90: baseNetWorthP90.map(v => Math.round(v * netRatio)),
        p99: baseNetWorthP99.map(v => Math.round(v * netRatio))
      } : {
        p10: baseIndNetWorthP10.map(v => Math.round(v * netRatio)),
        p25: baseIndNetWorthP25.map(v => Math.round(v * netRatio)),
        p50: scaledNet,
        p75: baseIndNetWorthP75.map(v => Math.round(v * netRatio)),
        p90: baseIndNetWorthP90.map(v => Math.round(v * netRatio)),
        p99: baseIndNetWorthP99.map(v => Math.round(v * netRatio))
      };
      const netLabelBase = unit === 'households' ? 'Median Net Worth (Households)' : 'Median Net Worth (Individuals)';
      const netColorMap = unit === 'households' ? percentileColors.netWorth : percentileColors.indNetWorth;
      const netResult = buildPercentileDatasets(unit === 'households' ? 'netWorth' : 'indNetWorth', scaledNet, netPctArrays, netColorMap, netLabelBase);
      // Preserve zero line dataset (Zero Net Worth) and user dataset
      let zeroNetDs = null;
      let netUserDs = null;
      netWorthChartInstance.data.datasets.forEach(ds => {
        if (ds.label === 'Zero Net Worth') zeroNetDs = ds;
        if (ds.label === 'You' && userActive) netUserDs = ds;
      });
      // Build new datasets: median + selected percentiles + zero line + user
      let netDatasets = netResult.datasets.slice();
      if (zeroNetDs) netDatasets.push(zeroNetDs);
      if (netUserDs) netDatasets.push(netUserDs);
      netWorthChartInstance.data.datasets = netDatasets;
      // Compute axis for net worth chart
      let netVals = netResult.values.slice();
      if (userActive) netVals.push(userNetWorthVal);
      // include zero line values (it's 0 across ages) in axis to guarantee zero appears but computeAxis will handle automatically
      netVals = netVals.concat(new Array(ageLabels.length).fill(0));
      let netAxis = computeAxis(netVals, 200000);
      netWorthChartInstance.options.scales.y.min = netAxis.min;
      netWorthChartInstance.options.scales.y.max = netAxis.max;
      netWorthChartInstance.update();

      // Wealth Composition chart — assets stacked above zero, debts stacked below, plus net worth line
      (function updateWealthComposition(){
        const useNet = (unit==='households' ? baseNetWorth : baseIndNetWorth).map(v => Math.round(v * netRatio));
        // Approximate debt curve: peaks near mid-30s, declines after 50
        const peak = unit==='households' ? 200000 : 120000;
        const centerAge = 37; const sigma = 10;
        const debts = ageLabels.map((ageStr,i)=>{
          const age = parseInt(ageStr,10);
          const gauss = Math.exp(-0.5 * Math.pow((age - centerAge)/sigma, 2));
          let val = Math.round(peak * gauss);
          if (age < 20) val = Math.round(val*0.4);
          if (age > 70) val = Math.round(val*0.2);
          return val; // positive magnitude; we'll plot negative
        });
        // Total assets approximated as net worth + debt
        const totalAssets = useNet.map((nw,i)=> Math.max(0, nw + debts[i]));
        // Split assets by shares varying with age (more financial/pension later)
        const shares = ageLabels.map((aStr,i)=>{
          const t = i/(ageLabels.length-1);
          const realEstate = 0.55 - 0.15*t; // falls with age
          const financial = 0.25 + 0.15*t; // rises with age
          const pensions = 0.20 + 0.00*t;
          const sum = realEstate + financial + pensions;
          return { re: realEstate/sum, fin: financial/sum, pen: pensions/sum };
        });
        const re = totalAssets.map((TA,i)=> Math.round(TA * shares[i].re));
        const fin = totalAssets.map((TA,i)=> Math.round(TA * shares[i].fin));
        const pen = totalAssets.map((TA,i)=> Math.round(TA * shares[i].pen));
        const deb = debts.map(d=> -d); // negative for plotting
        const net = useNet; // already median net worth
        wealthCompositionChartInstance.data.labels = ageLabels;
        wealthCompositionChartInstance.data.datasets[0].data = re;
        wealthCompositionChartInstance.data.datasets[1].data = fin;
        wealthCompositionChartInstance.data.datasets[2].data = pen;
        wealthCompositionChartInstance.data.datasets[3].data = deb;
        wealthCompositionChartInstance.data.datasets[4].data = net;
        // Stacking: assets vs debts separated
        wealthCompositionChartInstance.options.scales.y.stacked = true;
        wealthCompositionChartInstance.options.scales.x.stacked = true;
        // Compute axis from combined arrays
        let wVals = re.concat(fin, pen, deb, net);
        const wAxis = computeAxis(wVals, 200000);
        wealthCompositionChartInstance.options.scales.y.min = wAxis.min;
        wealthCompositionChartInstance.options.scales.y.max = wAxis.max;
        wealthCompositionChartInstance.update();
      })();

      // Update scatter chart (Income vs Net Worth, Median). X = median total income, Y = median net worth for selected unit.
      const scaledTotal = (unit === 'households'
        ? baseTotalIncome.map(v => Math.round(v * incomeRatio * HOUSEHOLD_INCOME_MULTIPLIER))
        : baseTotalIncome.map(v => Math.round(v * incomeRatio)));
      const scaledNetForScatter = (unit === 'households'
        ? baseNetWorth.map(v => Math.round(v * netRatio))
        : baseIndNetWorth.map(v => Math.round(v * netRatio)));
      const scatterData = [];
      for (let i = 0; i < ageLabels.length; i++) {
        scatterData.push({ x: scaledTotal[i], y: scaledNetForScatter[i] });
      }
      // Base dataset is median
      scatterChartInstance.data.datasets[0].label = 'Median';
      scatterChartInstance.data.datasets[0].data = scatterData;
      // Add faint percentile overlays when selected (p10, p25, p75, p90, p99)
      const pToArray = (pKey) => {
        const incMap = { p10: baseTotalIncomeP10, p25: baseTotalIncomeP25, p50: baseTotalIncome, p75: baseTotalIncomeP75, p90: baseTotalIncomeP90, p99: baseTotalIncomeP99 };
        const netMapH = { p10: baseNetWorthP10, p25: baseNetWorthP25, p50: baseNetWorth, p75: baseNetWorthP75, p90: baseNetWorthP90, p99: baseNetWorthP99 };
        const netMapI = { p10: baseIndNetWorthP10, p25: baseIndNetWorthP25, p50: baseIndNetWorth, p75: baseIndNetWorthP75, p90: baseIndNetWorthP90, p99: baseIndNetWorthP99 };
        const incArr = (incMap[pKey] || baseTotalIncome).map(v => Math.round(v * incomeRatio * (unit === 'households' ? HOUSEHOLD_INCOME_MULTIPLIER : 1)));
        const netArr = ((unit === 'households' ? netMapH[pKey] : netMapI[pKey]) || (unit==='households'?baseNetWorth:baseIndNetWorth)).map(v => Math.round(v * netRatio));
        return { incArr, netArr };
      };
      // Remove any previous percentile overlay datasets (keep index 0 for median and any 'You' dataset)
      scatterChartInstance.data.datasets = scatterChartInstance.data.datasets.filter((ds, i) => i === 0 || ds.label === 'You');
      const faintGreen = 'rgba(102,187,106,0.14)';
      const faintBlue = 'rgba(41,182,246,0.14)';
      // No percentile overlays on the scatter chart — keep only the median (and 'You' marker if present)
      // Colour code the scatter points by age.  We map age from blue to red across the
      // entire age range using an HSL colour gradient.  Each point is given a
      // corresponding colour so that younger ages appear blue and older ages fade to red.
      const scatterColors = ageLabels.map((lbl, idx) => {
        // Compute a colour gradient from blue to red.  We slightly raise the
        // lightness to improve visibility against the dark background.
        const t = idx / (ageLabels.length - 1);
        const hue = 240 - 240 * t; // 240 (blue) to 0 (red)
        // Use higher lightness (60%) for better contrast and keep saturation at 70%
        return `hsl(${hue}, 70%, 60%)`;
      });
      scatterChartInstance.data.datasets[0].pointBackgroundColor = scatterColors;
      scatterChartInstance.data.datasets[0].pointBorderColor = scatterColors;
      scatterChartInstance.data.datasets[0].backgroundColor = scatterColors;
      // Compute separate axis bounds for scatter chart (x and y). x step 5000, y step 200000.
      // Include median scatter points and percentile overlay datasets when computing axis bounds.
      const allScatterX = [];
      const allScatterY = [];
      scatterChartInstance.data.datasets.forEach(ds => {
        (ds.data || []).forEach(pt => {
          if (pt && typeof pt === 'object') {
            if (typeof pt.x === 'number' && !isNaN(pt.x)) allScatterX.push(pt.x);
            if (typeof pt.y === 'number' && !isNaN(pt.y)) allScatterY.push(pt.y);
          } else if (typeof pt === 'number' && !isNaN(pt)) {
            allScatterY.push(pt);
          }
        });
      });
      const xAxis = computeAxis(allScatterX.length ? allScatterX : scatterData.map(pt => pt.x), 5000);
      const yAxis = computeAxis(allScatterY.length ? allScatterY : scatterData.map(pt => pt.y), 200000);
      scatterChartInstance.options.scales = {
        x: {
          type: 'linear',
          position: 'bottom',
          min: Math.max(0, xAxis.min),
          max: xAxis.max,
          ticks: {
            color: '#b0c5e8',
            callback: function(value) {
              const rounded = Math.round(value / 1000) * 1000;
              return '$' + rounded.toLocaleString();
            },
            stepSize: 5000,
            maxTicksLimit: 10
          },
          grid: { color: '#1f3a64' }
        },
        y: {
          min: yAxis.min,
          max: yAxis.max,
          ticks: {
            color: '#b0c5e8',
            callback: function(value) {
              const rounded = Math.round(value / 1000) * 1000;
              return '$' + rounded.toLocaleString();
            },
            stepSize: 200000
          },
          grid: { color: '#1f3a64' }
        }
      };
      scatterChartInstance.update();

      // Province bar chart with percentile overlays and user line
      // Rebuild the bar dataset and percentile line datasets for the province chart.
      // Highlight the selected province by changing its bar colour.
      const barColors = baseProvinceLabels.map(label => label === region ? '#ffa726' : '#66bb6a');
      // Remove any existing user dataset before rebuilding the chart
      const existingDs = provinceChartInstance.data.datasets;
      let userLine = null;
      // Extract the bar dataset and existing user line if present
      let barDataset = null;
      existingDs.forEach(ds => {
        if (ds.type === 'bar' || !ds.type) {
          barDataset = ds;
        } else if (ds.label === 'You') {
          userLine = ds;
        }
      });
      if (!barDataset) {
        // Fallback in case of unexpected structure
        barDataset = { label: 'Median Net Worth', data: baseProvinceValues.slice(), backgroundColor: barColors, type: 'bar' };
      }
      // Update bar data and colours
      barDataset.data = baseProvinceValues.slice();
      barDataset.backgroundColor = barColors;
      barDataset.order = 1;
      // For province chart we display the median as bars and draw whiskers
      // representing the 10th and 90th percentiles via a drawing plugin.
      // Choose base values according to unit (households vs individuals).
      const baseProvinceValsForUnit = (unit === 'households')
        ? baseProvinceValues.slice()
        : baseProvinceValues.map(v => (v < 0 ? Math.round(v * 1.5) : Math.round(v * 0.6)));
      // Update bar dataset data to use unit-aware values
      barDataset.data = baseProvinceValsForUnit.slice();
      // Compute whisker values as proportional tails of the median bars
      const provincePctRatios = { p10: 0.10, p90: 1.80 };
      const p10Values = baseProvinceValsForUnit.map(v => Math.round(v * provincePctRatios.p10));
      const p90Values = baseProvinceValsForUnit.map(v => Math.round(v * provincePctRatios.p90));
      // Store whisker values on the chart instance for the provinceWhiskers plugin
      provinceChartInstance._whiskers = { p10: p10Values, p90: p90Values };
      // Only the median bar dataset is used for drawing; user line will be re-added by addUserMarkers()
      provinceChartInstance.data.datasets = [ barDataset ];
      // Compute axis bounds including bars, whiskers and user value if present
      let provinceValsForAxis = baseProvinceValsForUnit.slice();
      // include whisker values so the y-axis covers the 10th-90th range
      provinceValsForAxis = provinceValsForAxis.concat(p10Values, p90Values);
      if (userActive) provinceValsForAxis.push(userNetWorthVal);
      let provinceAxis = computeAxis(provinceValsForAxis, 50000);
      provinceChartInstance.options.scales.y.beginAtZero = true;
      provinceChartInstance.options.scales.y.min = 0;
      provinceChartInstance.options.scales.y.max = provinceAxis.max;
      provinceChartInstance.update();

      // Province income chart (median and percentile income by province)
      // Compute a representative median income for each province using the national
      // median employment income at age 40 (baseIncome[22]) scaled by the
      // province-specific income ratio.  This yields a single value per
      // province suitable for bar display.
      const baseMedianIncome = (unit === 'households') ? Math.round(baseIncome[22] * HOUSEHOLD_INCOME_MULTIPLIER) : baseIncome[22];
      const provinceIncomeBars = baseProvinceLabels.map(lbl => {
        const ratio = incomeRatios[lbl] || 1;
        return Math.round(baseMedianIncome * ratio);
      });
      // Highlight the selected province in orange
      const incomeBarColors = baseProvinceLabels.map(lbl => lbl === region ? '#ffa726' : '#42a5f5');
      // Define constant percentile ratios for income across provinces.  These
      // values approximate the 10th, 25th, 75th, 90th and 99th percentile as
      // proportions of the median income, based on 2016 census income
      // distributions【605841652791315†L220-L244】.
      // Province income chart: show median bars and store 10th/90th for whiskers
      const provinceIncomePctRatios = { p10: 0.22, p90: 2.44 };
      const p10IncomeValues = provinceIncomeBars.map(v => Math.round(v * provinceIncomePctRatios.p10));
      const p90IncomeValues = provinceIncomeBars.map(v => Math.round(v * provinceIncomePctRatios.p90));
      // Store whiskers for the income chart and set the median bars
      provinceIncomeChartInstance._whiskers = { p10: p10IncomeValues, p90: p90IncomeValues };
      provinceIncomeChartInstance.data.datasets = [ { label: 'Median Income', data: provinceIncomeBars, backgroundColor: incomeBarColors, type: 'bar' } ];
      // Ensure axis includes whiskers
      let provinceIncomeVals = provinceIncomeBars.slice();
      provinceIncomeVals = provinceIncomeVals.concat(p10IncomeValues, p90IncomeValues);
      if (userActive) provinceIncomeVals.push(userIncomeVal);
      let provinceIncomeAxis = computeAxis(provinceIncomeVals, 5000);
      provinceIncomeChartInstance.options.scales.y.beginAtZero = true;
      provinceIncomeChartInstance.options.scales.y.min = 0;
      provinceIncomeChartInstance.options.scales.y.max = provinceIncomeAxis.max;
      provinceIncomeChartInstance.update();
      // Net discretionary chart: compute whiskers from income percentiles minus spending
      if (provinceDiscretionaryChartInstance) {
        try {
          // Choose spending estimates based on unit (approximate individuals at 60% of household spending)
          const spendingUsed = (unit === 'households') ? provinceSpendingEstimates : provinceSpendingEstimates.map(v => Math.round(v * 0.6));
          // Use provinceIncomeBars (unit-aware) and spendingUsed to compute median discretionary values
          const discValues = provinceIncomeBars.map((inc, idx) => Math.round(inc - (spendingUsed[idx] || 0)));
          // Compute whiskers from earlier p10/p90 income values adjusted by spendingUsed
          const p10DiscValues = p10IncomeValues.map((v, idx) => Math.round(v - (spendingUsed[idx] || 0)));
          const p90DiscValues = p90IncomeValues.map((v, idx) => Math.round(v - (spendingUsed[idx] || 0)));
          provinceDiscretionaryChartInstance._whiskers = { p10: p10DiscValues, p90: p90DiscValues };
          // Update the bar dataset and axis to reflect unit-aware discretionary values
          provinceDiscretionaryChartInstance.data.datasets = [ { label: 'Net Discretionary Income', data: discValues, backgroundColor: baseProvinceLabels.map(lbl => lbl === region ? '#ffa726' : '#00bfa5') } ];
          let discVals = discValues.slice();
          discVals = discVals.concat(p10DiscValues, p90DiscValues);
          let discAxis = computeAxis(discVals, 5000);
          provinceDiscretionaryChartInstance.options.scales.y.min = Math.min(discAxis.min, -20000);
          provinceDiscretionaryChartInstance.options.scales.y.max = Math.max(discAxis.max, 40000);
          provinceDiscretionaryChartInstance.update();
        } catch (e) { /* no-op */ }
      }
      
      // Update titles
      const suffix = region === 'Canada' ? 'Canada' : region;
      const unitTitle = unit === 'households' ? 'Households' : 'Individuals';
      document.getElementById('incomeTitle').textContent = `Estimated Median Employment Income by Age (${unitTitle}, 2025) - ${suffix}`;
      document.getElementById('compositionTitle').textContent = `Income Composition Breakdown by Age (Median, 2025) - ${suffix}`;
      document.getElementById('netWorthTitle').textContent = `Estimated Median Net Worth by Age (${unitTitle}, 2025) - ${suffix}`;
      document.getElementById('scatterTitle').textContent = `Income vs Net Worth by Age (Median, 2025) - ${suffix}`;
      // Update percentile charts for current region using region-wide medians
      let regionMedianNetWorth;
      let regionMedianIncome;
      const provinceIndex = baseProvinceLabels.indexOf(region);
      const nationalMedianNetWorthHousehold = 652286; // projected national household median
      const nationalMedianIncomeIndividual = baseIncome[22];
      const nationalMedianNetWorth = (unit === 'households') ? nationalMedianNetWorthHousehold : Math.round(nationalMedianNetWorthHousehold * 0.6);
      const nationalMedianIncome = (unit === 'households') ? Math.round(nationalMedianIncomeIndividual * HOUSEHOLD_INCOME_MULTIPLIER) : nationalMedianIncomeIndividual;
      if (region === 'Canada' || provinceIndex === -1) {
        regionMedianNetWorth = nationalMedianNetWorth;
        regionMedianIncome = nationalMedianIncome;
      } else {
        regionMedianNetWorth = (unit === 'households') ? baseProvinceValues[provinceIndex] : Math.round(baseProvinceValues[provinceIndex] * 0.6);
        regionMedianIncome = Math.round((incomeRatios[region] || 1) * nationalMedianIncome);
      }
      // Estimate normal distribution parameters from anchor ratios
      function estimateNormalParams(median, r10, r90) {
        const z = 1.2815515655446004; // Phi^{-1}(0.90)
        const x10 = median * r10;
        const x90 = median * r90;
        const s10 = (median - x10) / z;
        const s90 = (x90 - median) / z;
        const sigma = Math.max(1, (s10 + s90) / 2);
        return { mu: median, sigma };
      }
      function normInv(p) {
        // Acklam's approximation for inverse normal CDF
        // https://web.archive.org/web/20150910044736/http://home.online.no/~pjacklam/notes/invnorm/
        const a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
        const b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
        const c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
        const d = [7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
        const plow = 0.02425; const phigh = 1 - plow;
        let q, r;
        if (p < plow) {
          q = Math.sqrt(-2 * Math.log(p));
          return (((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
                 ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
        }
        if (p > phigh) {
          q = Math.sqrt(-2 * Math.log(1 - p));
          return -(((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
                   ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
        }
        q = p - 0.5; r = q*q;
        return (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5]) * q /
               (((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1);
      }
      // Build histogram-style distributions from normal approximation
      function buildNormalHistogram(mu, sigma, binCount = 30) {
        const minX = Math.max(0, mu - 3.5 * sigma);
        const maxX = mu + 3.5 * sigma;
        const width = (maxX - minX) / binCount;
        const pts = [];
        const invSQRT2PI = 1 / Math.sqrt(2 * Math.PI);
        for (let i = 0; i < binCount; i++) {
          const xMid = minX + (i + 0.5) * width;
          const z = (xMid - mu) / sigma;
          const pdf = invSQRT2PI * Math.exp(-0.5 * z * z) / sigma; // density per $1
          const prob = pdf * width; // probability mass in this bin
          pts.push({ x: xMid, y: prob * 100 }); // percentage
        }
        return { points: pts, minX, maxX };
      }
      const netParams = estimateNormalParams(regionMedianNetWorth, 0.10, 1.80);
      const incParams = estimateNormalParams(regionMedianIncome, 0.22, 2.44);
      const netHist = buildNormalHistogram(netParams.mu, netParams.sigma);
      const incHist = buildNormalHistogram(incParams.mu, incParams.sigma);

      // Update datasets
      percentileNetWorthChartInstance.data.labels = [];
      percentileNetWorthChartInstance.data.datasets = [ { label: 'Net Worth Distribution', data: netHist.points, backgroundColor: '#66bb6a' } ];
      percentileIncomeChartInstance.data.labels = [];
      percentileIncomeChartInstance.data.datasets = [ { label: 'Income Distribution', data: incHist.points, backgroundColor: '#29b6f6' } ];
      // Axes: X in dollars (linear), Y in percent probability
      percentileNetWorthChartInstance.options.scales = {
        x: { type: 'linear', position: 'bottom', ticks: { color: '#b0c5e8', callback: (v)=> '$' + Math.round(v/1000).toLocaleString() + 'k', maxTicksLimit: 10 }, grid: { color: '#1f3a64' }, min: netHist.minX, max: netHist.maxX },
        y: { min: 0, ticks: { color: '#b0c5e8', callback: (v)=> v + '%' }, grid: { color: '#1f3a64' } }
      };
      percentileIncomeChartInstance.options.scales = {
        x: { type: 'linear', position: 'bottom', ticks: { color: '#b0c5e8', callback: (v)=> '$' + Math.round(v/1000).toLocaleString() + 'k', maxTicksLimit: 10 }, grid: { color: '#1f3a64' }, min: incHist.minX, max: incHist.maxX },
        y: { min: 0, ticks: { color: '#b0c5e8', callback: (v)=> v + '%' }, grid: { color: '#1f3a64' } }
      };
      // Save dist params for tooltips
      percentileNetWorthChartInstance.options.plugins.distParams = { mu: netParams.mu, sigma: netParams.sigma };
      percentileIncomeChartInstance.options.plugins.distParams = { mu: incParams.mu, sigma: incParams.sigma };
      // Draw a subtle median line on both distributions
      percentileNetWorthChartInstance.options.plugins.medianVLine = { xValue: netParams.mu, color: 'rgba(255,255,255,0.6)', dash: [2,2], width: 1, label: 'Median' };
      percentileIncomeChartInstance.options.plugins.medianVLine = { xValue: incParams.mu, color: 'rgba(255,255,255,0.6)', dash: [2,2], width: 1, label: 'Median' };
      // Custom tooltip for histograms (percent at $x)
      const histLabelPctile = (ctx) => {
        const x = ctx.parsed?.x ?? 0;
        const dp = ctx?.chart?.options?.plugins?.distParams || { mu: 0, sigma: 1 };
        function erf(x){ const sign=x<0?-1:1; x=Math.abs(x); const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911; const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x); return sign*y; }
        function normCdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
        const pct = Math.max(0, Math.min(100, 100*normCdf((x - dp.mu)/Math.max(1, dp.sigma))));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        return `Percentile: ${toOrdinal(pct)} — $${Math.round(x).toLocaleString()}`;
      };
      percentileNetWorthChartInstance.options.plugins.tooltip = { mode: 'nearest', intersect: true, callbacks: { label: histLabelPctile } };
      percentileIncomeChartInstance.options.plugins.tooltip = { mode: 'nearest', intersect: true, callbacks: { label: histLabelPctile } };
      document.getElementById('percentileNetWorthTitle').textContent = `Net Worth Distribution (Histogram, 2025) - ${suffix}`;
      document.getElementById('percentileIncomeTitle').textContent = `Income Distribution (Histogram, 2025) - ${suffix}`;
      if (userActive) {
        // Draw vertical line at user's value on histograms with percentile labels
        function erf(x){ const sign=x<0?-1:1; x=Math.abs(x); const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911; const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x); return sign*y; }
        function normCdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
        const netPct = Math.max(0, Math.min(100, 100*normCdf((userNetWorthVal - netParams.mu)/Math.max(1,netParams.sigma))));
        const incPct = Math.max(0, Math.min(100, 100*normCdf((userIncomeVal - incParams.mu)/Math.max(1,incParams.sigma))));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: userNetWorthVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(netPct)} percentile` };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: userIncomeVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(incPct)} percentile` };
      } else {
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: null };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: null };
      }
      percentileNetWorthChartInstance.update();
      percentileIncomeChartInstance.update();
      document.getElementById('provinceTitle').textContent = `Projected Median Net Worth by Province (2025)`;
      document.getElementById('provinceIncomeTitle').textContent = `Median Income by Province (2025)`;
      // If the user has entered comparison data, replot the markers after updating the charts.
      if (userActive) {
        addUserMarkers();
      }
    }

    /**
     * Generic chart creator
     * @param {string} canvasId
     * @param {Object} dataInfo
     * @param {string} type - Chart type (line or bar)
     */
function createChart(canvasId, dataInfo, type = 'line') {
  const ctx = document.getElementById(canvasId).getContext('2d');
  const axisLabels = dataInfo.axisLabels || {};
  const tickFontSize = dataInfo.tickFontSize || 12;
  const axisTitleColor = '#e0e6ed';

  // --- helpers ---
  const toRGBA = (hex, a=1) => {
    if (!hex) return `rgba(79,195,247,${a})`; // fallback light blue
    const h = hex.replace('#','');
    const bigint = parseInt(h, 16);
    const r = (h.length===3) ? ((bigint>>8)&0xF)*17 : (bigint>>16)&0xFF;
    const g = (h.length===3) ? ((bigint>>4)&0xF)*17 : (bigint>>8)&0xFF;
    const b = (h.length===3) ? (bigint&0xF)*17     : (bigint>>0)&0xFF;
    return `rgba(${r},${g},${b},${a})`;
  };

  // Flatten numeric values for y-scaling. Support datasets where data
  // items may be plain numbers or point objects like {x, y} used by
  // histograms/scatter datasets. We prefer y values when present.
  const allValues = [];
  dataInfo.datasets.forEach(ds => {
    (ds.data || []).forEach(v => {
      if (v && typeof v === 'object') {
        if (typeof v.y === 'number' && !isNaN(v.y)) allValues.push(v.y);
        else if (typeof v.x === 'number' && !isNaN(v.x)) allValues.push(v.x);
      } else if (typeof v === 'number' && !isNaN(v)) {
        allValues.push(v);
      }
    });
  });
  const minVal = allValues.length ? Math.min(...allValues) : 0;
  const maxVal = allValues.length ? Math.max(...allValues) : 1;
  const pad = (maxVal - minVal) * 0.05;
  let yMin = Math.floor((minVal - pad) / 1000) * 1000;
  let yMax = Math.ceil((maxVal + pad) / 1000) * 1000;

  if (dataInfo.step) {
    const range = yMax - yMin;
    const remainder = range % dataInfo.step;
    if (remainder !== 0) yMax += dataInfo.step - remainder;
  }

  // stacking only for non-scatter when at least one dataset has .stack
  const isStacked = type !== 'scatter' && dataInfo.datasets.some(ds => ds.stack);

  // Build datasets w/ safe colors + optional gradient fill
  const datasets = dataInfo.datasets.map((ds) => {
    const stroke = ds.borderColor || ds.color || '#29b6f6';
    let fillColor = ds.backgroundColor || (ds.fill ? toRGBA(stroke, 0.35) : 'transparent');

    // For stacked/filled areas, create a subtle vertical gradient (fade)
    if ((ds.fill || ds.stack) && type !== 'bar' && type !== 'scatter') {
      const grad = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
      grad.addColorStop(0, toRGBA(stroke, 0.45));
      grad.addColorStop(1, toRGBA(stroke, 0.05));
      fillColor = grad;
    }

    return {
      label: ds.label,
      data: ds.data,
      borderColor: stroke,
      backgroundColor: fillColor,
      borderWidth: ds.borderWidth || 2,
      tension: ds.tension ?? 0.3,
      fill: !!(ds.fill || ds.stack),
      stack: ds.stack || undefined,
      type: ds.type || undefined,
      pointRadius: ds.pointRadius ?? (type==='scatter' ? 4 : 2),
      pointHoverRadius: ds.pointHoverRadius ?? (type==='scatter' ? 5 : 5),
      pointHitRadius: ds.pointHitRadius ?? 10,
      borderDash: ds.borderDash || undefined,
      order: ds.order || 1,
      showLine: ds.showLine
    };
  });

  // X ticks
  const labels = dataInfo.labels || [];
  const xTickOptions = {
    color: '#b0c5e8',
    font: { size: tickFontSize },
    callback: function(value, index) { return labels[index]; }
  };
  if (type === 'bar') {
    xTickOptions.autoSkip = false; xTickOptions.maxRotation = 45; xTickOptions.minRotation = 45;
  } else if (type !== 'scatter') {
    xTickOptions.autoSkip = true; xTickOptions.maxTicksLimit = 10;
  }

  // Watermark colour: consistent faint blue across all charts
  const watermarkColor = '#6aa3f4';

  // Base options; special-case scatter axes below
  const options = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: { mode: 'nearest', intersect: true },
    hover: { mode: 'nearest', intersect: true },
    scales: {
      x: {
        stacked: isStacked,
        ticks: xTickOptions,
        grid: { color: '#1f3a64' }
      },
      y: {
        stacked: isStacked,
        min: yMin,
        max: yMax,
      ticks: {
        color: '#b0c5e8',
        font: { size: tickFontSize },
        callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); },
        stepSize: dataInfo.step,
        maxTicksLimit: dataInfo.step ? Math.ceil((yMax - yMin)/dataInfo.step) + 1 : undefined
      },
      grid: { color: '#1f3a64' }
      }
    },
    plugins: {
    legend: { display: datasets.length > 1, labels: { color: '#e0e6ed', usePointStyle: true } },
      tooltip: {
        mode: 'nearest',
        intersect: true,
        callbacks: {
          label: (ctx) => {
            const label = ctx.dataset.label || '';
            const y = (ctx.parsed?.y ?? ctx.raw?.y ?? ctx.raw);
            if (typeof y === 'number') return `${label}: $${y.toLocaleString()}`;
            return label;
          }
        }
      },
      watermark: { text: 'wealthdashboard.ca', color: watermarkColor, opacity: 0.10, fontSize: 18 }
    }
  };

  // Proper axes for scatter from the start (prevents the blank-chart error)
  if (type === 'scatter') {
    options.scales.x = {
      type: 'linear',
      position: 'bottom',
      ticks: {
        color: '#b0c5e8',
        font: { size: tickFontSize },
        callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); },
        maxTicksLimit: 10
      },
      grid: { color: '#1f3a64' }
    };
    options.scales.y = {
      min: yMin,
      max: yMax,
      ticks: {
        color: '#b0c5e8',
        font: { size: tickFontSize },
        callback: function(v){ const r = Math.round(v/1000)*1000; return '$' + r.toLocaleString(); }
      },
      grid: { color: '#1f3a64' }
    };
  }

  const setAxisTitle = (axis, text) => {
    if (!text) return;
    if (!options.scales[axis]) options.scales[axis] = {};
    options.scales[axis].title = {
      display: true,
      text,
      color: axisTitleColor,
      font: { size: tickFontSize, weight: '600' },
      padding: { top: 8, bottom: 8 }
    };
  };
  setAxisTitle('x', axisLabels.x);
  setAxisTitle('y', axisLabels.y);

  if (dataInfo.tooltip) {
    options.plugins.tooltip = Object.assign({}, options.plugins.tooltip, dataInfo.tooltip);
  }

  const chartInstance = new Chart(ctx, { type, data: { labels, datasets }, options });
  chartInstance.__step = dataInfo.step || null;
  return chartInstance;
}

    let chartsInitialized = false;
    function initCharts() {
      if (chartsInitialized) return;
      // Build Chart.js instances for each canvas using the base (Canada) data
      incomeChartInstance = createChart('incomeChart', {
        labels: ageLabels,
        datasets: [ { label: 'Median Employment Income (Individuals)', data: baseIncome, color: '#29b6f6' } ],
        step: 5000,
        axisLabels: {
          x: 'Age (Years - Individuals)',
          y: 'Median Employment Income ($ - Individuals / Households)'
        }
      }, 'line');

      // Build the income composition chart.  This stacked area chart will show the
      // breakdown of total income into employment, investment, pension and transfer
      // components.  Each dataset is initially populated with zeros; actual values
      // are computed in updateCharts() based on the selected region and age.

      compositionChartInstance = createChart('compositionChart', {
  labels: ageLabels,
  datasets: [
    {
      label: 'Employment Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#42a5f5',
      backgroundColor: 'rgba(66,165,245,0.6)',
      fill: true,
      stack: 'income'
    },
    {
      label: 'Investment Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#66bb6a',
      backgroundColor: 'rgba(102,187,106,0.6)',
      fill: true,
      stack: 'income'
    },
    {
      label: 'Pension Income',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#ffa726',
      backgroundColor: 'rgba(255,167,38,0.6)',
      fill: true,
      stack: 'income'
    },
    {
      label: 'Government Transfers',
      data: baseTotalIncome.map(() => 0),
      borderColor: '#ab47bc',
      backgroundColor: 'rgba(171,71,188,0.6)',
      fill: true,
      stack: 'income'
    }
  ],
  step: 5000,
  axisLabels: {
    x: 'Age (Years - Individuals)',
    y: 'Income Components ($ - Individuals / Households)'
  }
}, 'line');

      // Define a zero net‑worth reference line for net worth charts. This will appear as a light blue dashed line.
      const baseZeroData = new Array(ageLabels.length).fill(0);
      const zeroLine = {
        label: 'Zero Net Worth',
        data: baseZeroData,
        color: '#4fc3f7',
        borderDash: [4,4],
        borderWidth: 1,
        pointRadius: 0
      };
      // Build the combined net worth chart (households vs individuals).  Both series
      // are shown by default; additional percentile lines can be toggled via the
      // percentile selector.  A zero net worth reference line is included.
      netWorthChartInstance = createChart('netWorthChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Median Net Worth (Households)', data: baseNetWorth, color: '#66bb6a' },
          Object.assign({}, zeroLine, { data: baseZeroData.slice() })
        ],
        step: 200000,
        axisLabels: {
          x: 'Age (Years - Individuals)',
          y: 'Median Net Worth ($ - Households / Individuals)'
        }
      }, 'line');
      // Build the scatter chart for income vs net worth.  This uses the median total income
      // as the x-value and the median net worth (households) as the y-value for each age.
      scatterChartInstance = createChart('scatterChart', {
        labels: ageLabels,
        datasets: [
          {
            label: 'Income vs Net Worth',
            data: [],
            borderColor: '#66bb6a',
            backgroundColor: '#66bb6a',
            pointBackgroundColor: '#66bb6a',
            pointBorderColor: '#66bb6a',
            // Increase the base point size to improve visibility.  A larger
            // point radius and hover radius make scatter points easier to see.
            pointRadius: 5,
            pointHoverRadius: 6,
            showLine: false
          }
        ],
        // We will update the step sizes dynamically in updateCharts
        step: null,
        axisLabels: {
          x: 'Median Total Income ($ - Households / Individuals)',
          y: 'Median Net Worth ($ - Households / Individuals)'
        }
      }, 'scatter');
      // The province chart remains the same; median provincial values are used as bars.
      // Build the province bar chart. Use a default color for all bars; the
      // selected province will be highlighted via updateCharts().
      provinceChartInstance = createChart('provinceChart', {
        labels: baseProvinceLabels,
        datasets: [ { label: 'Median Net Worth', data: baseProvinceValues, backgroundColor: '#66bb6a' } ],
        step: 50000,
        axisLabels: {
          x: 'Province (Households)',
          y: 'Median Net Worth ($ - Households)'
        }
      }, 'bar');

      // Build the provincial median income chart.  This bar chart displays
      // typical median employment income for each province using the
      // baseProvinceIncomeValues array.  Percentile lines are drawn on top
      // via updateCharts() when selected from the percentile selector.
      provinceIncomeChartInstance = createChart('provinceIncomeChart', {
        labels: baseProvinceLabels,
        datasets: [ { label: 'Median Income', data: baseProvinceIncomeValues, backgroundColor: '#42a5f5' } ],
        step: 5000,
        axisLabels: {
          x: 'Province (Individuals / Households)',
          y: 'Median Employment Income ($)'
        }
      }, 'bar');

      provinceDiscretionaryChartInstance = createChart('provinceDiscretionaryChart', {
        labels: baseProvinceLabels,
        datasets: [
          {
            label: 'Net Discretionary Income (Households)',
            data: provinceDiscretionaryValues,
            backgroundColor: baseProvinceLabels.map(() => '#00bfa5')
          }
        ],
        step: 5000,
        axisLabels: {
          x: 'Province (Households)',
          y: 'Net Discretionary Income ($ - Households)'
        },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const idx = ctx.dataIndex;
              const income = provinceHouseholdIncomeValues[idx];
              const spending = provinceSpendingEstimates[idx];
              const net = provinceDiscretionaryValues[idx];
              return [
                `Median income: $${income.toLocaleString()}`,
                `Cost of living: $${spending.toLocaleString()}`,
                `Net discretionary: $${net.toLocaleString()}`
              ];
            }
          }
        }
      }, 'bar');

      // Wealth Composition baseline; data is computed in updateCharts per region/unit
      wealthCompositionChartInstance = createChart('wealthCompositionChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Real Estate', data: new Array(ageLabels.length).fill(0), borderColor: '#66bb6a', backgroundColor: 'rgba(102,187,106,0.55)', fill: true, stack: 'assets' },
          { label: 'Financial Assets', data: new Array(ageLabels.length).fill(0), borderColor: '#29b6f6', backgroundColor: 'rgba(41,182,246,0.55)', fill: true, stack: 'assets' },
          { label: 'Pensions', data: new Array(ageLabels.length).fill(0), borderColor: '#ab47bc', backgroundColor: 'rgba(171,71,188,0.55)', fill: true, stack: 'assets' },
          { label: 'Debts', data: new Array(ageLabels.length).fill(0), borderColor: '#ffa726', backgroundColor: 'rgba(255,167,38,0.55)', fill: true, stack: 'debts' },
          { label: 'Net Worth', data: new Array(ageLabels.length).fill(0), color: '#66bb6a', type: 'line', pointRadius: 0, order: 999 }
        ],
        step: 200000,
        axisLabels: {
          x: 'Age (Years - Individuals)',
          y: 'Assets & Liabilities ($ - Households / Individuals)'
        }
      }, 'line');

      // Income Percentile by Gender — line chart similar to individual income by age (placeholder ratios)
      genderIncomeChartInstance = createChart('genderIncomeChart', {
        labels: ageLabels,
        datasets: [
          { label: 'Women (Median)', data: new Array(ageLabels.length).fill(0), color: '#42a5f5' },
          { label: 'Men (Median)', data: new Array(ageLabels.length).fill(0), color: '#1e88e5' }
        ],
        step: 5000,
        axisLabels: {
          x: 'Age (Years - Individuals)',
          y: 'Median Employment Income ($ - Individuals / Households)'
        }
      }, 'line');

      // Initialize distribution charts as bar (histogram-like)
      percentileNetWorthChartInstance = createChart('percentileNetWorthChart', {
        labels: [],
        datasets: [ { label: 'Net Worth Distribution', data: [], backgroundColor: '#66bb6a' } ],
        step: null,
        axisLabels: {
          x: 'Net Worth ($ - Households / Individuals)',
          y: 'Share of Households (%)'
        }
      }, 'bar');
      percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: null };

      percentileIncomeChartInstance = createChart('percentileIncomeChart', {
        labels: [],
        datasets: [ { label: 'Income Distribution', data: [], backgroundColor: '#29bbf6' } ],
        step: null,
        axisLabels: {
          x: 'Employment Income ($ - Individuals / Households)',
          y: 'Share of Tax Filers (%)'
        }
      }, 'bar');
      percentileIncomeChartInstance.options.plugins.userVLine = { xValue: null };
      // Hook up the dropdown to update the charts when a region is selected
      const select = document.getElementById('provinceSelect');
      select.addEventListener('change', function() {
        const region = this.value;
        updateCharts(region);
      });

      // Percentiles are always shown by default; no selector to watch.
      // Unit selector: switch between Households and Individuals across all charts
      const unitSelectEl = document.getElementById('unitSelect');
      if (unitSelectEl) {
        unitSelectEl.addEventListener('change', function() {
          const region = document.getElementById('provinceSelect').value;
          updateCharts(region);
        });
      }
      // Initialize with Canada selected
      updateCharts('Canada');

      // Add per-chart download buttons once charts are created
      addDownloadButtons();

      // Attach event listeners for user comparison and reset
      document.getElementById('compareBtn').addEventListener('click', function() {
        ensureChartsInitialized();
        plotUserData();
      });
      document.getElementById('resetBtn').addEventListener('click', function() {
        ensureChartsInitialized();
        resetUserData();
      });
      chartsInitialized = true;
    }

    function ensureChartsInitialized() { if (!chartsInitialized) initCharts(); }

    // Setup nav interactions and lazy initialization once DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      setupNav();
      const firstSection = document.getElementById('section-income-charts');
      if (firstSection && 'IntersectionObserver' in window) {
        const io = new IntersectionObserver((entries, obs) => {
          entries.forEach(e => { if (e.isIntersecting) { initCharts(); obs.disconnect(); } });
        }, { root: null, rootMargin: '300px', threshold: 0.02 });
        io.observe(firstSection);
      } else {
        // Fallback: initialize immediately
        initCharts();
      }
    });

    /* Navigation setup: smooth scrolling and active-section highlighting */
    function setupNav() {
      try {
        // Smooth scroll (CSS fallback is applied globally)
        const links = Array.from(document.querySelectorAll('#topNav .nav-link'));
        links.forEach(a => {
          a.addEventListener('click', function(e){
            e.preventDefault();
            const id = this.getAttribute('href').replace('#','');
            const el = document.getElementById(id);
            if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
          });
        });

        // Active link highlighting via IntersectionObserver
        if ('IntersectionObserver' in window) {
          const sections = links.map(l => document.getElementById(l.getAttribute('href').replace('#',''))).filter(Boolean);
          const io = new IntersectionObserver((entries) => {
            entries.forEach(ent => {
              const id = ent.target.id;
              const link = document.querySelector(`#topNav .nav-link[href='#${id}']`);
              if (link) link.classList.toggle('active', ent.isIntersecting);
            });
          }, { root: null, threshold: 0.3 });
          sections.forEach(s => io.observe(s));
        }
      } catch(e){ console.error('Nav setup failed', e); }
    }

    // Flags and storage for user input comparison
    let userActive = false;
    let userAgeVal, userIncomeVal, userNetWorthVal;

    /**
     * Handle plotting the user's input across all charts. Validates input
     * values and stores them in global variables. If validation fails,
     * notifies the user.
     */
    function plotUserData() {
      const ageInput = parseInt(document.getElementById('userAge').value, 10);
      const incomeInput = parseFloat(document.getElementById('userIncome').value);
      const netWorthInput = parseFloat(document.getElementById('userNetWorth').value);
      if (!ageInput || ageInput < 18 || ageInput > 100 || isNaN(incomeInput) || isNaN(netWorthInput)) {
        alert('Please enter a valid age between 18 and 100, and numeric values for income and net worth.');
        return;
      }
      if (incomeInput > 1000000) {
        alert('Please enter an income of $1,000,000 or less.');
        return;
      }
      if (netWorthInput > 100000000) {
        alert('Please enter a net worth of $100,000,000 or less.');
        return;
      }
      userActive = true;
      userAgeVal = ageInput;
      userIncomeVal = incomeInput;
      userNetWorthVal = netWorthInput;
      // After storing the user values, rescale all charts to include the new marker and redraw
      const region = document.getElementById('provinceSelect').value;
      updateCharts(region);
      // Update insight panel text after charts are refreshed
      try{ showYouVsEveryone(); }catch(e){}
    }

    /**
     * Add or update the user's markers on all charts using the stored values.
     */
    function addUserMarkers() {
      if (!userActive) return;
      const index = Math.max(0, Math.min(userAgeVal - 18, ageLabels.length - 1));
      // Add marker to each line chart
      addUserMarkerToChart(incomeChartInstance, userIncomeVal, index, 'You');
      // Place a marker on the income composition chart representing the user's total income
      addUserMarkerToChart(compositionChartInstance, userIncomeVal, index, 'You');
      addUserMarkerToChart(netWorthChartInstance, userNetWorthVal, index, 'You');
      addUserLineToBarChart(provinceChartInstance, userNetWorthVal, 'You');
      // Add a horizontal line on the provincial income chart for the user's income
      addUserLineToBarChart(provinceIncomeChartInstance, userIncomeVal, 'You');
      // Add a red "You" point to the scatter chart (income vs net worth)
      addUserPointToScatter(scatterChartInstance, userIncomeVal, userNetWorthVal, 'You');
      // Update vertical dashed user percentile lines on percentile charts
      try {
        const region = document.getElementById('provinceSelect').value;
        // Rebuild percentile curves for current region
        const provinceIndex = baseProvinceLabels.indexOf(region);
        const unitEl = document.getElementById('unitSelect');
        const unit = unitEl ? unitEl.value : 'households';
        const HOUSEHOLD_INCOME_MULTIPLIER = 1.6;
        const nationalMedianNetWorthHousehold = 652286;
        const nationalMedianIncomeIndividual = baseIncome[22];
        const nationalMedianNetWorth = (unit === 'households') ? nationalMedianNetWorthHousehold : Math.round(nationalMedianNetWorthHousehold * 0.6);
        const nationalMedianIncome = (unit === 'households') ? Math.round(nationalMedianIncomeIndividual * HOUSEHOLD_INCOME_MULTIPLIER) : nationalMedianIncomeIndividual;
        const regionMedianNetWorth = (region === 'Canada' || provinceIndex === -1) ? nationalMedianNetWorth : (unit==='households'? baseProvinceValues[provinceIndex] : Math.round(baseProvinceValues[provinceIndex]*0.6));
        const regionMedianIncome = Math.round((incomeRatios[region] || 1) * nationalMedianIncome);
        // Estimate parameters and compute user's percentile via normal CDF
        const z = 1.2815515655446004;
        const sNet = ((regionMedianNetWorth - regionMedianNetWorth*0.10)/z + (regionMedianNetWorth*1.80 - regionMedianNetWorth)/z)/2;
        const sInc = ((regionMedianIncome - regionMedianIncome*0.22)/z + (regionMedianIncome*2.44 - regionMedianIncome)/z)/2;
        function erf(x){ const sign=x<0?-1:1; x=Math.abs(x); const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911; const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x); return sign*y; }
        function normCdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
        // For histogram view, show a vertical line at user's value with percentile labels
        const netPct = Math.max(0, Math.min(100, 100*normCdf((userNetWorthVal - regionMedianNetWorth)/Math.max(1,sNet))));
        const incPct = Math.max(0, Math.min(100, 100*normCdf((userIncomeVal - regionMedianIncome)/Math.max(1,sInc))));
        const toOrdinal = (n)=>{n=Math.round(n); const s=['th','st','nd','rd']; const v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]);};
        percentileNetWorthChartInstance.options.plugins.userVLine = { xValue: userNetWorthVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(netPct)} percentile` };
        percentileIncomeChartInstance.options.plugins.userVLine = { xValue: userIncomeVal, color: 'rgba(244,67,54,1)', dash: [6,3], width: 2, label: `You: ${toOrdinal(incPct)} percentile` };
        percentileNetWorthChartInstance.update();
        percentileIncomeChartInstance.update();
      } catch (e) { /* no-op */ }
    }

    /**
     * Add or update a single-point marker on a line chart. The marker is
     * represented as a dataset with mostly null values except for the
     * specified index where the user value is placed.
     * @param {Chart} chart The Chart.js instance
     * @param {number} value The y-value to plot
     * @param {number} index The index corresponding to the user's age
     * @param {string} label The label used to identify the user's dataset
     */
    function addUserMarkerToChart(chart, value, index, label) {
      if (!chart) return;
      const length = chart.data.labels.length;
      const dataArray = new Array(length).fill(null);
      dataArray[index] = value;
      const existingIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const markerDataset = {
        label: label,
        data: dataArray,
        borderColor: 'rgba(244,67,54,1)',
        backgroundColor: 'rgba(244,67,54,1)',
        pointStyle: 'circle',
        pointRadius: 5,
        pointHoverRadius: 6,
        fill: false,
        showLine: false,
        borderWidth: 0,
        order: 9999,
        clip: false
      };
      if (existingIndex >= 0) {
        chart.data.datasets[existingIndex].data = dataArray;
      } else {
        chart.data.datasets.push(markerDataset);
      }
      // After placing the user marker, dynamically expand the y-axis
      // so that the user value is always visible. We recompute the axis
      // bounds based on all non-user datasets and the user value. This
      // prevents the chart from being clipped when the comparison value
      // exceeds the existing range.
      const step = chart.__step || null;
      let allVals = [];
      chart.data.datasets.forEach(ds => {
        if (ds.label !== label) {
          ds.data.forEach(v => {
            if (typeof v === 'number' && !isNaN(v)) allVals.push(v);
          });
        }
      });
      // Include the user-provided value in the axis computation
      allVals.push(value);
      // Compute new axis bounds
      let axis = computeAxis(allVals, step);
      // For income charts (employment and total), clamp minimum at zero
      // Clamp the y-axis minimum at zero for income charts (employment and composition)
      if (chart === incomeChartInstance || chart === compositionChartInstance) {
        axis.min = 0;
      }
      chart.options.scales.y.min = axis.min;
      chart.options.scales.y.max = axis.max;
      chart.update();
    }

    /**
     * Add or update a horizontal dashed line on the bar chart representing
     * the user's net worth across all provinces.
     * @param {Chart} chart The bar chart instance
     * @param {number} value The y-value for the horizontal line
     * @param {string} label The label used to identify the user's dataset
     */
    function addUserLineToBarChart(chart, value, label) {
      if (!chart) return;
      const dataArray = new Array(chart.data.labels.length).fill(value);
      const existingIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const lineDataset = {
        label: label,
        data: dataArray,
        type: 'line',
        borderColor: 'rgba(244,67,54,1)',
        borderDash: [6,3],
        borderWidth: 3,
        fill: false,
        pointRadius: 0,
        // Ensure the user line is drawn in front of bars and percentile lines
        // Draw the user line on top of all other datasets.  A high order value
        // ensures it appears in front of the bar series and percentile lines.
        order: 9999,
        // Avoid being clipped beneath chart area edges
        clip: false
      };
      if (existingIndex >= 0) {
        chart.data.datasets[existingIndex].data = dataArray;
      } else {
        chart.data.datasets.push(lineDataset);
      }
      // Recalculate the bar chart axis to ensure the user's line is visible.
      // Use the base province values plus the user value. Since the bar chart
      // step size is stored on the chart instance, we can reuse it here.
      let provinceVals = baseProvinceValues.slice();
      provinceVals.push(value);
      const step = chart.__step || 50000;
      const axis = computeAxis(provinceVals, step);
      chart.options.scales.y.min = axis.min;
      chart.options.scales.y.max = axis.max;
      chart.update();
    }

    /**
     * Reset and remove all user markers from every chart.
     */
    function resetUserData() {
      userActive = false;
      removeUserDataset(incomeChartInstance, 'You');
      removeUserDataset(compositionChartInstance, 'You');
      removeUserDataset(netWorthChartInstance, 'You');
      removeUserDataset(provinceChartInstance, 'You');
      removeUserDataset(provinceIncomeChartInstance, 'You');
      removeUserDataset(scatterChartInstance, 'You');
      // Clear percentile chart vertical lines
      if (percentileNetWorthChartInstance?.options?.plugins) {
        percentileNetWorthChartInstance.options.plugins.userVLine = { index: null };
        percentileNetWorthChartInstance.update();
      }
      if (percentileIncomeChartInstance?.options?.plugins) {
        percentileIncomeChartInstance.options.plugins.userVLine = { index: null };
        percentileIncomeChartInstance.update();
      }
      // Rescale charts back to default ranges after removing user data
      const region = document.getElementById('provinceSelect').value;
      updateCharts(region);
      // Hide insight tiles and projection section if present
      try{ showYouVsEveryone(); }catch(e){}
      try{
        const tiles = document.getElementById('resultTiles'); if (tiles) tiles.style.display = 'none';
        const projSection = document.getElementById('projectionSection'); if (projSection) projSection.style.display = 'none';
        const projCard = document.getElementById('projCard'); if (projCard) projCard.querySelector('.value').textContent = '—';
        const median65Card = document.getElementById('median65Card'); if (median65Card) median65Card.querySelector('.value').textContent = '—';
        const requiredRateCard = document.getElementById('requiredRateCard'); if (requiredRateCard) { requiredRateCard.querySelector('.value').textContent = '—'; requiredRateCard.querySelector('.label').textContent = 'Required savings rate'; }
      }catch(e){}
    }

    /**
     * Helper to remove a dataset with the given label from a chart.
     * @param {Chart} chart The chart instance
     * @param {string} label The label identifying the dataset to remove
     */
    function removeUserDataset(chart, label) {
      if (!chart) return;
      const index = chart.data.datasets.findIndex(ds => ds.label === label);
      if (index >= 0) {
        chart.data.datasets.splice(index, 1);
        chart.update();
      }
    }

    /* Helper: return ordinal string (e.g., 1st, 2nd, 3rd, 4th) */
    function ordinal(n) {
      const nn = Math.round(n);
      const s = ['th','st','nd','rd'];
      const v = nn % 100;
      return nn + (s[(v-20)%10] || s[v] || s[0]);
    }

    /* Interpolate percentile between known percentile thresholds */
    function computePercentileFromThresholds(value, thresholds) {
      if (!thresholds || thresholds.length === 0) return 50;
      if (value <= thresholds[0].v) return thresholds[0].p;
      for (let i = 1; i < thresholds.length; i++) {
        const lo = thresholds[i-1];
        const hi = thresholds[i];
        if (value <= hi.v) {
          const frac = (value - lo.v) / Math.max(1, (hi.v - lo.v));
          return lo.p + frac * (hi.p - lo.p);
        }
      }
      const last = thresholds[thresholds.length-1];
      const prev = thresholds[thresholds.length-2] || last;
      const extra = (value - last.v) / Math.max(1, (last.v - prev.v));
      return Math.min(99, last.p + extra * (99 - last.p));
    }

    /* Show the You vs Everyone insight text based on the stored user values */
    function showYouVsEveryone() {
      const incTile = document.getElementById('incomePctTile');
      const netTile = document.getElementById('netPctTile');
      const tilesWrap = document.getElementById('resultTiles');
      if (!incTile || !netTile || !tilesWrap) return;
      if (!userActive) { tilesWrap.style.display = 'none'; incTile.querySelector('.tile-value').textContent = '—'; netTile.querySelector('.tile-value').textContent = '—'; return; }
      const age = Math.max(18, Math.min(80, userAgeVal));
      const idx = age - 18;
      const region = document.getElementById('provinceSelect').value || 'Canada';
      const unit = (document.getElementById('unitSelect') || {value:'households'}).value || 'households';
      const incThresh = [
        {p:10, v: baseTotalIncomeP10[idx] * (incomeRatios[region] || 1) * (unit==='households'? HOUSEHOLD_INCOME_MULTIPLIER:1)},
        {p:25, v: baseTotalIncomeP25[idx] * (incomeRatios[region] || 1) * (unit==='households'? HOUSEHOLD_INCOME_MULTIPLIER:1)},
        {p:50, v: baseTotalIncome[idx] * (incomeRatios[region] || 1) * (unit==='households'? HOUSEHOLD_INCOME_MULTIPLIER:1)},
        {p:75, v: baseTotalIncomeP75[idx] * (incomeRatios[region] || 1) * (unit==='households'? HOUSEHOLD_INCOME_MULTIPLIER:1)},
        {p:90, v: baseTotalIncomeP90[idx] * (incomeRatios[region] || 1) * (unit==='households'? HOUSEHOLD_INCOME_MULTIPLIER:1)},
        {p:99, v: baseTotalIncomeP99[idx] * (incomeRatios[region] || 1) * (unit==='households'? HOUSEHOLD_INCOME_MULTIPLIER:1)}
      ];
      const netBase = unit==='households' ? {
        p10: baseNetWorthP10, p25: baseNetWorthP25, p50: baseNetWorth, p75: baseNetWorthP75, p90: baseNetWorthP90, p99: baseNetWorthP99
      } : {
        p10: baseIndNetWorthP10, p25: baseIndNetWorthP25, p50: baseIndNetWorth, p75: baseIndNetWorthP75, p90: baseIndNetWorthP90, p99: baseIndNetWorthP99
      };
      const netRatio = (netWorthRatios[region] || 1);
      const netThresh = [
        {p:10, v: netBase.p10[idx] * netRatio},
        {p:25, v: netBase.p25[idx] * netRatio},
        {p:50, v: netBase.p50[idx] * netRatio},
        {p:75, v: netBase.p75[idx] * netRatio},
        {p:90, v: netBase.p90[idx] * netRatio},
        {p:99, v: netBase.p99[idx] * netRatio}
      ];
      const incomePct = computePercentileFromThresholds(userIncomeVal, incThresh);
      const netPct = computePercentileFromThresholds(userNetWorthVal, netThresh);
      const unitLabel = (unit==='households') ? `${region} households` : `${region} individuals`;
      tilesWrap.style.display = 'flex';
      incTile.querySelector('.tile-value').textContent = ordinal(incomePct);
      incTile.querySelector('.tile-sub').textContent = `among ${unitLabel} • age ${age}`;
      netTile.querySelector('.tile-value').textContent = ordinal(netPct);
      netTile.querySelector('.tile-sub').textContent = `among ${unitLabel} • age ${age}`;
    }

    /* Inject small download buttons under each chart and wire to Chart.toBase64Image() */
    function addDownloadButtons() {
      const canvases = document.querySelectorAll('.chart-card canvas');
      canvases.forEach(canvas => {
        const card = canvas.closest('.chart-card');
        if (!card) return;
        if (card.querySelector('.download-btn')) return;
        const btn = document.createElement('button');
        btn.className = 'download-btn';
        btn.type = 'button';
        btn.title = 'Download chart as PNG';
        btn.textContent = 'Download PNG';
        btn.addEventListener('click', function() { downloadChart(canvas.id); });
        const chartContainer = card.querySelector('.chart-container');
        if (chartContainer) chartContainer.insertAdjacentElement('afterend', btn);
      });
    }

    function downloadChart(canvasId) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) { alert('Chart not found'); return; }
      let chart = null;
      try { chart = Chart.getChart(canvas); } catch(e) { chart = null; }
      if (!chart) {
        const altName = canvasId + 'Instance';
        chart = window[altName] || null;
      }
      if (!chart) { alert('Chart instance not available for download.'); return; }
      const url = chart.toBase64Image();
      const a = document.createElement('a');
      a.href = url;
      a.download = canvasId + '.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    /* ---------------- Savings projection tools ---------------- */
    function formatCurrency(n) {
      return '$' + Math.round(n).toLocaleString();
    }

    function projectNetWorthToAge(savingsRatePct, targetAge, opts = {}) {
      // savingsRatePct is percent (0-100)
      const r = opts.returnRate !== undefined ? opts.returnRate : 0.03; // annual real return
      if (!userActive) { return { error: 'Enter your age, income and net worth and click Compare first.' }; }
      const startAge = Math.max(18, Math.min(80, userAgeVal));
      const idxStart = startAge - 18;
      const idxTarget = Math.max(0, Math.min(ageLabels.length-1, targetAge - 18));
      if (targetAge <= startAge) {
        return { projected: userNetWorthVal, years: 0 };
      }
      const unit = (document.getElementById('unitSelect') || {value:'households'}).value || 'households';
      const region = document.getElementById('provinceSelect').value || 'Canada';
      const incomeRatio = (incomeRatios[region] || 1);
      const householdMult = (unit==='households') ? HOUSEHOLD_INCOME_MULTIPLIER : 1;
      // Map user's income growth to baseTotalIncome growth curve
      const baseAtStart = baseTotalIncome[idxStart] * incomeRatio * householdMult;
      let balance = userNetWorthVal;
      for (let a = startAge; a < targetAge; a++) {
        const idx = Math.max(0, Math.min(ageLabels.length-1, a - 18));
        const idxNext = Math.max(0, Math.min(ageLabels.length-1, a+1 - 18));
        // Projected income next year based on growth factor from baseTotalIncome
        const growthFactor = baseTotalIncome[idxNext] / Math.max(1, baseTotalIncome[idx]);
        // Estimate this year's income as scaled from user's current income
        // Use ratio of baseTotalIncome at this age to base at start
        const incomeThisYear = userIncomeVal * (baseTotalIncome[idx] / baseTotalIncome[idxStart]) * incomeRatio * householdMult;
        const saving = incomeThisYear * (savingsRatePct/100);
        // Apply return then add saving (assume saving at year end)
        balance = balance * (1 + r) + saving;
      }
      return { projected: balance, years: targetAge - startAge };
    }

    function requiredSavingsRateForPercentile(targetPct, targetAge, opts = {}) {
      if (!userActive) { return { error: 'Enter your age, income and net worth and click Compare first.' }; }
      const maxRate = 100; // percent
      const tol = 0.1; // 0.1% precision
      let lo = 0, hi = maxRate, mid = 0;
      const desired = targetPct;
      // Determine goal net worth at target age for 90th percentile using base arrays scaled
      const ageIdx = Math.max(0, Math.min(ageLabels.length-1, targetAge - 18));
      const unit = (document.getElementById('unitSelect') || {value:'households'}).value || 'households';
      const region = document.getElementById('provinceSelect').value || 'Canada';
      const netBase = unit==='households' ? baseNetWorthP90 : baseIndNetWorthP90;
      // Project the percentile baseline forward to the year the user reaches targetAge.
      // base arrays are 2025 values; yearsToTarget is how many years from now until the user
      // reaches the target age: targetAge - userAgeVal. Use 3.5% real growth per year.
      const yearsToTarget = Math.max(0, targetAge - userAgeVal);
      const growth = opts.percentileGrowth !== undefined ? opts.percentileGrowth : 0.035;
      const netGoal = netBase[ageIdx] * (netWorthRatios[region] || 1) * Math.pow(1 + growth, yearsToTarget);
      // Quick check: if current net worth already >= goal
      if (userNetWorthVal >= netGoal) return { rate: 0, reachable: true, goal: netGoal };
      // Binary search for required savings rate
      let resultRate = null;
      for (let i=0;i<40;i++) {
        mid = (lo + hi) / 2;
        const proj = projectNetWorthToAge(mid, targetAge, opts);
        if (proj.error) return { error: proj.error };
        const val = proj.projected;
        if (Math.abs(val - netGoal) < Math.max(1000, 0.01 * netGoal)) { resultRate = mid; break; }
        if (val < netGoal) lo = mid; else hi = mid;
        resultRate = mid;
      }
      const reachable = resultRate <= maxRate;
      return { rate: Math.min(resultRate, maxRate), reachable, goal: netGoal };
    }

    // Wire projection buttons
    document.addEventListener('click', function(e){
      if (e.target && e.target.id === 'projectBtn') {
        // Combined action: project to 65 using the supplied savings rate,
        // and compute the required savings rate to reach the 90th percentile
        // by the chosen target age. Results are merged into a single output.
        const sr = parseFloat(document.getElementById('savingsRate').value);
        const tgtAge = parseInt(document.getElementById('targetAge').value,10);
        if (isNaN(sr) || sr < 0 || sr > 200) { alert('Enter a valid savings rate (0-200%).'); return; }
        if (isNaN(tgtAge) || tgtAge < 18 || tgtAge > 100) { alert('Enter a valid target age (18-100).'); return; }
        // Run projection to age 65 (user's projected net worth at that age)
        const proj = projectNetWorthToAge(sr, 65);
        if (proj.error) { alert(proj.error); return; }
        // Compute the calendar year for that projection and the 2025-adjusted value
        const yearsToProj65 = Math.max(0, 65 - userAgeVal);
        const yearAt65 = 2025 + yearsToProj65;
        const pctGrowth = 0.035; // 3.5% used to project percentiles and to convert to 2025 dollars
        const projAdj2025 = proj.projected / Math.pow(1 + pctGrowth, yearsToProj65);
        // Compare to median net worth at 65 for region/unit
        // Compare to projected median net worth at 65 for region/unit
        const region = document.getElementById('provinceSelect').value || 'Canada';
        const unit = (document.getElementById('unitSelect') || {value:'households'}).value || 'households';
        const ageIdx65 = 65 - 18;
        // Project the 2025 median at age 65 forward by the number of years until the user reaches 65
        const yearsTo65 = yearsToProj65;
        const medianNet65 = ((unit==='households') ? baseNetWorth[ageIdx65] : baseIndNetWorth[ageIdx65]) * (netWorthRatios[region] || 1) * Math.pow(1 + pctGrowth, yearsTo65);
        // Populate projection cards
        const projCard = document.getElementById('projCard');
        const median65Card = document.getElementById('median65Card');
        const requiredRateCard = document.getElementById('requiredRateCard');
        if (projCard) projCard.querySelector('.value').textContent = formatCurrency(proj.projected) + ` (${yearAt65})`;
        if (median65Card) median65Card.querySelector('.value').textContent = formatCurrency(medianNet65) + ` (${yearAt65})`;
        // Run required savings rate calculation for 90th percentile by target age
        const req = requiredSavingsRateForPercentile(90, tgtAge);
        if (req.error) { alert(req.error); return; }
        // Build combined output
        let html = '';
        // Also show the target-year and 2025-adjusted value for the 90th percentile goal
        const yearsToReq = Math.max(0, tgtAge - userAgeVal);
        const yearAtReq = 2025 + yearsToReq;
        const reqAdj2025 = req.goal / Math.pow(1 + pctGrowth, yearsToReq);
        // Update the required-rate card
        if (requiredRateCard) {
          if (!req.reachable) {
            requiredRateCard.querySelector('.value').textContent = 'Unrealistic';
            requiredRateCard.querySelector('.label').textContent = `Goal (${yearAtReq}) ${formatCurrency(req.goal)}`;
          } else {
            requiredRateCard.querySelector('.value').textContent = req.rate.toFixed(1) + '%';
            requiredRateCard.querySelector('.label').textContent = `Goal (${yearAtReq}) ${formatCurrency(req.goal)}`;
          }
        }
        // Show projection section if hidden
        const projSection = document.getElementById('projectionSection');
        if (projSection) projSection.style.display = 'block';
      }
    });

    /**
     * Add or update the user's point on the scatter chart (income vs net worth).
     * Ensures the axes include the user's point and draws it prominently in red.
     * @param {Chart} chart The scatter chart instance
     * @param {number} incomeX The user's income (x value)
     * @param {number} netWorthY The user's net worth (y value)
     * @param {string} label Dataset label (e.g., 'You')
     */
    function addUserPointToScatter(chart, incomeX, netWorthY, label) {
      if (!chart) return;
      const userDsIndex = chart.data.datasets.findIndex(ds => ds.label === label);
      const userDs = {
        label: label,
        type: 'scatter',
        data: [ { x: incomeX, y: netWorthY } ],
        borderColor: 'rgba(244,67,54,1)',
        backgroundColor: 'rgba(244,67,54,1)',
        pointStyle: 'circle',
        pointBackgroundColor: 'rgba(244,67,54,1)',
        pointBorderColor: 'rgba(244,67,54,1)',
        pointRadius: 6,
        pointHoverRadius: 7,
        showLine: false,
        order: 9999,
        clip: false
      };
      if (userDsIndex >= 0) {
        chart.data.datasets[userDsIndex] = Object.assign(chart.data.datasets[userDsIndex], userDs);
      } else {
        chart.data.datasets.push(userDs);
      }

      // Recompute axes to include the user's point alongside the base series
      const baseData = (chart.data.datasets[0] && Array.isArray(chart.data.datasets[0].data)) ? chart.data.datasets[0].data : [];
      const xVals = baseData.map(p => p.x);
      const yVals = baseData.map(p => p.y);
      xVals.push(incomeX);
      yVals.push(netWorthY);
      const xAxis = computeAxis(xVals, 5000);
      const yAxis = computeAxis(yVals, 200000);
      if (!chart.options.scales) chart.options.scales = {};
      if (!chart.options.scales.x) chart.options.scales.x = { type: 'linear', position: 'bottom' };
      if (!chart.options.scales.y) chart.options.scales.y = {};
      chart.options.scales.x.min = Math.max(0, xAxis.min);
      chart.options.scales.x.max = xAxis.max;
      chart.options.scales.y.min = yAxis.min;
      chart.options.scales.y.max = yAxis.max;
      chart.update();
    }

    /* Capture a snapshot of the small summary tiles + projection area and download as PNG */
    async function captureSnapshot() {
      try {
        ensureChartsInitialized();
        const tiles = document.getElementById('resultTiles');
        const proj = document.getElementById('projectionSection');
        // Build a temporary container and clone the nodes we want to capture
        const container = document.createElement('div');
        container.style.background = getComputedStyle(document.body).background || '#0a1931';
        container.style.color = getComputedStyle(document.body).color || '#e0e6ed';
        container.style.padding = '18px';
        container.style.width = '1200px';
        container.style.boxSizing = 'border-box';
        // Add a small header
        const h = document.createElement('div');
        h.style.fontWeight = '700';
        h.style.marginBottom = '8px';
        h.textContent = 'Your Snapshot — Summary';
        container.appendChild(h);
        if (tiles) container.appendChild(tiles.cloneNode(true));
        if (proj && proj.style.display !== 'none') container.appendChild(proj.cloneNode(true));
        // Place off-screen so it doesn't flash
        container.style.position = 'fixed';
        container.style.left = '-9999px';
        container.style.top = '0';
        document.body.appendChild(container);
        // Use html2canvas to capture
        const canvas = await html2canvas(container, { scale: 2, useCORS: true, backgroundColor: null });
        const url = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = url;
        a.download = 'my_snapshot.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
        // Clean up
        container.remove();
      } catch (err) {
        console.error('Snapshot failed', err);
        alert('Snapshot failed. Please try again or use the chart download buttons.');
      }
    }

    // Wire snapshot button and set footer date after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      const btn = document.getElementById('snapshotBtn');
      if (btn) btn.addEventListener('click', function(){ captureSnapshot(); });
      const d = new Date();
      const el = document.getElementById('lastUpdated');
      if (el) el.textContent = d.toLocaleDateString();
    });
  </script>
</body>
</html>
